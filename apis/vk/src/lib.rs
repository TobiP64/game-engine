//! MACHINE GENERATED FILE, DO NOT EDIT
#![feature(try_trait_v2, stmt_expr_attributes)]
#![warn(clippy::all)]
#![allow(
non_snake_case,
non_upper_case_globals,
non_camel_case_types,
unused_attributes,
unused_parens,
invalid_value,
clippy::unused_unit,
clippy::too_many_arguments,
clippy::enum_clike_unportable_variant,
clippy::unnecessary_cast,
clippy::missing_safety_doc,
clippy::from_over_into,
clippy::upper_case_acronyms,
clippy::mixed_case_hex_literals
)]

use {
	core::{mem::{transmute, MaybeUninit}, ops, fmt},
	std::sync::Arc,
	self::external::*
};

pub use types::*;

/// Contains some useful types
mod types {
	#[derive(Copy, Clone, Debug)]
	#[repr(transparent)]
	pub struct VkAnyRef<'b>(&'b ());
	
	impl<'a> VkAnyRef<'a> {
		#[allow(clippy::transmute_ptr_to_ptr)]
		pub const fn new<T>(v: &'a T) -> Self {
			Self(unsafe { std::mem::transmute(v) })
		}
	}
	
	impl<'a, T> From<&'a T> for VkAnyRef<'a> {
		fn from(v: &'a T) -> Self {
			unsafe { Self((v as *const T as *const ()).as_ref().unwrap()) }
		}
	}
	
	impl<'a, T> Into<*const T> for VkAnyRef<'a> {
		fn into(self) -> *const T {
			self.0 as *const () as *const T
		}
	}
	
	#[derive(Debug)]
	#[repr(transparent)]
	pub struct VkAnyMut<'b>(&'b mut ());
	
	impl<'a> VkAnyMut<'a> {
		pub fn new<T>(v: &'a mut T) -> Self {
			Self(unsafe { &mut*(v as *mut T as *mut ()) })
		}
	}
	
	impl<'a, T> From<&'a mut T> for VkAnyMut<'a> {
		fn from(v: &'a mut T) -> Self {
			unsafe { Self((v as *mut T as *mut ()).as_mut().unwrap()) }
		}
	}
	
	impl<'a, T> Into<*mut T> for VkAnyMut<'a> {
		fn into(self) -> *mut T {
			self.0 as *mut () as *mut T
		}
	}
}

pub mod external {
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum wl_display {}
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum wl_surface {}
	
	impl wl_display {
		pub unsafe fn from_ptr<'a, T>(ptr: *mut T) -> Option<&'a mut Self> {
			(ptr as *mut Self).as_mut()
		}
	}
	
	impl wl_surface {
		pub unsafe fn from_ptr<'a, T>(ptr: *mut T) -> Option<&'a mut Self> {
			(ptr as *mut Self).as_mut()
		}
	}
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum xcb_connection_t {}
	pub type xcb_window_t   = u32;
	pub type xcb_visualid_t = u32;
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum Display {}
	pub type VisualID = u32;
	pub type Window   = u32;
	pub type RROutput = u32;
	
	pub type GgpStreamDescriptor = usize;
	pub type GgpFrameToken       = usize;
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum ANativeWindow {}
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum AHardwareBuffer {}
	
	pub type zx_handle_t = usize;
	
	pub type HINSTANCE = Option<std::ptr::NonNull<()>>;
	pub type HWND      = Option<std::ptr::NonNull<()>>;
	pub type HMONITOR  = Option<std::ptr::NonNull<()>>;
	pub type HANDLE    = Option<std::ptr::NonNull<()>>;
	pub type DWORD     = u32;
	pub type LPCWSTR   = Option<std::ptr::NonNull<u16>>;
	
	#[derive(Debug, Copy, Clone, Eq, PartialEq)]
	pub struct SECURITY_ATTRIBUTES {
		pub nLength:              DWORD,
		pub lpSecurityDescriptor: Option<std::ptr::NonNull<()>>,
		pub bInheritHandle:       i32
	}
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum CAMetalLayer {}
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum IDirectFB {}
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum IDirectFBSurface {}
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum _screen_context {}
	
	#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
	pub enum _screen_window {}
	
	pub struct StdVideoH264ProfileIdc;
	pub struct StdVideoH264SequenceParameterSet;
	pub struct StdVideoH264PictureParameterSet;
	pub struct StdVideoDecodeH264PictureInfo;
	pub struct StdVideoDecodeH264ReferenceInfo;
	pub struct StdVideoDecodeH264Mvc;
	pub struct StdVideoEncodeH264PictureInfo;
	pub struct StdVideoEncodeH264SliceHeader;
	pub struct StdVideoH265ProfileIdc;
	pub struct StdVideoH265SequenceParameterSet;
	pub struct StdVideoH265PictureParameterSet;
	pub struct StdVideoDecodeH265PictureInfo;
	pub struct StdVideoDecodeH265ReferenceInfo;
}

pub const VK_NULL_HANDLE        : u64 = 0;
/// Vulkan 1.0 version number
pub const VK_API_VERSION_1_0    : u32 = VK_MAKE_VERSION(1, 0, 0);
/// Vulkan 1.1 version number
pub const VK_API_VERSION_1_1    : u32 = VK_MAKE_VERSION(1, 1, 0);
/// Vulkan 1.1 version number
pub const VK_API_VERSION_1_2    : u32 = VK_MAKE_VERSION(1, 2, 0);

#[cfg(unix)]
const LIB: &str = "libvulkan.so.1";
#[cfg(windows)]
const LIB: &str = "vulkan-1.dll";

impl<T, E: From<VkResult>> std::ops::FromResidual<VkResult> for Result<T, E> {
	fn from_residual(r: VkResult) -> Self {
		Err(r.into())
	}
}

impl<T, E: Into<VkResult>> std::ops::FromResidual<Result<T, E>> for VkResult {
	fn from_residual(r: Result<T, E>) -> Self {
		match r {
			Ok(_) => VK_SUCCESS,
			Err(v) => v.into()
		}
	}
}

impl ops::FromResidual<VkResult> for VkResult {
	fn from_residual(residual: VkResult) -> Self {
		residual
	}
}

impl ops::Try for VkResult {
	type Output = Self;
	type Residual = Self;
	
	fn from_output(output: Self::Output) -> Self {
		output
	}
	
	fn branch(self) -> ops::ControlFlow<Self::Residual, Self::Output> {
		if self as i32 >= 0 {
			ops::ControlFlow::Continue(self)
		} else {
			ops::ControlFlow::Break(self)
		}
	}
}

impl Into<Result<Self, Self>> for VkResult {
	fn into(self) -> Result<VkResult, VkResult> {
		if self as i32 >= 0 {
			Ok(self)
		} else {
			Err(self)
		}
	}
}

impl std::error::Error for VkResult {}

impl fmt::Display for VkResult {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		fmt::Debug::fmt(self, f)
	}
}

// Copyright 2015-2021 The Khronos Group Inc.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT
// This file, vk.xml, is the Vulkan API Registry. It is a critically important
// and normative part of the Vulkan Specification, including a canonical
// machine-readable definition of the API, parameter and member validation
// language incorporated into the Specification and reference pages, and other
// material which is registered by Khronos, such as tags used by extension and
// layer authors. The authoritative public version of vk.xml is maintained in
// the default branch (currently named main) of the Khronos Vulkan GitHub
// project. The authoritative private version is maintained in the default
// branch of the member gitlab server.
// Vulkan type definitions
// WSI extensions
// In the current header structure, each platform's interfaces
// are confined to a platform-specific header (vulkan_xlib.h,
// vulkan_win32.h, etc.). These headers are not self-contained,
// and should not include native headers (X11/Xlib.h,
// windows.h, etc.). Code should either include vulkan.h after
// defining the appropriate VK_USE_PLATFORM_platform
// macros, or include the required native headers prior to
// explicitly including the corresponding platform header.
//
// To accomplish this, the dependencies of native types require
// native headers, but the XML defines the content for those
// native headers as empty. The actual native header includes
// can be restored by modifying the native header tags above
// to #include the header file in the 'name' attribute.

pub type VkSampleMask                                  = u32;

pub type VkBool32                                      = u32;

pub type VkFlags                                       = u32;

pub type VkFlags64                                     = u64;

pub type VkDeviceSize                                  = u64;

pub type VkDeviceAddress                               = u64;
// Basic C types, pulled in via vk_platform.h
// Bitmask types

pub type VkFramebufferCreateFlags                      = VkFlags;

pub type VkQueryPoolCreateFlags                        = VkFlags;

pub type VkRenderPassCreateFlags                       = VkFlags;

pub type VkSamplerCreateFlags                          = VkFlags;

pub type VkPipelineLayoutCreateFlags                   = VkFlags;

pub type VkPipelineCacheCreateFlags                    = VkFlags;

pub type VkPipelineDepthStencilStateCreateFlags        = VkFlags;

pub type VkPipelineDynamicStateCreateFlags             = VkFlags;

pub type VkPipelineColorBlendStateCreateFlags          = VkFlags;

pub type VkPipelineMultisampleStateCreateFlags         = VkFlags;

pub type VkPipelineRasterizationStateCreateFlags       = VkFlags;

pub type VkPipelineViewportStateCreateFlags            = VkFlags;

pub type VkPipelineTessellationStateCreateFlags        = VkFlags;

pub type VkPipelineInputAssemblyStateCreateFlags       = VkFlags;

pub type VkPipelineVertexInputStateCreateFlags         = VkFlags;

pub type VkPipelineShaderStageCreateFlags              = VkFlags;

pub type VkDescriptorSetLayoutCreateFlags              = VkFlags;

pub type VkBufferViewCreateFlags                       = VkFlags;

pub type VkInstanceCreateFlags                         = VkFlags;

pub type VkDeviceCreateFlags                           = VkFlags;

pub type VkDeviceQueueCreateFlags                      = VkFlags;

pub type VkQueueFlags                                  = VkFlags;

pub type VkMemoryPropertyFlags                         = VkFlags;

pub type VkMemoryHeapFlags                             = VkFlags;

pub type VkAccessFlags                                 = VkFlags;

pub type VkBufferUsageFlags                            = VkFlags;

pub type VkBufferCreateFlags                           = VkFlags;

pub type VkShaderStageFlags                            = VkFlags;

pub type VkImageUsageFlags                             = VkFlags;

pub type VkImageCreateFlags                            = VkFlags;

pub type VkImageViewCreateFlags                        = VkFlags;

pub type VkPipelineCreateFlags                         = VkFlags;

pub type VkColorComponentFlags                         = VkFlags;

pub type VkFenceCreateFlags                            = VkFlags;
// When VkSemaphoreCreateFlagBits is first extended, need to add a requires= attribute for it to VkSemaphoreCreateFlags

pub type VkSemaphoreCreateFlags                        = VkFlags;

pub type VkFormatFeatureFlags                          = VkFlags;

pub type VkQueryControlFlags                           = VkFlags;

pub type VkQueryResultFlags                            = VkFlags;

pub type VkShaderModuleCreateFlags                     = VkFlags;

pub type VkEventCreateFlags                            = VkFlags;

pub type VkCommandPoolCreateFlags                      = VkFlags;

pub type VkCommandPoolResetFlags                       = VkFlags;

pub type VkCommandBufferResetFlags                     = VkFlags;

pub type VkCommandBufferUsageFlags                     = VkFlags;

pub type VkQueryPipelineStatisticFlags                 = VkFlags;

pub type VkMemoryMapFlags                              = VkFlags;

pub type VkImageAspectFlags                            = VkFlags;

pub type VkSparseMemoryBindFlags                       = VkFlags;

pub type VkSparseImageFormatFlags                      = VkFlags;

pub type VkSubpassDescriptionFlags                     = VkFlags;

pub type VkPipelineStageFlags                          = VkFlags;

pub type VkSampleCountFlags                            = VkFlags;

pub type VkAttachmentDescriptionFlags                  = VkFlags;

pub type VkStencilFaceFlags                            = VkFlags;

pub type VkCullModeFlags                               = VkFlags;

pub type VkDescriptorPoolCreateFlags                   = VkFlags;

pub type VkDescriptorPoolResetFlags                    = VkFlags;

pub type VkDependencyFlags                             = VkFlags;

pub type VkSubgroupFeatureFlags                        = VkFlags;

pub type VkIndirectCommandsLayoutUsageFlagsNV          = VkFlags;

pub type VkIndirectStateFlagsNV                        = VkFlags;

pub type VkGeometryFlagsKHR                            = VkFlags;

pub type VkGeometryFlagsNV                             = VkGeometryFlagsKHR;

pub type VkGeometryInstanceFlagsKHR                    = VkFlags;

pub type VkGeometryInstanceFlagsNV                     = VkGeometryInstanceFlagsKHR;

pub type VkBuildAccelerationStructureFlagsKHR          = VkFlags;

pub type VkBuildAccelerationStructureFlagsNV           = VkBuildAccelerationStructureFlagsKHR;

pub type VkPrivateDataSlotCreateFlagsEXT               = VkFlags;

pub type VkAccelerationStructureCreateFlagsKHR         = VkFlags;

pub type VkDescriptorUpdateTemplateCreateFlags         = VkFlags;

pub type VkDescriptorUpdateTemplateCreateFlagsKHR      = VkDescriptorUpdateTemplateCreateFlags;

pub type VkPipelineCreationFeedbackFlagsEXT            = VkFlags;

pub type VkPerformanceCounterDescriptionFlagsKHR       = VkFlags;

pub type VkAcquireProfilingLockFlagsKHR                = VkFlags;

pub type VkSemaphoreWaitFlags                          = VkFlags;

pub type VkSemaphoreWaitFlagsKHR                       = VkSemaphoreWaitFlags;

pub type VkPipelineCompilerControlFlagsAMD             = VkFlags;

pub type VkShaderCorePropertiesFlagsAMD                = VkFlags;

pub type VkDeviceDiagnosticsConfigFlagsNV              = VkFlags;

pub type VkAccessFlags2KHR                             = VkFlags64;

pub type VkPipelineStageFlags2KHR                      = VkFlags64;

pub type VkAccelerationStructureMotionInfoFlagsNV      = VkFlags;

pub type VkAccelerationStructureMotionInstanceFlagsNV  = VkFlags;
// WSI extensions

pub type VkCompositeAlphaFlagsKHR                      = VkFlags;

pub type VkDisplayPlaneAlphaFlagsKHR                   = VkFlags;

pub type VkSurfaceTransformFlagsKHR                    = VkFlags;

pub type VkSwapchainCreateFlagsKHR                     = VkFlags;

pub type VkDisplayModeCreateFlagsKHR                   = VkFlags;

pub type VkDisplaySurfaceCreateFlagsKHR                = VkFlags;

pub type VkAndroidSurfaceCreateFlagsKHR                = VkFlags;

pub type VkViSurfaceCreateFlagsNN                      = VkFlags;

pub type VkWaylandSurfaceCreateFlagsKHR                = VkFlags;

pub type VkWin32SurfaceCreateFlagsKHR                  = VkFlags;

pub type VkXlibSurfaceCreateFlagsKHR                   = VkFlags;

pub type VkXcbSurfaceCreateFlagsKHR                    = VkFlags;

pub type VkDirectFBSurfaceCreateFlagsEXT               = VkFlags;

pub type VkIOSSurfaceCreateFlagsMVK                    = VkFlags;

pub type VkMacOSSurfaceCreateFlagsMVK                  = VkFlags;

pub type VkMetalSurfaceCreateFlagsEXT                  = VkFlags;

pub type VkImagePipeSurfaceCreateFlagsFUCHSIA          = VkFlags;

pub type VkStreamDescriptorSurfaceCreateFlagsGGP       = VkFlags;

pub type VkHeadlessSurfaceCreateFlagsEXT               = VkFlags;

pub type VkScreenSurfaceCreateFlagsQNX                 = VkFlags;

pub type VkPeerMemoryFeatureFlags                      = VkFlags;

pub type VkPeerMemoryFeatureFlagsKHR                   = VkPeerMemoryFeatureFlags;

pub type VkMemoryAllocateFlags                         = VkFlags;

pub type VkMemoryAllocateFlagsKHR                      = VkMemoryAllocateFlags;

pub type VkDeviceGroupPresentModeFlagsKHR              = VkFlags;

pub type VkDebugReportFlagsEXT                         = VkFlags;

pub type VkCommandPoolTrimFlags                        = VkFlags;

pub type VkCommandPoolTrimFlagsKHR                     = VkCommandPoolTrimFlags;

pub type VkExternalMemoryHandleTypeFlagsNV             = VkFlags;

pub type VkExternalMemoryFeatureFlagsNV                = VkFlags;

pub type VkExternalMemoryHandleTypeFlags               = VkFlags;

pub type VkExternalMemoryHandleTypeFlagsKHR            = VkExternalMemoryHandleTypeFlags;

pub type VkExternalMemoryFeatureFlags                  = VkFlags;

pub type VkExternalMemoryFeatureFlagsKHR               = VkExternalMemoryFeatureFlags;

pub type VkExternalSemaphoreHandleTypeFlags            = VkFlags;

pub type VkExternalSemaphoreHandleTypeFlagsKHR         = VkExternalSemaphoreHandleTypeFlags;

pub type VkExternalSemaphoreFeatureFlags               = VkFlags;

pub type VkExternalSemaphoreFeatureFlagsKHR            = VkExternalSemaphoreFeatureFlags;

pub type VkSemaphoreImportFlags                        = VkFlags;

pub type VkSemaphoreImportFlagsKHR                     = VkSemaphoreImportFlags;

pub type VkExternalFenceHandleTypeFlags                = VkFlags;

pub type VkExternalFenceHandleTypeFlagsKHR             = VkExternalFenceHandleTypeFlags;

pub type VkExternalFenceFeatureFlags                   = VkFlags;

pub type VkExternalFenceFeatureFlagsKHR                = VkExternalFenceFeatureFlags;

pub type VkFenceImportFlags                            = VkFlags;

pub type VkFenceImportFlagsKHR                         = VkFenceImportFlags;

pub type VkSurfaceCounterFlagsEXT                      = VkFlags;

pub type VkPipelineViewportSwizzleStateCreateFlagsNV   = VkFlags;

pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;

pub type VkPipelineCoverageToColorStateCreateFlagsNV   = VkFlags;

pub type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;

pub type VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;

pub type VkValidationCacheCreateFlagsEXT               = VkFlags;

pub type VkDebugUtilsMessageSeverityFlagsEXT           = VkFlags;

pub type VkDebugUtilsMessageTypeFlagsEXT               = VkFlags;

pub type VkDebugUtilsMessengerCreateFlagsEXT           = VkFlags;

pub type VkDebugUtilsMessengerCallbackDataFlagsEXT     = VkFlags;

pub type VkDeviceMemoryReportFlagsEXT                  = VkFlags;

pub type VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;

pub type VkDescriptorBindingFlags                      = VkFlags;

pub type VkDescriptorBindingFlagsEXT                   = VkDescriptorBindingFlags;

pub type VkConditionalRenderingFlagsEXT                = VkFlags;

pub type VkResolveModeFlags                            = VkFlags;

pub type VkResolveModeFlagsKHR                         = VkResolveModeFlags;

pub type VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;

pub type VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;

pub type VkSwapchainImageUsageFlagsANDROID             = VkFlags;

pub type VkToolPurposeFlagsEXT                         = VkFlags;

pub type VkSubmitFlagsKHR                              = VkFlags;
// Video Core extension

pub type VkVideoCodecOperationFlagsKHR                 = VkFlags;

pub type VkVideoCapabilitiesFlagsKHR                   = VkFlags;

pub type VkVideoSessionCreateFlagsKHR                  = VkFlags;

pub type VkVideoBeginCodingFlagsKHR                    = VkFlags;

pub type VkVideoEndCodingFlagsKHR                      = VkFlags;

pub type VkVideoCodingQualityPresetFlagsKHR            = VkFlags;

pub type VkVideoCodingControlFlagsKHR                  = VkFlags;
// Video Decode Core extension

pub type VkVideoDecodeFlagsKHR                         = VkFlags;
// Video Decode H.264 extension

pub type VkVideoDecodeH264FieldLayoutFlagsEXT          = VkFlags;

pub type VkVideoDecodeH264CreateFlagsEXT               = VkFlags;
// Video Decode H.265 extension

pub type VkVideoDecodeH265CreateFlagsEXT               = VkFlags;
// Video Encode Core extension

pub type VkVideoEncodeFlagsKHR                         = VkFlags;

pub type VkVideoEncodeRateControlFlagsKHR              = VkFlags;

pub type VkVideoEncodeRateControlModeFlagsKHR          = VkFlags;

pub type VkVideoChromaSubsamplingFlagsKHR              = VkFlags;

pub type VkVideoComponentBitDepthFlagsKHR              = VkFlags;
// Video Encode H.264 extension

pub type VkVideoEncodeH264CapabilitiesFlagsEXT         = VkFlags;

pub type VkVideoEncodeH264InputModeFlagsEXT            = VkFlags;

pub type VkVideoEncodeH264OutputModeFlagsEXT           = VkFlags;

pub type VkVideoEncodeH264CreateFlagsEXT               = VkFlags;
// Types which can be void pointers or class pointers, selected at compile time

pub type VkInstance                                    = u64;

pub type VkPhysicalDevice                              = u64;

pub type VkDevice                                      = u64;

pub type VkQueue                                       = u64;

pub type VkCommandBuffer                               = u64;

pub type VkDeviceMemory                                = u64;

pub type VkCommandPool                                 = u64;

pub type VkBuffer                                      = u64;

pub type VkBufferView                                  = u64;

pub type VkImage                                       = u64;

pub type VkImageView                                   = u64;

pub type VkShaderModule                                = u64;

pub type VkPipeline                                    = u64;

pub type VkPipelineLayout                              = u64;

pub type VkSampler                                     = u64;

pub type VkDescriptorSet                               = u64;

pub type VkDescriptorSetLayout                         = u64;

pub type VkDescriptorPool                              = u64;

pub type VkFence                                       = u64;

pub type VkSemaphore                                   = u64;

pub type VkEvent                                       = u64;

pub type VkQueryPool                                   = u64;

pub type VkFramebuffer                                 = u64;

pub type VkRenderPass                                  = u64;

pub type VkPipelineCache                               = u64;

pub type VkIndirectCommandsLayoutNV                    = u64;

pub type VkDescriptorUpdateTemplate                    = u64;

pub type VkDescriptorUpdateTemplateKHR                 = VkDescriptorUpdateTemplate;

pub type VkSamplerYcbcrConversion                      = u64;

pub type VkSamplerYcbcrConversionKHR                   = VkSamplerYcbcrConversion;

pub type VkValidationCacheEXT                          = u64;

pub type VkAccelerationStructureKHR                    = u64;

pub type VkAccelerationStructureNV                     = u64;

pub type VkPerformanceConfigurationINTEL               = u64;

pub type VkDeferredOperationKHR                        = u64;

pub type VkPrivateDataSlotEXT                          = u64;

pub type VkCuModuleNVX                                 = u64;

pub type VkCuFunctionNVX                               = u64;
// WSI extensions

pub type VkDisplayKHR                                  = u64;

pub type VkDisplayModeKHR                              = u64;

pub type VkSurfaceKHR                                  = u64;

pub type VkSwapchainKHR                                = u64;

pub type VkDebugReportCallbackEXT                      = u64;

pub type VkDebugUtilsMessengerEXT                      = u64;
// Video extensions

pub type VkVideoSessionKHR                             = u64;

pub type VkVideoSessionParametersKHR                   = u64;
// Types generated from corresponding enums tags below
// When VkSemaphoreCreateFlagBits is first extended, need to add a type enum tag for it here
// Extensions

pub type VkDescriptorUpdateTemplateTypeKHR             = VkDescriptorUpdateTemplateType;

pub type VkPointClippingBehaviorKHR                    = VkPointClippingBehavior;

pub type VkResolveModeFlagBitsKHR                      = VkResolveModeFlagBits;

pub type VkDescriptorBindingFlagBitsEXT                = VkDescriptorBindingFlagBits;

pub type VkSemaphoreTypeKHR                            = VkSemaphoreType;

pub type VkGeometryFlagBitsNV                          = VkGeometryFlagBitsKHR;

pub type VkGeometryInstanceFlagBitsNV                  = VkGeometryInstanceFlagBitsKHR;

pub type VkBuildAccelerationStructureFlagBitsNV        = VkBuildAccelerationStructureFlagBitsKHR;

pub type VkCopyAccelerationStructureModeNV             = VkCopyAccelerationStructureModeKHR;

pub type VkAccelerationStructureTypeNV                 = VkAccelerationStructureTypeKHR;

pub type VkGeometryTypeNV                              = VkGeometryTypeKHR;

pub type VkRayTracingShaderGroupTypeNV                 = VkRayTracingShaderGroupTypeKHR;

pub type VkSemaphoreWaitFlagBitsKHR                    = VkSemaphoreWaitFlagBits;
// WSI extensions

pub type VkExternalMemoryHandleTypeFlagBitsKHR         = VkExternalMemoryHandleTypeFlagBits;

pub type VkExternalMemoryFeatureFlagBitsKHR            = VkExternalMemoryFeatureFlagBits;

pub type VkExternalSemaphoreHandleTypeFlagBitsKHR      = VkExternalSemaphoreHandleTypeFlagBits;

pub type VkExternalSemaphoreFeatureFlagBitsKHR         = VkExternalSemaphoreFeatureFlagBits;

pub type VkSemaphoreImportFlagBitsKHR                  = VkSemaphoreImportFlagBits;

pub type VkExternalFenceHandleTypeFlagBitsKHR          = VkExternalFenceHandleTypeFlagBits;

pub type VkExternalFenceFeatureFlagBitsKHR             = VkExternalFenceFeatureFlagBits;

pub type VkFenceImportFlagBitsKHR                      = VkFenceImportFlagBits;

pub type VkPeerMemoryFeatureFlagBitsKHR                = VkPeerMemoryFeatureFlagBits;

pub type VkMemoryAllocateFlagBitsKHR                   = VkMemoryAllocateFlagBits;

pub type VkTessellationDomainOriginKHR                 = VkTessellationDomainOrigin;

pub type VkSamplerYcbcrModelConversionKHR              = VkSamplerYcbcrModelConversion;

pub type VkSamplerYcbcrRangeKHR                        = VkSamplerYcbcrRange;

pub type VkChromaLocationKHR                           = VkChromaLocation;

pub type VkSamplerReductionModeEXT                     = VkSamplerReductionMode;

pub type VkShaderFloatControlsIndependenceKHR          = VkShaderFloatControlsIndependence;
// Enumerated types in the header, but not used by the API

pub type VkDriverIdKHR                                 = VkDriverId;
// Video Core extensions
// Video Decode extensions
// Video H.264 Decode extensions
// Video H.265 Decode extensions
// Video Encode extensions
// Video H.264 Encode extensions
// The PFN_vk*Function types are used by VkAllocationCallbacks below
// The PFN_vkVoidFunction type are used by VkGet*ProcAddr below
// The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension
// The PFN_vkDebugUtilsMessengerCallbackEXT type are used by the VK_EXT_debug_utils extension
// The PFN_vkDeviceMemoryReportCallbackEXT type is used by the VK_EXT_device_memory_report extension
// Struct types

#[repr(C)]
#[derive()]
pub struct VkBaseOutStructure<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<&'a mut VkBaseOutStructure<'a>>,
}

unsafe impl Send for VkBaseOutStructure<'_> {}
unsafe impl Sync for VkBaseOutStructure<'_> {}

impl fmt::Debug for VkBaseOutStructure<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBaseOutStructure").finish()
	}
}

impl Default for VkBaseOutStructure<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBaseInStructure<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<&'a VkBaseInStructure<'a>>,
}

unsafe impl Send for VkBaseInStructure<'_> {}
unsafe impl Sync for VkBaseInStructure<'_> {}

impl fmt::Debug for VkBaseInStructure<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBaseInStructure").finish()
	}
}

impl Default for VkBaseInStructure<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkOffset2D {
	pub x                                            : i32,
	pub y                                            : i32,
}

unsafe impl Send for VkOffset2D {}
unsafe impl Sync for VkOffset2D {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkOffset3D {
	pub x                                            : i32,
	pub y                                            : i32,
	pub z                                            : i32,
}

unsafe impl Send for VkOffset3D {}
unsafe impl Sync for VkOffset3D {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkExtent2D {
	pub width                                        : u32,
	pub height                                       : u32,
}

unsafe impl Send for VkExtent2D {}
unsafe impl Sync for VkExtent2D {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkExtent3D {
	pub width                                        : u32,
	pub height                                       : u32,
	pub depth                                        : u32,
}

unsafe impl Send for VkExtent3D {}
unsafe impl Sync for VkExtent3D {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkViewport {
	pub x                                            : f32,
	pub y                                            : f32,
	pub width                                        : f32,
	pub height                                       : f32,
	pub minDepth                                     : f32,
	pub maxDepth                                     : f32,
}

unsafe impl Send for VkViewport {}
unsafe impl Sync for VkViewport {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRect2D {
	pub offset                                       : VkOffset2D,
	pub extent                                       : VkExtent2D,
}

unsafe impl Send for VkRect2D {}
unsafe impl Sync for VkRect2D {}

impl fmt::Debug for VkRect2D {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRect2D").finish()
	}
}

impl Default for VkRect2D {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearRect {
	pub rect                                         : VkRect2D,
	pub baseArrayLayer                               : u32,
	pub layerCount                                   : u32,
}

unsafe impl Send for VkClearRect {}
unsafe impl Sync for VkClearRect {}

impl fmt::Debug for VkClearRect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkClearRect").finish()
	}
}

impl Default for VkClearRect {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkComponentMapping {
	pub r                                            : VkComponentSwizzle,
	pub g                                            : VkComponentSwizzle,
	pub b                                            : VkComponentSwizzle,
	pub a                                            : VkComponentSwizzle,
}

unsafe impl Send for VkComponentMapping {}
unsafe impl Sync for VkComponentMapping {}

impl Default for VkComponentMapping {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties {
	pub apiVersion                                   : u32,
	pub driverVersion                                : u32,
	pub vendorID                                     : u32,
	pub deviceID                                     : u32,
	pub deviceType                                   : VkPhysicalDeviceType,
	pub deviceName                                   : [u8;  VK_MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
	pub pipelineCacheUUID                            : [u8;  VK_UUID_SIZE as usize],
	pub limits                                       : VkPhysicalDeviceLimits,
	pub sparseProperties                             : VkPhysicalDeviceSparseProperties,
}

unsafe impl Send for VkPhysicalDeviceProperties {}
unsafe impl Sync for VkPhysicalDeviceProperties {}

impl fmt::Debug for VkPhysicalDeviceProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProperties").finish()
	}
}

impl Default for VkPhysicalDeviceProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtensionProperties {
	/// extension name
	pub extensionName                                : [u8;  VK_MAX_EXTENSION_NAME_SIZE as usize],
	/// version of the extension specification implemented
	pub specVersion                                  : u32,
}

unsafe impl Send for VkExtensionProperties {}
unsafe impl Sync for VkExtensionProperties {}

impl fmt::Debug for VkExtensionProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExtensionProperties").finish()
	}
}

impl Default for VkExtensionProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkLayerProperties {
	/// layer name
	pub layerName                                    : [u8;  VK_MAX_EXTENSION_NAME_SIZE as usize],
	/// version of the layer specification implemented
	pub specVersion                                  : u32,
	/// build or release version of the layer's library
	pub implementationVersion                        : u32,
	/// Free-form description of the layer
	pub description                                  : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
}

unsafe impl Send for VkLayerProperties {}
unsafe impl Sync for VkLayerProperties {}

impl fmt::Debug for VkLayerProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkLayerProperties").finish()
	}
}

impl Default for VkLayerProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkApplicationInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pApplicationName                             : *const u8,
	pub applicationVersion                           : u32,
	pub pEngineName                                  : *const u8,
	pub engineVersion                                : u32,
	pub apiVersion                                   : u32,
}

unsafe impl Send for VkApplicationInfo<'_> {}
unsafe impl Sync for VkApplicationInfo<'_> {}

impl Default for VkApplicationInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkAllocationCallbacks<'a> {
	pub pUserData                                    : Option<VkAnyMut<'a>>,
	pub pfnAllocation                                : PFN_vkAllocationFunction,
	pub pfnReallocation                              : PFN_vkReallocationFunction,
	pub pfnFree                                      : PFN_vkFreeFunction,
	pub pfnInternalAllocation                        : PFN_vkInternalAllocationNotification,
	pub pfnInternalFree                              : PFN_vkInternalFreeNotification,
}

unsafe impl Send for VkAllocationCallbacks<'_> {}
unsafe impl Sync for VkAllocationCallbacks<'_> {}

impl fmt::Debug for VkAllocationCallbacks<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAllocationCallbacks").finish()
	}
}

impl Default for VkAllocationCallbacks<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceQueueCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDeviceQueueCreateFlags,
	pub queueFamilyIndex                             : u32,
	pub queueCount                                   : u32,
	pub pQueuePriorities                             : *const f32,
}

unsafe impl Send for VkDeviceQueueCreateInfo<'_> {}
unsafe impl Sync for VkDeviceQueueCreateInfo<'_> {}

impl Default for VkDeviceQueueCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDeviceCreateFlags,
	pub queueCreateInfoCount                         : u32,
	pub pQueueCreateInfos                            : *const VkDeviceQueueCreateInfo<'a>,
	pub enabledLayerCount                            : u32,
	/// Ordered list of layer names to be enabled
	pub ppEnabledLayerNames                          : *const *const u8,
	pub enabledExtensionCount                        : u32,
	pub ppEnabledExtensionNames                      : *const *const u8,
	pub pEnabledFeatures                             : Option<&'a VkPhysicalDeviceFeatures>,
}

unsafe impl Send for VkDeviceCreateInfo<'_> {}
unsafe impl Sync for VkDeviceCreateInfo<'_> {}

impl fmt::Debug for VkDeviceCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceCreateInfo").finish()
	}
}

impl Default for VkDeviceCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInstanceCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkInstanceCreateFlags,
	pub pApplicationInfo                             : Option<&'a VkApplicationInfo<'a>>,
	pub enabledLayerCount                            : u32,
	/// Ordered list of layer names to be enabled
	pub ppEnabledLayerNames                          : *const *const u8,
	pub enabledExtensionCount                        : u32,
	/// Extension names to be enabled
	pub ppEnabledExtensionNames                      : *const *const u8,
}

unsafe impl Send for VkInstanceCreateInfo<'_> {}
unsafe impl Sync for VkInstanceCreateInfo<'_> {}

impl fmt::Debug for VkInstanceCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkInstanceCreateInfo").finish()
	}
}

impl Default for VkInstanceCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkQueueFamilyProperties {
	/// Queue flags
	pub queueFlags                                   : VkQueueFlags,
	pub queueCount                                   : u32,
	pub timestampValidBits                           : u32,
	/// Minimum alignment requirement for image transfers
	pub minImageTransferGranularity                  : VkExtent3D,
}

unsafe impl Send for VkQueueFamilyProperties {}
unsafe impl Sync for VkQueueFamilyProperties {}

impl fmt::Debug for VkQueueFamilyProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyProperties").finish()
	}
}

impl Default for VkQueueFamilyProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties {
	pub memoryTypeCount                              : u32,
	pub memoryTypes                                  : [VkMemoryType;  VK_MAX_MEMORY_TYPES as usize],
	pub memoryHeapCount                              : u32,
	pub memoryHeaps                                  : [VkMemoryHeap;  VK_MAX_MEMORY_HEAPS as usize],
}

unsafe impl Send for VkPhysicalDeviceMemoryProperties {}
unsafe impl Sync for VkPhysicalDeviceMemoryProperties {}

impl fmt::Debug for VkPhysicalDeviceMemoryProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryProperties").finish()
	}
}

impl Default for VkPhysicalDeviceMemoryProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Size of memory allocation
	pub allocationSize                               : VkDeviceSize,
	/// Index of the of the memory type to allocate from
	pub memoryTypeIndex                              : u32,
}

unsafe impl Send for VkMemoryAllocateInfo<'_> {}
unsafe impl Sync for VkMemoryAllocateInfo<'_> {}

impl Default for VkMemoryAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkMemoryRequirements {
	/// Specified in bytes
	pub size                                         : VkDeviceSize,
	/// Specified in bytes
	pub alignment                                    : VkDeviceSize,
	/// Bitmask of the allowed memory type indices into memoryTypes[] for this object
	pub memoryTypeBits                               : u32,
}

unsafe impl Send for VkMemoryRequirements {}
unsafe impl Sync for VkMemoryRequirements {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageFormatProperties {
	pub aspectMask                                   : VkImageAspectFlags,
	pub imageGranularity                             : VkExtent3D,
	pub flags                                        : VkSparseImageFormatFlags,
}

unsafe impl Send for VkSparseImageFormatProperties {}
unsafe impl Sync for VkSparseImageFormatProperties {}

impl fmt::Debug for VkSparseImageFormatProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageFormatProperties").finish()
	}
}

impl Default for VkSparseImageFormatProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryRequirements {
	pub formatProperties                             : VkSparseImageFormatProperties,
	pub imageMipTailFirstLod                         : u32,
	/// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
	pub imageMipTailSize                             : VkDeviceSize,
	/// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
	pub imageMipTailOffset                           : VkDeviceSize,
	/// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
	pub imageMipTailStride                           : VkDeviceSize,
}

unsafe impl Send for VkSparseImageMemoryRequirements {}
unsafe impl Sync for VkSparseImageMemoryRequirements {}

impl fmt::Debug for VkSparseImageMemoryRequirements {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryRequirements").finish()
	}
}

impl Default for VkSparseImageMemoryRequirements {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkMemoryType {
	/// Memory properties of this memory type
	pub propertyFlags                                : VkMemoryPropertyFlags,
	/// Index of the memory heap allocations of this memory type are taken from
	pub heapIndex                                    : u32,
}

unsafe impl Send for VkMemoryType {}
unsafe impl Sync for VkMemoryType {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkMemoryHeap {
	/// Available memory in the heap
	pub size                                         : VkDeviceSize,
	/// Flags for the heap
	pub flags                                        : VkMemoryHeapFlags,
}

unsafe impl Send for VkMemoryHeap {}
unsafe impl Sync for VkMemoryHeap {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMappedMemoryRange<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Mapped memory object
	pub memory                                       : VkDeviceMemory,
	/// Offset within the memory object where the range starts
	pub offset                                       : VkDeviceSize,
	/// Size of the range within the memory object
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkMappedMemoryRange<'_> {}
unsafe impl Sync for VkMappedMemoryRange<'_> {}

impl Default for VkMappedMemoryRange<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkFormatProperties {
	/// Format features in case of linear tiling
	pub linearTilingFeatures                         : VkFormatFeatureFlags,
	/// Format features in case of optimal tiling
	pub optimalTilingFeatures                        : VkFormatFeatureFlags,
	/// Format features supported by buffers
	pub bufferFeatures                               : VkFormatFeatureFlags,
}

unsafe impl Send for VkFormatProperties {}
unsafe impl Sync for VkFormatProperties {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageFormatProperties {
	/// max image dimensions for this resource type
	pub maxExtent                                    : VkExtent3D,
	/// max number of mipmap levels for this resource type
	pub maxMipLevels                                 : u32,
	/// max array size for this resource type
	pub maxArrayLayers                               : u32,
	/// supported sample counts for this resource type
	pub sampleCounts                                 : VkSampleCountFlags,
	/// max size (in bytes) of this resource type
	pub maxResourceSize                              : VkDeviceSize,
}

unsafe impl Send for VkImageFormatProperties {}
unsafe impl Sync for VkImageFormatProperties {}

impl fmt::Debug for VkImageFormatProperties {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageFormatProperties").finish()
	}
}

impl Default for VkImageFormatProperties {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDescriptorBufferInfo {
	/// Buffer used for this descriptor slot.
	pub buffer                                       : VkBuffer,
	/// Base offset from buffer start in bytes to update in the descriptor set.
	pub offset                                       : VkDeviceSize,
	/// Size in bytes of the buffer resource for this descriptor update.
	pub range                                        : VkDeviceSize,
}

unsafe impl Send for VkDescriptorBufferInfo {}
unsafe impl Sync for VkDescriptorBufferInfo {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorImageInfo {
	/// Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
	pub sampler                                      : VkSampler,
	/// Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
	pub imageView                                    : VkImageView,
	/// Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
	pub imageLayout                                  : VkImageLayout,
}

unsafe impl Send for VkDescriptorImageInfo {}
unsafe impl Sync for VkDescriptorImageInfo {}

impl Default for VkDescriptorImageInfo {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkWriteDescriptorSet<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Destination descriptor set
	pub dstSet                                       : VkDescriptorSet,
	/// Binding within the destination descriptor set to write
	pub dstBinding                                   : u32,
	/// Array element within the destination binding to write
	pub dstArrayElement                              : u32,
	/// Number of descriptors to write (determines the size of the array pointed by pDescriptors)
	pub descriptorCount                              : u32,
	/// Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
	pub descriptorType                               : VkDescriptorType,
	/// Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
	pub pImageInfo                                   : *const VkDescriptorImageInfo,
	/// Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
	pub pBufferInfo                                  : *const VkDescriptorBufferInfo,
	/// Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
	pub pTexelBufferView                             : *const VkBufferView,
}

unsafe impl Send for VkWriteDescriptorSet<'_> {}
unsafe impl Sync for VkWriteDescriptorSet<'_> {}

impl fmt::Debug for VkWriteDescriptorSet<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSet").finish()
	}
}

impl Default for VkWriteDescriptorSet<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCopyDescriptorSet<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Source descriptor set
	pub srcSet                                       : VkDescriptorSet,
	/// Binding within the source descriptor set to copy from
	pub srcBinding                                   : u32,
	/// Array element within the source binding to copy from
	pub srcArrayElement                              : u32,
	/// Destination descriptor set
	pub dstSet                                       : VkDescriptorSet,
	/// Binding within the destination descriptor set to copy to
	pub dstBinding                                   : u32,
	/// Array element within the destination binding to copy to
	pub dstArrayElement                              : u32,
	/// Number of descriptors to write (determines the size of the array pointed by pDescriptors)
	pub descriptorCount                              : u32,
}

unsafe impl Send for VkCopyDescriptorSet<'_> {}
unsafe impl Sync for VkCopyDescriptorSet<'_> {}

impl Default for VkCopyDescriptorSet<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Buffer creation flags
	pub flags                                        : VkBufferCreateFlags,
	/// Specified in bytes
	pub size                                         : VkDeviceSize,
	/// Buffer usage flags
	pub usage                                        : VkBufferUsageFlags,
	pub sharingMode                                  : VkSharingMode,
	pub queueFamilyIndexCount                        : u32,
	pub pQueueFamilyIndices                          : *const u32,
}

unsafe impl Send for VkBufferCreateInfo<'_> {}
unsafe impl Sync for VkBufferCreateInfo<'_> {}

impl Default for VkBufferCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferViewCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkBufferViewCreateFlags,
	pub buffer                                       : VkBuffer,
	/// Optionally specifies format of elements
	pub format                                       : VkFormat,
	/// Specified in bytes
	pub offset                                       : VkDeviceSize,
	/// View size specified in bytes
	pub range                                        : VkDeviceSize,
}

unsafe impl Send for VkBufferViewCreateInfo<'_> {}
unsafe impl Sync for VkBufferViewCreateInfo<'_> {}

impl Default for VkBufferViewCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkImageSubresource {
	pub aspectMask                                   : VkImageAspectFlags,
	pub mipLevel                                     : u32,
	pub arrayLayer                                   : u32,
}

unsafe impl Send for VkImageSubresource {}
unsafe impl Sync for VkImageSubresource {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkImageSubresourceLayers {
	pub aspectMask                                   : VkImageAspectFlags,
	pub mipLevel                                     : u32,
	pub baseArrayLayer                               : u32,
	pub layerCount                                   : u32,
}

unsafe impl Send for VkImageSubresourceLayers {}
unsafe impl Sync for VkImageSubresourceLayers {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkImageSubresourceRange {
	pub aspectMask                                   : VkImageAspectFlags,
	pub baseMipLevel                                 : u32,
	pub levelCount                                   : u32,
	pub baseArrayLayer                               : u32,
	pub layerCount                                   : u32,
}

unsafe impl Send for VkImageSubresourceRange {}
unsafe impl Sync for VkImageSubresourceRange {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryBarrier<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Memory accesses from the source of the dependency to synchronize
	pub srcAccessMask                                : VkAccessFlags,
	/// Memory accesses from the destination of the dependency to synchronize
	pub dstAccessMask                                : VkAccessFlags,
}

unsafe impl Send for VkMemoryBarrier<'_> {}
unsafe impl Sync for VkMemoryBarrier<'_> {}

impl Default for VkMemoryBarrier<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferMemoryBarrier<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Memory accesses from the source of the dependency to synchronize
	pub srcAccessMask                                : VkAccessFlags,
	/// Memory accesses from the destination of the dependency to synchronize
	pub dstAccessMask                                : VkAccessFlags,
	/// Queue family to transition ownership from
	pub srcQueueFamilyIndex                          : u32,
	/// Queue family to transition ownership to
	pub dstQueueFamilyIndex                          : u32,
	/// Buffer to sync
	pub buffer                                       : VkBuffer,
	/// Offset within the buffer to sync
	pub offset                                       : VkDeviceSize,
	/// Amount of bytes to sync
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkBufferMemoryBarrier<'_> {}
unsafe impl Sync for VkBufferMemoryBarrier<'_> {}

impl Default for VkBufferMemoryBarrier<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryBarrier<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Memory accesses from the source of the dependency to synchronize
	pub srcAccessMask                                : VkAccessFlags,
	/// Memory accesses from the destination of the dependency to synchronize
	pub dstAccessMask                                : VkAccessFlags,
	/// Current layout of the image
	pub oldLayout                                    : VkImageLayout,
	/// New layout to transition the image to
	pub newLayout                                    : VkImageLayout,
	/// Queue family to transition ownership from
	pub srcQueueFamilyIndex                          : u32,
	/// Queue family to transition ownership to
	pub dstQueueFamilyIndex                          : u32,
	/// Image to sync
	pub image                                        : VkImage,
	/// Subresource range to sync
	pub subresourceRange                             : VkImageSubresourceRange,
}

unsafe impl Send for VkImageMemoryBarrier<'_> {}
unsafe impl Sync for VkImageMemoryBarrier<'_> {}

impl fmt::Debug for VkImageMemoryBarrier<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageMemoryBarrier").finish()
	}
}

impl Default for VkImageMemoryBarrier<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Image creation flags
	pub flags                                        : VkImageCreateFlags,
	pub imageType                                    : VkImageType,
	pub format                                       : VkFormat,
	pub extent                                       : VkExtent3D,
	pub mipLevels                                    : u32,
	pub arrayLayers                                  : u32,
	pub samples                                      : VkSampleCountFlagBits,
	pub tiling                                       : VkImageTiling,
	/// Image usage flags
	pub usage                                        : VkImageUsageFlags,
	/// Cross-queue-family sharing mode
	pub sharingMode                                  : VkSharingMode,
	/// Number of queue families to share across
	pub queueFamilyIndexCount                        : u32,
	/// Array of queue family indices to share across
	pub pQueueFamilyIndices                          : *const u32,
	/// Initial image layout for all subresources
	pub initialLayout                                : VkImageLayout,
}

unsafe impl Send for VkImageCreateInfo<'_> {}
unsafe impl Sync for VkImageCreateInfo<'_> {}

impl fmt::Debug for VkImageCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageCreateInfo").finish()
	}
}

impl Default for VkImageCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSubresourceLayout {
	/// Specified in bytes
	pub offset                                       : VkDeviceSize,
	/// Specified in bytes
	pub size                                         : VkDeviceSize,
	/// Specified in bytes
	pub rowPitch                                     : VkDeviceSize,
	/// Specified in bytes
	pub arrayPitch                                   : VkDeviceSize,
	/// Specified in bytes
	pub depthPitch                                   : VkDeviceSize,
}

unsafe impl Send for VkSubresourceLayout {}
unsafe impl Sync for VkSubresourceLayout {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageViewCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkImageViewCreateFlags,
	pub image                                        : VkImage,
	pub viewType                                     : VkImageViewType,
	pub format                                       : VkFormat,
	pub components                                   : VkComponentMapping,
	pub subresourceRange                             : VkImageSubresourceRange,
}

unsafe impl Send for VkImageViewCreateInfo<'_> {}
unsafe impl Sync for VkImageViewCreateInfo<'_> {}

impl fmt::Debug for VkImageViewCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewCreateInfo").finish()
	}
}

impl Default for VkImageViewCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkBufferCopy {
	/// Specified in bytes
	pub srcOffset                                    : VkDeviceSize,
	/// Specified in bytes
	pub dstOffset                                    : VkDeviceSize,
	/// Specified in bytes
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkBufferCopy {}
unsafe impl Sync for VkBufferCopy {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSparseMemoryBind {
	/// Specified in bytes
	pub resourceOffset                               : VkDeviceSize,
	/// Specified in bytes
	pub size                                         : VkDeviceSize,
	pub memory                                       : VkDeviceMemory,
	/// Specified in bytes
	pub memoryOffset                                 : VkDeviceSize,
	pub flags                                        : VkSparseMemoryBindFlags,
}

unsafe impl Send for VkSparseMemoryBind {}
unsafe impl Sync for VkSparseMemoryBind {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryBind {
	pub subresource                                  : VkImageSubresource,
	pub offset                                       : VkOffset3D,
	pub extent                                       : VkExtent3D,
	pub memory                                       : VkDeviceMemory,
	/// Specified in bytes
	pub memoryOffset                                 : VkDeviceSize,
	pub flags                                        : VkSparseMemoryBindFlags,
}

unsafe impl Send for VkSparseImageMemoryBind {}
unsafe impl Sync for VkSparseImageMemoryBind {}

impl fmt::Debug for VkSparseImageMemoryBind {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryBind").finish()
	}
}

impl Default for VkSparseImageMemoryBind {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseBufferMemoryBindInfo {
	pub buffer                                       : VkBuffer,
	pub bindCount                                    : u32,
	pub pBinds                                       : *const VkSparseMemoryBind,
}

unsafe impl Send for VkSparseBufferMemoryBindInfo {}
unsafe impl Sync for VkSparseBufferMemoryBindInfo {}

impl fmt::Debug for VkSparseBufferMemoryBindInfo {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseBufferMemoryBindInfo").finish()
	}
}

impl Default for VkSparseBufferMemoryBindInfo {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
	pub image                                        : VkImage,
	pub bindCount                                    : u32,
	pub pBinds                                       : *const VkSparseMemoryBind,
}

unsafe impl Send for VkSparseImageOpaqueMemoryBindInfo {}
unsafe impl Sync for VkSparseImageOpaqueMemoryBindInfo {}

impl fmt::Debug for VkSparseImageOpaqueMemoryBindInfo {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageOpaqueMemoryBindInfo").finish()
	}
}

impl Default for VkSparseImageOpaqueMemoryBindInfo {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSparseImageMemoryBindInfo {
	pub image                                        : VkImage,
	pub bindCount                                    : u32,
	pub pBinds                                       : *const VkSparseImageMemoryBind,
}

unsafe impl Send for VkSparseImageMemoryBindInfo {}
unsafe impl Sync for VkSparseImageMemoryBindInfo {}

impl fmt::Debug for VkSparseImageMemoryBindInfo {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryBindInfo").finish()
	}
}

impl Default for VkSparseImageMemoryBindInfo {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindSparseInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub waitSemaphoreCount                           : u32,
	pub pWaitSemaphores                              : *const VkSemaphore,
	pub bufferBindCount                              : u32,
	pub pBufferBinds                                 : *const VkSparseBufferMemoryBindInfo,
	pub imageOpaqueBindCount                         : u32,
	pub pImageOpaqueBinds                            : *const VkSparseImageOpaqueMemoryBindInfo,
	pub imageBindCount                               : u32,
	pub pImageBinds                                  : *const VkSparseImageMemoryBindInfo,
	pub signalSemaphoreCount                         : u32,
	pub pSignalSemaphores                            : *const VkSemaphore,
}

unsafe impl Send for VkBindSparseInfo<'_> {}
unsafe impl Sync for VkBindSparseInfo<'_> {}

impl fmt::Debug for VkBindSparseInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBindSparseInfo").finish()
	}
}

impl Default for VkBindSparseInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCopy {
	pub srcSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub srcOffset                                    : VkOffset3D,
	pub dstSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub dstOffset                                    : VkOffset3D,
	/// Specified in pixels for both compressed and uncompressed images
	pub extent                                       : VkExtent3D,
}

unsafe impl Send for VkImageCopy {}
unsafe impl Sync for VkImageCopy {}

impl fmt::Debug for VkImageCopy {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageCopy").finish()
	}
}

impl Default for VkImageCopy {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageBlit {
	pub srcSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub srcOffsets                                   : [VkOffset3D;  2 as usize],
	pub dstSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub dstOffsets                                   : [VkOffset3D;  2 as usize],
}

unsafe impl Send for VkImageBlit {}
unsafe impl Sync for VkImageBlit {}

impl fmt::Debug for VkImageBlit {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageBlit").finish()
	}
}

impl Default for VkImageBlit {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferImageCopy {
	/// Specified in bytes
	pub bufferOffset                                 : VkDeviceSize,
	/// Specified in texels
	pub bufferRowLength                              : u32,
	pub bufferImageHeight                            : u32,
	pub imageSubresource                             : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub imageOffset                                  : VkOffset3D,
	/// Specified in pixels for both compressed and uncompressed images
	pub imageExtent                                  : VkExtent3D,
}

unsafe impl Send for VkBufferImageCopy {}
unsafe impl Sync for VkBufferImageCopy {}

impl fmt::Debug for VkBufferImageCopy {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBufferImageCopy").finish()
	}
}

impl Default for VkBufferImageCopy {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageResolve {
	pub srcSubresource                               : VkImageSubresourceLayers,
	pub srcOffset                                    : VkOffset3D,
	pub dstSubresource                               : VkImageSubresourceLayers,
	pub dstOffset                                    : VkOffset3D,
	pub extent                                       : VkExtent3D,
}

unsafe impl Send for VkImageResolve {}
unsafe impl Sync for VkImageResolve {}

impl fmt::Debug for VkImageResolve {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageResolve").finish()
	}
}

impl Default for VkImageResolve {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkShaderModuleCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkShaderModuleCreateFlags,
	/// Specified in bytes
	pub codeSize                                     : usize,
	/// Binary code of size codeSize
	pub pCode                                        : *const u32,
}

unsafe impl Send for VkShaderModuleCreateInfo<'_> {}
unsafe impl Sync for VkShaderModuleCreateInfo<'_> {}

impl Default for VkShaderModuleCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetLayoutBinding {
	/// Binding number for this entry
	pub binding                                      : u32,
	/// Type of the descriptors in this binding
	pub descriptorType                               : VkDescriptorType,
	/// Number of descriptors in this binding
	pub descriptorCount                              : u32,
	/// Shader stages this binding is visible to
	pub stageFlags                                   : VkShaderStageFlags,
	/// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
	pub pImmutableSamplers                           : *const VkSampler,
}

unsafe impl Send for VkDescriptorSetLayoutBinding {}
unsafe impl Sync for VkDescriptorSetLayoutBinding {}

impl Default for VkDescriptorSetLayoutBinding {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorSetLayoutCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDescriptorSetLayoutCreateFlags,
	/// Number of bindings in the descriptor set layout
	pub bindingCount                                 : u32,
	/// Array of descriptor set layout bindings
	pub pBindings                                    : *const VkDescriptorSetLayoutBinding,
}

unsafe impl Send for VkDescriptorSetLayoutCreateInfo<'_> {}
unsafe impl Sync for VkDescriptorSetLayoutCreateInfo<'_> {}

impl fmt::Debug for VkDescriptorSetLayoutCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetLayoutCreateInfo").finish()
	}
}

impl Default for VkDescriptorSetLayoutCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorPoolSize {
	pub r#type                                       : VkDescriptorType,
	pub descriptorCount                              : u32,
}

unsafe impl Send for VkDescriptorPoolSize {}
unsafe impl Sync for VkDescriptorPoolSize {}

impl Default for VkDescriptorPoolSize {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorPoolCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDescriptorPoolCreateFlags,
	pub maxSets                                      : u32,
	pub poolSizeCount                                : u32,
	pub pPoolSizes                                   : *const VkDescriptorPoolSize,
}

unsafe impl Send for VkDescriptorPoolCreateInfo<'_> {}
unsafe impl Sync for VkDescriptorPoolCreateInfo<'_> {}

impl fmt::Debug for VkDescriptorPoolCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorPoolCreateInfo").finish()
	}
}

impl Default for VkDescriptorPoolCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub descriptorPool                               : VkDescriptorPool,
	pub descriptorSetCount                           : u32,
	pub pSetLayouts                                  : *const VkDescriptorSetLayout,
}

unsafe impl Send for VkDescriptorSetAllocateInfo<'_> {}
unsafe impl Sync for VkDescriptorSetAllocateInfo<'_> {}

impl Default for VkDescriptorSetAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSpecializationMapEntry {
	/// The SpecConstant ID specified in the BIL
	pub constantID                                   : u32,
	/// Offset of the value in the data block
	pub offset                                       : u32,
	/// Size in bytes of the SpecConstant
	pub size                                         : usize,
}

unsafe impl Send for VkSpecializationMapEntry {}
unsafe impl Sync for VkSpecializationMapEntry {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSpecializationInfo {
	/// Number of entries in the map
	pub mapEntryCount                                : u32,
	/// Array of map entries
	pub pMapEntries                                  : *const VkSpecializationMapEntry,
	/// Size in bytes of pData
	pub dataSize                                     : usize,
	/// Pointer to SpecConstant data
	pub pData                                        : *const (),
}

unsafe impl Send for VkSpecializationInfo {}
unsafe impl Sync for VkSpecializationInfo {}

impl fmt::Debug for VkSpecializationInfo {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSpecializationInfo").finish()
	}
}

impl Default for VkSpecializationInfo {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineShaderStageCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineShaderStageCreateFlags,
	/// Shader stage
	pub stage                                        : VkShaderStageFlagBits,
	/// Module containing entry point
	pub module                                       : VkShaderModule,
	/// Null-terminated entry point name
	pub pName                                        : *const u8,
	pub pSpecializationInfo                          : Option<&'a VkSpecializationInfo>,
}

unsafe impl Send for VkPipelineShaderStageCreateInfo<'_> {}
unsafe impl Sync for VkPipelineShaderStageCreateInfo<'_> {}

impl fmt::Debug for VkPipelineShaderStageCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineShaderStageCreateInfo").finish()
	}
}

impl Default for VkPipelineShaderStageCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkComputePipelineCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Pipeline creation flags
	pub flags                                        : VkPipelineCreateFlags,
	pub stage                                        : VkPipelineShaderStageCreateInfo<'a>,
	/// Interface layout of the pipeline
	pub layout                                       : VkPipelineLayout,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	pub basePipelineHandle                           : VkPipeline,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
	pub basePipelineIndex                            : i32,
}

unsafe impl Send for VkComputePipelineCreateInfo<'_> {}
unsafe impl Sync for VkComputePipelineCreateInfo<'_> {}

impl fmt::Debug for VkComputePipelineCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkComputePipelineCreateInfo").finish()
	}
}

impl Default for VkComputePipelineCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVertexInputBindingDescription {
	/// Vertex buffer binding id
	pub binding                                      : u32,
	/// Distance between vertices in bytes (0 = no advancement)
	pub stride                                       : u32,
	/// The rate at which the vertex data is consumed
	pub inputRate                                    : VkVertexInputRate,
}

unsafe impl Send for VkVertexInputBindingDescription {}
unsafe impl Sync for VkVertexInputBindingDescription {}

impl Default for VkVertexInputBindingDescription {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVertexInputAttributeDescription {
	/// location of the shader vertex attrib
	pub location                                     : u32,
	/// Vertex buffer binding id
	pub binding                                      : u32,
	/// format of source data
	pub format                                       : VkFormat,
	/// Offset of first element in bytes from base of vertex
	pub offset                                       : u32,
}

unsafe impl Send for VkVertexInputAttributeDescription {}
unsafe impl Sync for VkVertexInputAttributeDescription {}

impl Default for VkVertexInputAttributeDescription {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineVertexInputStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineVertexInputStateCreateFlags,
	/// number of bindings
	pub vertexBindingDescriptionCount                : u32,
	pub pVertexBindingDescriptions                   : *const VkVertexInputBindingDescription,
	/// number of attributes
	pub vertexAttributeDescriptionCount              : u32,
	pub pVertexAttributeDescriptions                 : *const VkVertexInputAttributeDescription,
}

unsafe impl Send for VkPipelineVertexInputStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineVertexInputStateCreateInfo<'_> {}

impl fmt::Debug for VkPipelineVertexInputStateCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineVertexInputStateCreateInfo").finish()
	}
}

impl Default for VkPipelineVertexInputStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineInputAssemblyStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineInputAssemblyStateCreateFlags,
	pub topology                                     : VkPrimitiveTopology,
	pub primitiveRestartEnable                       : VkBool32,
}

unsafe impl Send for VkPipelineInputAssemblyStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineInputAssemblyStateCreateInfo<'_> {}

impl Default for VkPipelineInputAssemblyStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineTessellationStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineTessellationStateCreateFlags,
	pub patchControlPoints                           : u32,
}

unsafe impl Send for VkPipelineTessellationStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineTessellationStateCreateInfo<'_> {}

impl Default for VkPipelineTessellationStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineViewportStateCreateFlags,
	pub viewportCount                                : u32,
	pub pViewports                                   : *const VkViewport,
	pub scissorCount                                 : u32,
	pub pScissors                                    : *const VkRect2D,
}

unsafe impl Send for VkPipelineViewportStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineViewportStateCreateInfo<'_> {}

impl fmt::Debug for VkPipelineViewportStateCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportStateCreateInfo").finish()
	}
}

impl Default for VkPipelineViewportStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineRasterizationStateCreateFlags,
	pub depthClampEnable                             : VkBool32,
	pub rasterizerDiscardEnable                      : VkBool32,
	/// optional (GL45)
	pub polygonMode                                  : VkPolygonMode,
	pub cullMode                                     : VkCullModeFlags,
	pub frontFace                                    : VkFrontFace,
	pub depthBiasEnable                              : VkBool32,
	pub depthBiasConstantFactor                      : f32,
	pub depthBiasClamp                               : f32,
	pub depthBiasSlopeFactor                         : f32,
	pub lineWidth                                    : f32,
}

unsafe impl Send for VkPipelineRasterizationStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineRasterizationStateCreateInfo<'_> {}

impl Default for VkPipelineRasterizationStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineMultisampleStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineMultisampleStateCreateFlags,
	/// Number of samples used for rasterization
	pub rasterizationSamples                         : VkSampleCountFlagBits,
	/// optional (GL45)
	pub sampleShadingEnable                          : VkBool32,
	/// optional (GL45)
	pub minSampleShading                             : f32,
	/// Array of sampleMask words
	pub pSampleMask                                  : *const VkSampleMask,
	pub alphaToCoverageEnable                        : VkBool32,
	pub alphaToOneEnable                             : VkBool32,
}

unsafe impl Send for VkPipelineMultisampleStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineMultisampleStateCreateInfo<'_> {}

impl Default for VkPipelineMultisampleStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineColorBlendAttachmentState {
	pub blendEnable                                  : VkBool32,
	pub srcColorBlendFactor                          : VkBlendFactor,
	pub dstColorBlendFactor                          : VkBlendFactor,
	pub colorBlendOp                                 : VkBlendOp,
	pub srcAlphaBlendFactor                          : VkBlendFactor,
	pub dstAlphaBlendFactor                          : VkBlendFactor,
	pub alphaBlendOp                                 : VkBlendOp,
	pub colorWriteMask                               : VkColorComponentFlags,
}

unsafe impl Send for VkPipelineColorBlendAttachmentState {}
unsafe impl Sync for VkPipelineColorBlendAttachmentState {}

impl Default for VkPipelineColorBlendAttachmentState {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineColorBlendStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineColorBlendStateCreateFlags,
	pub logicOpEnable                                : VkBool32,
	pub logicOp                                      : VkLogicOp,
	/// # of pAttachments
	pub attachmentCount                              : u32,
	pub pAttachments                                 : *const VkPipelineColorBlendAttachmentState,
	pub blendConstants                               : [f32;  4 as usize],
}

unsafe impl Send for VkPipelineColorBlendStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineColorBlendStateCreateInfo<'_> {}

impl fmt::Debug for VkPipelineColorBlendStateCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineColorBlendStateCreateInfo").finish()
	}
}

impl Default for VkPipelineColorBlendStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineDynamicStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineDynamicStateCreateFlags,
	pub dynamicStateCount                            : u32,
	pub pDynamicStates                               : *const VkDynamicState,
}

unsafe impl Send for VkPipelineDynamicStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineDynamicStateCreateInfo<'_> {}

impl Default for VkPipelineDynamicStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkStencilOpState {
	pub failOp                                       : VkStencilOp,
	pub passOp                                       : VkStencilOp,
	pub depthFailOp                                  : VkStencilOp,
	pub compareOp                                    : VkCompareOp,
	pub compareMask                                  : u32,
	pub writeMask                                    : u32,
	pub reference                                    : u32,
}

unsafe impl Send for VkStencilOpState {}
unsafe impl Sync for VkStencilOpState {}

impl Default for VkStencilOpState {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineDepthStencilStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineDepthStencilStateCreateFlags,
	pub depthTestEnable                              : VkBool32,
	pub depthWriteEnable                             : VkBool32,
	pub depthCompareOp                               : VkCompareOp,
	/// optional (depth_bounds_test)
	pub depthBoundsTestEnable                        : VkBool32,
	pub stencilTestEnable                            : VkBool32,
	pub front                                        : VkStencilOpState,
	pub back                                         : VkStencilOpState,
	pub minDepthBounds                               : f32,
	pub maxDepthBounds                               : f32,
}

unsafe impl Send for VkPipelineDepthStencilStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineDepthStencilStateCreateInfo<'_> {}

impl fmt::Debug for VkPipelineDepthStencilStateCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineDepthStencilStateCreateInfo").finish()
	}
}

impl Default for VkPipelineDepthStencilStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGraphicsPipelineCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Pipeline creation flags
	pub flags                                        : VkPipelineCreateFlags,
	pub stageCount                                   : u32,
	/// One entry for each active shader stage
	pub pStages                                      : *const VkPipelineShaderStageCreateInfo<'a>,
	pub pVertexInputState                            : Option<&'a VkPipelineVertexInputStateCreateInfo<'a>>,
	pub pInputAssemblyState                          : Option<&'a VkPipelineInputAssemblyStateCreateInfo<'a>>,
	pub pTessellationState                           : Option<&'a VkPipelineTessellationStateCreateInfo<'a>>,
	pub pViewportState                               : Option<&'a VkPipelineViewportStateCreateInfo<'a>>,
	pub pRasterizationState                          : &'a VkPipelineRasterizationStateCreateInfo<'a>,
	pub pMultisampleState                            : Option<&'a VkPipelineMultisampleStateCreateInfo<'a>>,
	pub pDepthStencilState                           : Option<&'a VkPipelineDepthStencilStateCreateInfo<'a>>,
	pub pColorBlendState                             : Option<&'a VkPipelineColorBlendStateCreateInfo<'a>>,
	pub pDynamicState                                : Option<&'a VkPipelineDynamicStateCreateInfo<'a>>,
	/// Interface layout of the pipeline
	pub layout                                       : VkPipelineLayout,
	pub renderPass                                   : VkRenderPass,
	pub subpass                                      : u32,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	pub basePipelineHandle                           : VkPipeline,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
	pub basePipelineIndex                            : i32,
}

unsafe impl Send for VkGraphicsPipelineCreateInfo<'_> {}
unsafe impl Sync for VkGraphicsPipelineCreateInfo<'_> {}

impl fmt::Debug for VkGraphicsPipelineCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsPipelineCreateInfo").finish()
	}
}

impl Default for VkGraphicsPipelineCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineCacheCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineCacheCreateFlags,
	/// Size of initial data to populate cache, in bytes
	pub initialDataSize                              : usize,
	/// Initial data to populate cache
	pub pInitialData                                 : *const (),
}

unsafe impl Send for VkPipelineCacheCreateInfo<'_> {}
unsafe impl Sync for VkPipelineCacheCreateInfo<'_> {}

impl Default for VkPipelineCacheCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineCacheHeaderVersionOne {
	pub headerSize                                   : u32,
	pub headerVersion                                : VkPipelineCacheHeaderVersion,
	pub vendorID                                     : u32,
	pub deviceID                                     : u32,
	pub pipelineCacheUUID                            : [u8;  VK_UUID_SIZE as usize],
}

unsafe impl Send for VkPipelineCacheHeaderVersionOne {}
unsafe impl Sync for VkPipelineCacheHeaderVersionOne {}

impl fmt::Debug for VkPipelineCacheHeaderVersionOne {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCacheHeaderVersionOne").finish()
	}
}

impl Default for VkPipelineCacheHeaderVersionOne {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkPushConstantRange {
	/// Which stages use the range
	pub stageFlags                                   : VkShaderStageFlags,
	/// Start of the range, in bytes
	pub offset                                       : u32,
	/// Size of the range, in bytes
	pub size                                         : u32,
}

unsafe impl Send for VkPushConstantRange {}
unsafe impl Sync for VkPushConstantRange {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineLayoutCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineLayoutCreateFlags,
	/// Number of descriptor sets interfaced by the pipeline
	pub setLayoutCount                               : u32,
	/// Array of setCount number of descriptor set layout objects defining the layout of the
	pub pSetLayouts                                  : *const VkDescriptorSetLayout,
	/// Number of push-constant ranges used by the pipeline
	pub pushConstantRangeCount                       : u32,
	/// Array of pushConstantRangeCount number of ranges used by various shader stages
	pub pPushConstantRanges                          : *const VkPushConstantRange,
}

unsafe impl Send for VkPipelineLayoutCreateInfo<'_> {}
unsafe impl Sync for VkPipelineLayoutCreateInfo<'_> {}

impl fmt::Debug for VkPipelineLayoutCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineLayoutCreateInfo").finish()
	}
}

impl Default for VkPipelineLayoutCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSamplerCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkSamplerCreateFlags,
	/// Filter mode for magnification
	pub magFilter                                    : VkFilter,
	/// Filter mode for minifiation
	pub minFilter                                    : VkFilter,
	/// Mipmap selection mode
	pub mipmapMode                                   : VkSamplerMipmapMode,
	pub addressModeU                                 : VkSamplerAddressMode,
	pub addressModeV                                 : VkSamplerAddressMode,
	pub addressModeW                                 : VkSamplerAddressMode,
	pub mipLodBias                                   : f32,
	pub anisotropyEnable                             : VkBool32,
	pub maxAnisotropy                                : f32,
	pub compareEnable                                : VkBool32,
	pub compareOp                                    : VkCompareOp,
	pub minLod                                       : f32,
	pub maxLod                                       : f32,
	pub borderColor                                  : VkBorderColor,
	pub unnormalizedCoordinates                      : VkBool32,
}

unsafe impl Send for VkSamplerCreateInfo<'_> {}
unsafe impl Sync for VkSamplerCreateInfo<'_> {}

impl Default for VkSamplerCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandPoolCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Command pool creation flags
	pub flags                                        : VkCommandPoolCreateFlags,
	pub queueFamilyIndex                             : u32,
}

unsafe impl Send for VkCommandPoolCreateInfo<'_> {}
unsafe impl Sync for VkCommandPoolCreateInfo<'_> {}

impl Default for VkCommandPoolCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub commandPool                                  : VkCommandPool,
	pub level                                        : VkCommandBufferLevel,
	pub commandBufferCount                           : u32,
}

unsafe impl Send for VkCommandBufferAllocateInfo<'_> {}
unsafe impl Sync for VkCommandBufferAllocateInfo<'_> {}

impl Default for VkCommandBufferAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferInheritanceInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Render pass for secondary command buffers
	pub renderPass                                   : VkRenderPass,
	pub subpass                                      : u32,
	/// Framebuffer for secondary command buffers
	pub framebuffer                                  : VkFramebuffer,
	/// Whether this secondary command buffer may be executed during an occlusion query
	pub occlusionQueryEnable                         : VkBool32,
	/// Query flags used by this secondary command buffer, if executed during an occlusion query
	pub queryFlags                                   : VkQueryControlFlags,
	/// Pipeline statistics that may be counted for this secondary command buffer
	pub pipelineStatistics                           : VkQueryPipelineStatisticFlags,
}

unsafe impl Send for VkCommandBufferInheritanceInfo<'_> {}
unsafe impl Sync for VkCommandBufferInheritanceInfo<'_> {}

impl Default for VkCommandBufferInheritanceInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferBeginInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Command buffer usage flags
	pub flags                                        : VkCommandBufferUsageFlags,
	/// Pointer to inheritance info for secondary command buffers
	pub pInheritanceInfo                             : Option<&'a VkCommandBufferInheritanceInfo<'a>>,
}

unsafe impl Send for VkCommandBufferBeginInfo<'_> {}
unsafe impl Sync for VkCommandBufferBeginInfo<'_> {}

impl fmt::Debug for VkCommandBufferBeginInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferBeginInfo").finish()
	}
}

impl Default for VkCommandBufferBeginInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassBeginInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub renderPass                                   : VkRenderPass,
	pub framebuffer                                  : VkFramebuffer,
	pub renderArea                                   : VkRect2D,
	pub clearValueCount                              : u32,
	pub pClearValues                                 : *const VkClearValue,
}

unsafe impl Send for VkRenderPassBeginInfo<'_> {}
unsafe impl Sync for VkRenderPassBeginInfo<'_> {}

impl fmt::Debug for VkRenderPassBeginInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassBeginInfo").finish()
	}
}

impl Default for VkRenderPassBeginInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

/// // Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkClearColorValue {
	pub float32                                      : [f32;  4 as usize],
	pub int32                                        : [i32;  4 as usize],
	pub uint32                                       : [u32;  4 as usize],
}

unsafe impl Send for VkClearColorValue {}
unsafe impl Sync for VkClearColorValue {}

impl fmt::Debug for VkClearColorValue {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkClearColorValue").finish()
	}
}

impl Default for VkClearColorValue {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkClearDepthStencilValue {
	pub depth                                        : f32,
	pub stencil                                      : u32,
}

unsafe impl Send for VkClearDepthStencilValue {}
unsafe impl Sync for VkClearDepthStencilValue {}


/// // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkClearValue {
	pub color                                        : VkClearColorValue,
	pub depthStencil                                 : VkClearDepthStencilValue,
}

unsafe impl Send for VkClearValue {}
unsafe impl Sync for VkClearValue {}

impl fmt::Debug for VkClearValue {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkClearValue").finish()
	}
}

impl Default for VkClearValue {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearAttachment {
	pub aspectMask                                   : VkImageAspectFlags,
	pub colorAttachment                              : u32,
	pub clearValue                                   : VkClearValue,
}

unsafe impl Send for VkClearAttachment {}
unsafe impl Sync for VkClearAttachment {}

impl fmt::Debug for VkClearAttachment {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkClearAttachment").finish()
	}
}

impl Default for VkClearAttachment {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAttachmentDescription {
	pub flags                                        : VkAttachmentDescriptionFlags,
	pub format                                       : VkFormat,
	pub samples                                      : VkSampleCountFlagBits,
	/// Load operation for color or depth data
	pub loadOp                                       : VkAttachmentLoadOp,
	/// Store operation for color or depth data
	pub storeOp                                      : VkAttachmentStoreOp,
	/// Load operation for stencil data
	pub stencilLoadOp                                : VkAttachmentLoadOp,
	/// Store operation for stencil data
	pub stencilStoreOp                               : VkAttachmentStoreOp,
	pub initialLayout                                : VkImageLayout,
	pub finalLayout                                  : VkImageLayout,
}

unsafe impl Send for VkAttachmentDescription {}
unsafe impl Sync for VkAttachmentDescription {}

impl Default for VkAttachmentDescription {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAttachmentReference {
	pub attachment                                   : u32,
	pub layout                                       : VkImageLayout,
}

unsafe impl Send for VkAttachmentReference {}
unsafe impl Sync for VkAttachmentReference {}

impl Default for VkAttachmentReference {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription<'a> {
	pub flags                                        : VkSubpassDescriptionFlags,
	/// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
	pub pipelineBindPoint                            : VkPipelineBindPoint,
	pub inputAttachmentCount                         : u32,
	pub pInputAttachments                            : *const VkAttachmentReference,
	pub colorAttachmentCount                         : u32,
	pub pColorAttachments                            : *const VkAttachmentReference,
	pub pResolveAttachments                          : *const VkAttachmentReference,
	pub pDepthStencilAttachment                      : Option<&'a VkAttachmentReference>,
	pub preserveAttachmentCount                      : u32,
	pub pPreserveAttachments                         : *const u32,
}

unsafe impl Send for VkSubpassDescription<'_> {}
unsafe impl Sync for VkSubpassDescription<'_> {}

impl fmt::Debug for VkSubpassDescription<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDescription").finish()
	}
}

impl Default for VkSubpassDescription<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSubpassDependency {
	pub srcSubpass                                   : u32,
	pub dstSubpass                                   : u32,
	pub srcStageMask                                 : VkPipelineStageFlags,
	pub dstStageMask                                 : VkPipelineStageFlags,
	/// Memory accesses from the source of the dependency to synchronize
	pub srcAccessMask                                : VkAccessFlags,
	/// Memory accesses from the destination of the dependency to synchronize
	pub dstAccessMask                                : VkAccessFlags,
	pub dependencyFlags                              : VkDependencyFlags,
}

unsafe impl Send for VkSubpassDependency {}
unsafe impl Sync for VkSubpassDependency {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkRenderPassCreateFlags,
	pub attachmentCount                              : u32,
	pub pAttachments                                 : *const VkAttachmentDescription,
	pub subpassCount                                 : u32,
	pub pSubpasses                                   : *const VkSubpassDescription<'a>,
	pub dependencyCount                              : u32,
	pub pDependencies                                : *const VkSubpassDependency,
}

unsafe impl Send for VkRenderPassCreateInfo<'_> {}
unsafe impl Sync for VkRenderPassCreateInfo<'_> {}

impl fmt::Debug for VkRenderPassCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreateInfo").finish()
	}
}

impl Default for VkRenderPassCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkEventCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Event creation flags
	pub flags                                        : VkEventCreateFlags,
}

unsafe impl Send for VkEventCreateInfo<'_> {}
unsafe impl Sync for VkEventCreateInfo<'_> {}

impl Default for VkEventCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFenceCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Fence creation flags
	pub flags                                        : VkFenceCreateFlags,
}

unsafe impl Send for VkFenceCreateInfo<'_> {}
unsafe impl Sync for VkFenceCreateInfo<'_> {}

impl Default for VkFenceCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkPhysicalDeviceFeatures {
	/// out of bounds buffer accesses are well defined
	pub robustBufferAccess                           : VkBool32,
	/// full 32-bit range of indices for indexed draw calls
	pub fullDrawIndexUint32                          : VkBool32,
	/// image views which are arrays of cube maps
	pub imageCubeArray                               : VkBool32,
	/// blending operations are controlled per-attachment
	pub independentBlend                             : VkBool32,
	/// geometry stage
	pub geometryShader                               : VkBool32,
	/// tessellation control and evaluation stage
	pub tessellationShader                           : VkBool32,
	/// per-sample shading and interpolation
	pub sampleRateShading                            : VkBool32,
	/// blend operations which take two sources
	pub dualSrcBlend                                 : VkBool32,
	/// logic operations
	pub logicOp                                      : VkBool32,
	/// multi draw indirect
	pub multiDrawIndirect                            : VkBool32,
	/// indirect draws can use non-zero firstInstance
	pub drawIndirectFirstInstance                    : VkBool32,
	/// depth clamping
	pub depthClamp                                   : VkBool32,
	/// depth bias clamping
	pub depthBiasClamp                               : VkBool32,
	/// point and wireframe fill modes
	pub fillModeNonSolid                             : VkBool32,
	/// depth bounds test
	pub depthBounds                                  : VkBool32,
	/// lines with width greater than 1
	pub wideLines                                    : VkBool32,
	/// points with size greater than 1
	pub largePoints                                  : VkBool32,
	/// the fragment alpha component can be forced to maximum representable alpha value
	pub alphaToOne                                   : VkBool32,
	/// viewport arrays
	pub multiViewport                                : VkBool32,
	/// anisotropic sampler filtering
	pub samplerAnisotropy                            : VkBool32,
	/// ETC texture compression formats
	pub textureCompressionETC2                       : VkBool32,
	/// ASTC LDR texture compression formats
	pub textureCompressionASTC_LDR                   : VkBool32,
	/// BC1-7 texture compressed formats
	pub textureCompressionBC                         : VkBool32,
	/// precise occlusion queries returning actual sample counts
	pub occlusionQueryPrecise                        : VkBool32,
	/// pipeline statistics query
	pub pipelineStatisticsQuery                      : VkBool32,
	/// stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
	pub vertexPipelineStoresAndAtomics               : VkBool32,
	/// stores and atomic ops on storage buffers and images are supported in the fragment stage
	pub fragmentStoresAndAtomics                     : VkBool32,
	/// tessellation and geometry stages can export point size
	pub shaderTessellationAndGeometryPointSize       : VkBool32,
	/// image gather with run-time values and independent offsets
	pub shaderImageGatherExtended                    : VkBool32,
	/// the extended set of formats can be used for storage images
	pub shaderStorageImageExtendedFormats            : VkBool32,
	/// multisample images can be used for storage images
	pub shaderStorageImageMultisample                : VkBool32,
	/// read from storage image does not require format qualifier
	pub shaderStorageImageReadWithoutFormat          : VkBool32,
	/// write to storage image does not require format qualifier
	pub shaderStorageImageWriteWithoutFormat         : VkBool32,
	/// arrays of uniform buffers can be accessed with dynamically uniform indices
	pub shaderUniformBufferArrayDynamicIndexing      : VkBool32,
	/// arrays of sampled images can be accessed with dynamically uniform indices
	pub shaderSampledImageArrayDynamicIndexing       : VkBool32,
	/// arrays of storage buffers can be accessed with dynamically uniform indices
	pub shaderStorageBufferArrayDynamicIndexing      : VkBool32,
	/// arrays of storage images can be accessed with dynamically uniform indices
	pub shaderStorageImageArrayDynamicIndexing       : VkBool32,
	/// clip distance in shaders
	pub shaderClipDistance                           : VkBool32,
	/// cull distance in shaders
	pub shaderCullDistance                           : VkBool32,
	/// 64-bit floats (doubles) in shaders
	pub shaderFloat64                                : VkBool32,
	/// 64-bit integers in shaders
	pub shaderInt64                                  : VkBool32,
	/// 16-bit integers in shaders
	pub shaderInt16                                  : VkBool32,
	/// shader can use texture operations that return resource residency information (requires sparseNonResident support)
	pub shaderResourceResidency                      : VkBool32,
	/// shader can use texture operations that specify minimum resource LOD
	pub shaderResourceMinLod                         : VkBool32,
	/// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
	pub sparseBinding                                : VkBool32,
	/// Sparse resources support: GPU can access partially resident buffers
	pub sparseResidencyBuffer                        : VkBool32,
	/// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images
	pub sparseResidencyImage2D                       : VkBool32,
	/// Sparse resources support: GPU can access partially resident 3D images
	pub sparseResidencyImage3D                       : VkBool32,
	/// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
	pub sparseResidency2Samples                      : VkBool32,
	/// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
	pub sparseResidency4Samples                      : VkBool32,
	/// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
	pub sparseResidency8Samples                      : VkBool32,
	/// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
	pub sparseResidency16Samples                     : VkBool32,
	/// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
	pub sparseResidencyAliased                       : VkBool32,
	/// multisample rate must be the same for all pipelines in a subpass
	pub variableMultisampleRate                      : VkBool32,
	/// Queries may be inherited from primary to secondary command buffers
	pub inheritedQueries                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFeatures {}
unsafe impl Sync for VkPhysicalDeviceFeatures {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkPhysicalDeviceSparseProperties {
	/// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
	pub residencyStandard2DBlockShape                : VkBool32,
	/// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
	pub residencyStandard2DMultisampleBlockShape     : VkBool32,
	/// Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
	pub residencyStandard3DBlockShape                : VkBool32,
	/// Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
	pub residencyAlignedMipSize                      : VkBool32,
	/// Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
	pub residencyNonResidentStrict                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSparseProperties {}
unsafe impl Sync for VkPhysicalDeviceSparseProperties {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceLimits {
	/// max 1D image dimension
	pub maxImageDimension1D                          : u32,
	/// max 2D image dimension
	pub maxImageDimension2D                          : u32,
	/// max 3D image dimension
	pub maxImageDimension3D                          : u32,
	/// max cubemap image dimension
	pub maxImageDimensionCube                        : u32,
	/// max layers for image arrays
	pub maxImageArrayLayers                          : u32,
	/// max texel buffer size (fstexels)
	pub maxTexelBufferElements                       : u32,
	/// max uniform buffer range (bytes)
	pub maxUniformBufferRange                        : u32,
	/// max storage buffer range (bytes)
	pub maxStorageBufferRange                        : u32,
	/// max size of the push constants pool (bytes)
	pub maxPushConstantsSize                         : u32,
	/// max number of device memory allocations supported
	pub maxMemoryAllocationCount                     : u32,
	/// max number of samplers that can be allocated on a device
	pub maxSamplerAllocationCount                    : u32,
	/// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
	pub bufferImageGranularity                       : VkDeviceSize,
	/// Total address space available for sparse allocations (bytes)
	pub sparseAddressSpaceSize                       : VkDeviceSize,
	/// max number of descriptors sets that can be bound to a pipeline
	pub maxBoundDescriptorSets                       : u32,
	/// max number of samplers allowed per-stage in a descriptor set
	pub maxPerStageDescriptorSamplers                : u32,
	/// max number of uniform buffers allowed per-stage in a descriptor set
	pub maxPerStageDescriptorUniformBuffers          : u32,
	/// max number of storage buffers allowed per-stage in a descriptor set
	pub maxPerStageDescriptorStorageBuffers          : u32,
	/// max number of sampled images allowed per-stage in a descriptor set
	pub maxPerStageDescriptorSampledImages           : u32,
	/// max number of storage images allowed per-stage in a descriptor set
	pub maxPerStageDescriptorStorageImages           : u32,
	/// max number of input attachments allowed per-stage in a descriptor set
	pub maxPerStageDescriptorInputAttachments        : u32,
	/// max number of resources allowed by a single stage
	pub maxPerStageResources                         : u32,
	/// max number of samplers allowed in all stages in a descriptor set
	pub maxDescriptorSetSamplers                     : u32,
	/// max number of uniform buffers allowed in all stages in a descriptor set
	pub maxDescriptorSetUniformBuffers               : u32,
	/// max number of dynamic uniform buffers allowed in all stages in a descriptor set
	pub maxDescriptorSetUniformBuffersDynamic        : u32,
	/// max number of storage buffers allowed in all stages in a descriptor set
	pub maxDescriptorSetStorageBuffers               : u32,
	/// max number of dynamic storage buffers allowed in all stages in a descriptor set
	pub maxDescriptorSetStorageBuffersDynamic        : u32,
	/// max number of sampled images allowed in all stages in a descriptor set
	pub maxDescriptorSetSampledImages                : u32,
	/// max number of storage images allowed in all stages in a descriptor set
	pub maxDescriptorSetStorageImages                : u32,
	/// max number of input attachments allowed in all stages in a descriptor set
	pub maxDescriptorSetInputAttachments             : u32,
	/// max number of vertex input attribute slots
	pub maxVertexInputAttributes                     : u32,
	/// max number of vertex input binding slots
	pub maxVertexInputBindings                       : u32,
	/// max vertex input attribute offset added to vertex buffer offset
	pub maxVertexInputAttributeOffset                : u32,
	/// max vertex input binding stride
	pub maxVertexInputBindingStride                  : u32,
	/// max number of output components written by vertex shader
	pub maxVertexOutputComponents                    : u32,
	/// max level supported by tessellation primitive generator
	pub maxTessellationGenerationLevel               : u32,
	/// max patch size (vertices)
	pub maxTessellationPatchSize                     : u32,
	/// max number of input components per-vertex in TCS
	pub maxTessellationControlPerVertexInputComponents: u32,
	/// max number of output components per-vertex in TCS
	pub maxTessellationControlPerVertexOutputComponents: u32,
	/// max number of output components per-patch in TCS
	pub maxTessellationControlPerPatchOutputComponents: u32,
	/// max total number of per-vertex and per-patch output components in TCS
	pub maxTessellationControlTotalOutputComponents  : u32,
	/// max number of input components per vertex in TES
	pub maxTessellationEvaluationInputComponents     : u32,
	/// max number of output components per vertex in TES
	pub maxTessellationEvaluationOutputComponents    : u32,
	/// max invocation count supported in geometry shader
	pub maxGeometryShaderInvocations                 : u32,
	/// max number of input components read in geometry stage
	pub maxGeometryInputComponents                   : u32,
	/// max number of output components written in geometry stage
	pub maxGeometryOutputComponents                  : u32,
	/// max number of vertices that can be emitted in geometry stage
	pub maxGeometryOutputVertices                    : u32,
	/// max total number of components (all vertices) written in geometry stage
	pub maxGeometryTotalOutputComponents             : u32,
	/// max number of input components read in fragment stage
	pub maxFragmentInputComponents                   : u32,
	/// max number of output attachments written in fragment stage
	pub maxFragmentOutputAttachments                 : u32,
	/// max number of output attachments written when using dual source blending
	pub maxFragmentDualSrcAttachments                : u32,
	/// max total number of storage buffers, storage images and output buffers
	pub maxFragmentCombinedOutputResources           : u32,
	/// max total storage size of work group local storage (bytes)
	pub maxComputeSharedMemorySize                   : u32,
	/// max num of compute work groups that may be dispatched by a single command (x,y,z)
	pub maxComputeWorkGroupCount                     : [u32;  3 as usize],
	/// max total compute invocations in a single local work group
	pub maxComputeWorkGroupInvocations               : u32,
	/// max local size of a compute work group (x,y,z)
	pub maxComputeWorkGroupSize                      : [u32;  3 as usize],
	/// number bits of subpixel precision in screen x and y
	pub subPixelPrecisionBits                        : u32,
	/// number bits of precision for selecting texel weights
	pub subTexelPrecisionBits                        : u32,
	/// number bits of precision for selecting mipmap weights
	pub mipmapPrecisionBits                          : u32,
	/// max index value for indexed draw calls (for 32-bit indices)
	pub maxDrawIndexedIndexValue                     : u32,
	/// max draw count for indirect draw calls
	pub maxDrawIndirectCount                         : u32,
	/// max absolute sampler LOD bias
	pub maxSamplerLodBias                            : f32,
	/// max degree of sampler anisotropy
	pub maxSamplerAnisotropy                         : f32,
	/// max number of active viewports
	pub maxViewports                                 : u32,
	/// max viewport dimensions (x,y)
	pub maxViewportDimensions                        : [u32;  2 as usize],
	/// viewport bounds range (min,max)
	pub viewportBoundsRange                          : [f32;  2 as usize],
	/// number bits of subpixel precision for viewport
	pub viewportSubPixelBits                         : u32,
	/// min required alignment of pointers returned by MapMemory (bytes)
	pub minMemoryMapAlignment                        : usize,
	/// min required alignment for texel buffer offsets (bytes)
	pub minTexelBufferOffsetAlignment                : VkDeviceSize,
	/// min required alignment for uniform buffer sizes and offsets (bytes)
	pub minUniformBufferOffsetAlignment              : VkDeviceSize,
	/// min required alignment for storage buffer offsets (bytes)
	pub minStorageBufferOffsetAlignment              : VkDeviceSize,
	/// min texel offset for OpTextureSampleOffset
	pub minTexelOffset                               : i32,
	/// max texel offset for OpTextureSampleOffset
	pub maxTexelOffset                               : u32,
	/// min texel offset for OpTextureGatherOffset
	pub minTexelGatherOffset                         : i32,
	/// max texel offset for OpTextureGatherOffset
	pub maxTexelGatherOffset                         : u32,
	/// furthest negative offset for interpolateAtOffset
	pub minInterpolationOffset                       : f32,
	/// furthest positive offset for interpolateAtOffset
	pub maxInterpolationOffset                       : f32,
	/// number of subpixel bits for interpolateAtOffset
	pub subPixelInterpolationOffsetBits              : u32,
	/// max width for a framebuffer
	pub maxFramebufferWidth                          : u32,
	/// max height for a framebuffer
	pub maxFramebufferHeight                         : u32,
	/// max layer count for a layered framebuffer
	pub maxFramebufferLayers                         : u32,
	/// supported color sample counts for a framebuffer
	pub framebufferColorSampleCounts                 : VkSampleCountFlags,
	/// supported depth sample counts for a framebuffer
	pub framebufferDepthSampleCounts                 : VkSampleCountFlags,
	/// supported stencil sample counts for a framebuffer
	pub framebufferStencilSampleCounts               : VkSampleCountFlags,
	/// supported sample counts for a subpass which uses no attachments
	pub framebufferNoAttachmentsSampleCounts         : VkSampleCountFlags,
	/// max number of color attachments per subpass
	pub maxColorAttachments                          : u32,
	/// supported color sample counts for a non-integer sampled image
	pub sampledImageColorSampleCounts                : VkSampleCountFlags,
	/// supported sample counts for an integer image
	pub sampledImageIntegerSampleCounts              : VkSampleCountFlags,
	/// supported depth sample counts for a sampled image
	pub sampledImageDepthSampleCounts                : VkSampleCountFlags,
	/// supported stencil sample counts for a sampled image
	pub sampledImageStencilSampleCounts              : VkSampleCountFlags,
	/// supported sample counts for a storage image
	pub storageImageSampleCounts                     : VkSampleCountFlags,
	/// max number of sample mask words
	pub maxSampleMaskWords                           : u32,
	/// timestamps on graphics and compute queues
	pub timestampComputeAndGraphics                  : VkBool32,
	/// number of nanoseconds it takes for timestamp query value to increment by 1
	pub timestampPeriod                              : f32,
	/// max number of clip distances
	pub maxClipDistances                             : u32,
	/// max number of cull distances
	pub maxCullDistances                             : u32,
	/// max combined number of user clipping
	pub maxCombinedClipAndCullDistances              : u32,
	/// distinct queue priorities available
	pub discreteQueuePriorities                      : u32,
	/// range (min,max) of supported point sizes
	pub pointSizeRange                               : [f32;  2 as usize],
	/// range (min,max) of supported line widths
	pub lineWidthRange                               : [f32;  2 as usize],
	/// granularity of supported point sizes
	pub pointSizeGranularity                         : f32,
	/// granularity of supported line widths
	pub lineWidthGranularity                         : f32,
	/// line rasterization follows preferred rules
	pub strictLines                                  : VkBool32,
	/// supports standard sample locations for all supported sample counts
	pub standardSampleLocations                      : VkBool32,
	/// optimal offset of buffer copies
	pub optimalBufferCopyOffsetAlignment             : VkDeviceSize,
	/// optimal pitch of buffer copies
	pub optimalBufferCopyRowPitchAlignment           : VkDeviceSize,
	/// minimum size and alignment for non-coherent host-mapped device memory access
	pub nonCoherentAtomSize                          : VkDeviceSize,
}

unsafe impl Send for VkPhysicalDeviceLimits {}
unsafe impl Sync for VkPhysicalDeviceLimits {}

impl fmt::Debug for VkPhysicalDeviceLimits {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLimits").finish()
	}
}

impl Default for VkPhysicalDeviceLimits {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Semaphore creation flags
	pub flags                                        : VkSemaphoreCreateFlags,
}

unsafe impl Send for VkSemaphoreCreateInfo<'_> {}
unsafe impl Sync for VkSemaphoreCreateInfo<'_> {}

impl Default for VkSemaphoreCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkQueryPoolCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkQueryPoolCreateFlags,
	pub queryType                                    : VkQueryType,
	pub queryCount                                   : u32,
	/// Optional
	pub pipelineStatistics                           : VkQueryPipelineStatisticFlags,
}

unsafe impl Send for VkQueryPoolCreateInfo<'_> {}
unsafe impl Sync for VkQueryPoolCreateInfo<'_> {}

impl Default for VkQueryPoolCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFramebufferCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkFramebufferCreateFlags,
	pub renderPass                                   : VkRenderPass,
	pub attachmentCount                              : u32,
	pub pAttachments                                 : *const VkImageView,
	pub width                                        : u32,
	pub height                                       : u32,
	pub layers                                       : u32,
}

unsafe impl Send for VkFramebufferCreateInfo<'_> {}
unsafe impl Sync for VkFramebufferCreateInfo<'_> {}

impl Default for VkFramebufferCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDrawIndirectCommand {
	pub vertexCount                                  : u32,
	pub instanceCount                                : u32,
	pub firstVertex                                  : u32,
	pub firstInstance                                : u32,
}

unsafe impl Send for VkDrawIndirectCommand {}
unsafe impl Sync for VkDrawIndirectCommand {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDrawIndexedIndirectCommand {
	pub indexCount                                   : u32,
	pub instanceCount                                : u32,
	pub firstIndex                                   : u32,
	pub vertexOffset                                 : i32,
	pub firstInstance                                : u32,
}

unsafe impl Send for VkDrawIndexedIndirectCommand {}
unsafe impl Sync for VkDrawIndexedIndirectCommand {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDispatchIndirectCommand {
	pub x                                            : u32,
	pub y                                            : u32,
	pub z                                            : u32,
}

unsafe impl Send for VkDispatchIndirectCommand {}
unsafe impl Sync for VkDispatchIndirectCommand {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkMultiDrawInfoEXT {
	pub firstVertex                                  : u32,
	pub vertexCount                                  : u32,
}

unsafe impl Send for VkMultiDrawInfoEXT {}
unsafe impl Sync for VkMultiDrawInfoEXT {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkMultiDrawIndexedInfoEXT {
	pub firstIndex                                   : u32,
	pub indexCount                                   : u32,
	pub vertexOffset                                 : i32,
}

unsafe impl Send for VkMultiDrawIndexedInfoEXT {}
unsafe impl Sync for VkMultiDrawIndexedInfoEXT {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubmitInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub waitSemaphoreCount                           : u32,
	pub pWaitSemaphores                              : *const VkSemaphore,
	pub pWaitDstStageMask                            : *const VkPipelineStageFlags,
	pub commandBufferCount                           : u32,
	pub pCommandBuffers                              : *const VkCommandBuffer,
	pub signalSemaphoreCount                         : u32,
	pub pSignalSemaphores                            : *const VkSemaphore,
}

unsafe impl Send for VkSubmitInfo<'_> {}
unsafe impl Sync for VkSubmitInfo<'_> {}

impl Default for VkSubmitInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}
// WSI extensions

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPropertiesKHR {
	/// Handle of the display object
	pub display                                      : VkDisplayKHR,
	/// Name of the display
	pub displayName                                  : *const u8,
	/// In millimeters?
	pub physicalDimensions                           : VkExtent2D,
	/// Max resolution for CRT?
	pub physicalResolution                           : VkExtent2D,
	/// one or more bits from VkSurfaceTransformFlagsKHR
	pub supportedTransforms                          : VkSurfaceTransformFlagsKHR,
	/// VK_TRUE if the overlay plane's z-order can be changed on this display.
	pub planeReorderPossible                         : VkBool32,
	/// VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
	pub persistentContent                            : VkBool32,
}

unsafe impl Send for VkDisplayPropertiesKHR {}
unsafe impl Sync for VkDisplayPropertiesKHR {}

impl fmt::Debug for VkDisplayPropertiesKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPropertiesKHR").finish()
	}
}

impl Default for VkDisplayPropertiesKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDisplayPlanePropertiesKHR {
	/// Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
	pub currentDisplay                               : VkDisplayKHR,
	/// Current z-order of the plane.
	pub currentStackIndex                            : u32,
}

unsafe impl Send for VkDisplayPlanePropertiesKHR {}
unsafe impl Sync for VkDisplayPlanePropertiesKHR {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModeParametersKHR {
	/// Visible scanout region.
	pub visibleRegion                                : VkExtent2D,
	/// Number of times per second the display is updated.
	pub refreshRate                                  : u32,
}

unsafe impl Send for VkDisplayModeParametersKHR {}
unsafe impl Sync for VkDisplayModeParametersKHR {}

impl fmt::Debug for VkDisplayModeParametersKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeParametersKHR").finish()
	}
}

impl Default for VkDisplayModeParametersKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModePropertiesKHR {
	/// Handle of this display mode.
	pub displayMode                                  : VkDisplayModeKHR,
	/// The parameters this mode uses.
	pub parameters                                   : VkDisplayModeParametersKHR,
}

unsafe impl Send for VkDisplayModePropertiesKHR {}
unsafe impl Sync for VkDisplayModePropertiesKHR {}

impl fmt::Debug for VkDisplayModePropertiesKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModePropertiesKHR").finish()
	}
}

impl Default for VkDisplayModePropertiesKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayModeCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDisplayModeCreateFlagsKHR,
	/// The parameters this mode uses.
	pub parameters                                   : VkDisplayModeParametersKHR,
}

unsafe impl Send for VkDisplayModeCreateInfoKHR<'_> {}
unsafe impl Sync for VkDisplayModeCreateInfoKHR<'_> {}

impl fmt::Debug for VkDisplayModeCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeCreateInfoKHR").finish()
	}
}

impl Default for VkDisplayModeCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPlaneCapabilitiesKHR {
	/// Types of alpha blending supported, if any.
	pub supportedAlpha                               : VkDisplayPlaneAlphaFlagsKHR,
	/// Does the plane have any position and extent restrictions?
	pub minSrcPosition                               : VkOffset2D,
	pub maxSrcPosition                               : VkOffset2D,
	pub minSrcExtent                                 : VkExtent2D,
	pub maxSrcExtent                                 : VkExtent2D,
	pub minDstPosition                               : VkOffset2D,
	pub maxDstPosition                               : VkOffset2D,
	pub minDstExtent                                 : VkExtent2D,
	pub maxDstExtent                                 : VkExtent2D,
}

unsafe impl Send for VkDisplayPlaneCapabilitiesKHR {}
unsafe impl Sync for VkDisplayPlaneCapabilitiesKHR {}

impl fmt::Debug for VkDisplayPlaneCapabilitiesKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneCapabilitiesKHR").finish()
	}
}

impl Default for VkDisplayPlaneCapabilitiesKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplaySurfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDisplaySurfaceCreateFlagsKHR,
	/// The mode to use when displaying this surface
	pub displayMode                                  : VkDisplayModeKHR,
	/// The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
	pub planeIndex                                   : u32,
	/// The z-order of the plane.
	pub planeStackIndex                              : u32,
	/// Transform to apply to the images as part of the scanout operation
	pub transform                                    : VkSurfaceTransformFlagBitsKHR,
	/// Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
	pub globalAlpha                                  : f32,
	/// What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.
	pub alphaMode                                    : VkDisplayPlaneAlphaFlagBitsKHR,
	/// size of the images to use with this surface
	pub imageExtent                                  : VkExtent2D,
}

unsafe impl Send for VkDisplaySurfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkDisplaySurfaceCreateInfoKHR<'_> {}

impl fmt::Debug for VkDisplaySurfaceCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplaySurfaceCreateInfoKHR").finish()
	}
}

impl Default for VkDisplaySurfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDisplayPresentInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Rectangle within the presentable image to read pixel data from when presenting to the display.
	pub srcRect                                      : VkRect2D,
	/// Rectangle within the current display mode's visible region to display srcRectangle in.
	pub dstRect                                      : VkRect2D,
	/// For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
	pub persistent                                   : VkBool32,
}

unsafe impl Send for VkDisplayPresentInfoKHR<'_> {}
unsafe impl Sync for VkDisplayPresentInfoKHR<'_> {}

impl fmt::Debug for VkDisplayPresentInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPresentInfoKHR").finish()
	}
}

impl Default for VkDisplayPresentInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceCapabilitiesKHR {
	/// Supported minimum number of images for the surface
	pub minImageCount                                : u32,
	/// Supported maximum number of images for the surface, 0 for unlimited
	pub maxImageCount                                : u32,
	/// Current image width and height for the surface, (0, 0) if undefined
	pub currentExtent                                : VkExtent2D,
	/// Supported minimum image width and height for the surface
	pub minImageExtent                               : VkExtent2D,
	/// Supported maximum image width and height for the surface
	pub maxImageExtent                               : VkExtent2D,
	/// Supported maximum number of image layers for the surface
	pub maxImageArrayLayers                          : u32,
	/// 1 or more bits representing the transforms supported
	pub supportedTransforms                          : VkSurfaceTransformFlagsKHR,
	/// The surface's current transform relative to the device's natural orientation
	pub currentTransform                             : VkSurfaceTransformFlagBitsKHR,
	/// 1 or more bits representing the alpha compositing modes supported
	pub supportedCompositeAlpha                      : VkCompositeAlphaFlagsKHR,
	/// Supported image usage flags for the surface
	pub supportedUsageFlags                          : VkImageUsageFlags,
}

unsafe impl Send for VkSurfaceCapabilitiesKHR {}
unsafe impl Sync for VkSurfaceCapabilitiesKHR {}

impl fmt::Debug for VkSurfaceCapabilitiesKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilitiesKHR").finish()
	}
}

impl Default for VkSurfaceCapabilitiesKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkAndroidSurfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkAndroidSurfaceCreateFlagsKHR,
	pub window                                       : &'a mut ANativeWindow,
}

unsafe impl Send for VkAndroidSurfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkAndroidSurfaceCreateInfoKHR<'_> {}

impl fmt::Debug for VkAndroidSurfaceCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAndroidSurfaceCreateInfoKHR").finish()
	}
}

impl Default for VkAndroidSurfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkViSurfaceCreateInfoNN<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkViSurfaceCreateFlagsNN,
	pub window                                       : VkAnyMut<'a>,
}

unsafe impl Send for VkViSurfaceCreateInfoNN<'_> {}
unsafe impl Sync for VkViSurfaceCreateInfoNN<'_> {}

impl Default for VkViSurfaceCreateInfoNN<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkWaylandSurfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkWaylandSurfaceCreateFlagsKHR,
	pub display                                      : &'a mut wl_display,
	pub surface                                      : &'a mut wl_surface,
}

unsafe impl Send for VkWaylandSurfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkWaylandSurfaceCreateInfoKHR<'_> {}

impl fmt::Debug for VkWaylandSurfaceCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkWaylandSurfaceCreateInfoKHR").finish()
	}
}

impl Default for VkWaylandSurfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkWin32SurfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkWin32SurfaceCreateFlagsKHR,
	pub hinstance                                    : HINSTANCE,
	pub hwnd                                         : HWND,
}

unsafe impl Send for VkWin32SurfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkWin32SurfaceCreateInfoKHR<'_> {}

impl fmt::Debug for VkWin32SurfaceCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkWin32SurfaceCreateInfoKHR").finish()
	}
}

impl Default for VkWin32SurfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkXlibSurfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkXlibSurfaceCreateFlagsKHR,
	pub dpy                                          : &'a mut Display,
	pub window                                       : Window,
}

unsafe impl Send for VkXlibSurfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkXlibSurfaceCreateInfoKHR<'_> {}

impl fmt::Debug for VkXlibSurfaceCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkXlibSurfaceCreateInfoKHR").finish()
	}
}

impl Default for VkXlibSurfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkXcbSurfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkXcbSurfaceCreateFlagsKHR,
	pub connection                                   : &'a mut xcb_connection_t,
	pub window                                       : xcb_window_t,
}

unsafe impl Send for VkXcbSurfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkXcbSurfaceCreateInfoKHR<'_> {}

impl fmt::Debug for VkXcbSurfaceCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkXcbSurfaceCreateInfoKHR").finish()
	}
}

impl Default for VkXcbSurfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDirectFBSurfaceCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDirectFBSurfaceCreateFlagsEXT,
	pub dfb                                          : &'a mut IDirectFB,
	pub surface                                      : &'a mut IDirectFBSurface,
}

unsafe impl Send for VkDirectFBSurfaceCreateInfoEXT<'_> {}
unsafe impl Sync for VkDirectFBSurfaceCreateInfoEXT<'_> {}

impl fmt::Debug for VkDirectFBSurfaceCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDirectFBSurfaceCreateInfoEXT").finish()
	}
}

impl Default for VkDirectFBSurfaceCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkImagePipeSurfaceCreateInfoFUCHSIA<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkImagePipeSurfaceCreateFlagsFUCHSIA,
	pub imagePipeHandle                              : zx_handle_t,
}

unsafe impl Send for VkImagePipeSurfaceCreateInfoFUCHSIA<'_> {}
unsafe impl Sync for VkImagePipeSurfaceCreateInfoFUCHSIA<'_> {}

impl fmt::Debug for VkImagePipeSurfaceCreateInfoFUCHSIA<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImagePipeSurfaceCreateInfoFUCHSIA").finish()
	}
}

impl Default for VkImagePipeSurfaceCreateInfoFUCHSIA<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkStreamDescriptorSurfaceCreateInfoGGP<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkStreamDescriptorSurfaceCreateFlagsGGP,
	pub streamDescriptor                             : GgpStreamDescriptor,
}

unsafe impl Send for VkStreamDescriptorSurfaceCreateInfoGGP<'_> {}
unsafe impl Sync for VkStreamDescriptorSurfaceCreateInfoGGP<'_> {}

impl fmt::Debug for VkStreamDescriptorSurfaceCreateInfoGGP<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkStreamDescriptorSurfaceCreateInfoGGP").finish()
	}
}

impl Default for VkStreamDescriptorSurfaceCreateInfoGGP<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkScreenSurfaceCreateInfoQNX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkScreenSurfaceCreateFlagsQNX,
	pub context                                      : &'a mut _screen_context,
	pub window                                       : &'a mut _screen_window,
}

unsafe impl Send for VkScreenSurfaceCreateInfoQNX<'_> {}
unsafe impl Sync for VkScreenSurfaceCreateInfoQNX<'_> {}

impl fmt::Debug for VkScreenSurfaceCreateInfoQNX<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkScreenSurfaceCreateInfoQNX").finish()
	}
}

impl Default for VkScreenSurfaceCreateInfoQNX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSurfaceFormatKHR {
	/// Supported pair of rendering format
	pub format                                       : VkFormat,
	/// and color space for the surface
	pub colorSpace                                   : VkColorSpaceKHR,
}

unsafe impl Send for VkSurfaceFormatKHR {}
unsafe impl Sync for VkSurfaceFormatKHR {}

impl Default for VkSurfaceFormatKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSwapchainCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkSwapchainCreateFlagsKHR,
	/// The swapchain's target surface
	pub surface                                      : VkSurfaceKHR,
	/// Minimum number of presentation images the application needs
	pub minImageCount                                : u32,
	/// Format of the presentation images
	pub imageFormat                                  : VkFormat,
	/// Colorspace of the presentation images
	pub imageColorSpace                              : VkColorSpaceKHR,
	/// Dimensions of the presentation images
	pub imageExtent                                  : VkExtent2D,
	/// Determines the number of views for multiview/stereo presentation
	pub imageArrayLayers                             : u32,
	/// Bits indicating how the presentation images will be used
	pub imageUsage                                   : VkImageUsageFlags,
	/// Sharing mode used for the presentation images
	pub imageSharingMode                             : VkSharingMode,
	/// Number of queue families having access to the images in case of concurrent sharing mode
	pub queueFamilyIndexCount                        : u32,
	/// Array of queue family indices having access to the images in case of concurrent sharing mode
	pub pQueueFamilyIndices                          : *const u32,
	/// The transform, relative to the device's natural orientation, applied to the image content prior to presentation
	pub preTransform                                 : VkSurfaceTransformFlagBitsKHR,
	/// The alpha blending mode used when compositing this surface with other surfaces in the window system
	pub compositeAlpha                               : VkCompositeAlphaFlagBitsKHR,
	/// Which presentation mode to use for presents on this swap chain
	pub presentMode                                  : VkPresentModeKHR,
	/// Specifies whether presentable images may be affected by window clip regions
	pub clipped                                      : VkBool32,
	/// Existing swap chain to replace, if any
	pub oldSwapchain                                 : VkSwapchainKHR,
}

unsafe impl Send for VkSwapchainCreateInfoKHR<'_> {}
unsafe impl Sync for VkSwapchainCreateInfoKHR<'_> {}

impl fmt::Debug for VkSwapchainCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainCreateInfoKHR").finish()
	}
}

impl Default for VkSwapchainCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPresentInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Number of semaphores to wait for before presenting
	pub waitSemaphoreCount                           : u32,
	/// Semaphores to wait for before presenting
	pub pWaitSemaphores                              : *const VkSemaphore,
	/// Number of swapchains to present in this call
	pub swapchainCount                               : u32,
	/// Swapchains to present an image from
	pub pSwapchains                                  : *const VkSwapchainKHR,
	/// Indices of which presentable images to present
	pub pImageIndices                                : *const u32,
	/// Optional (i.e. if non-NULL) VkResult for each swapchain
	pub pResults                                     : *mut VkResult,
}

unsafe impl Send for VkPresentInfoKHR<'_> {}
unsafe impl Sync for VkPresentInfoKHR<'_> {}

impl Default for VkPresentInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDebugReportCallbackCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Indicates which events call this callback
	pub flags                                        : VkDebugReportFlagsEXT,
	/// Function pointer of a callback function
	pub pfnCallback                                  : PFN_vkDebugReportCallbackEXT,
	/// User data provided to callback function
	pub pUserData                                    : Option<VkAnyMut<'a>>,
}

unsafe impl Send for VkDebugReportCallbackCreateInfoEXT<'_> {}
unsafe impl Sync for VkDebugReportCallbackCreateInfoEXT<'_> {}

impl fmt::Debug for VkDebugReportCallbackCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDebugReportCallbackCreateInfoEXT").finish()
	}
}

impl Default for VkDebugReportCallbackCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkValidationFlagsEXT<'a> {
	/// Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Number of validation checks to disable
	pub disabledValidationCheckCount                 : u32,
	/// Validation checks to disable
	pub pDisabledValidationChecks                    : *const VkValidationCheckEXT,
}

unsafe impl Send for VkValidationFlagsEXT<'_> {}
unsafe impl Sync for VkValidationFlagsEXT<'_> {}

impl Default for VkValidationFlagsEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkValidationFeaturesEXT<'a> {
	/// Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Number of validation features to enable
	pub enabledValidationFeatureCount                : u32,
	/// Validation features to enable
	pub pEnabledValidationFeatures                   : *const VkValidationFeatureEnableEXT,
	/// Number of validation features to disable
	pub disabledValidationFeatureCount               : u32,
	/// Validation features to disable
	pub pDisabledValidationFeatures                  : *const VkValidationFeatureDisableEXT,
}

unsafe impl Send for VkValidationFeaturesEXT<'_> {}
unsafe impl Sync for VkValidationFeaturesEXT<'_> {}

impl Default for VkValidationFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Rasterization order to use for the pipeline
	pub rasterizationOrder                           : VkRasterizationOrderAMD,
}

unsafe impl Send for VkPipelineRasterizationStateRasterizationOrderAMD<'_> {}
unsafe impl Sync for VkPipelineRasterizationStateRasterizationOrderAMD<'_> {}

impl Default for VkPipelineRasterizationStateRasterizationOrderAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDebugMarkerObjectNameInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// The type of the object
	pub objectType                                   : VkDebugReportObjectTypeEXT,
	/// The handle of the object, cast to uint64_t
	pub object                                       : u64,
	/// Name to apply to the object
	pub pObjectName                                  : *const u8,
}

unsafe impl Send for VkDebugMarkerObjectNameInfoEXT<'_> {}
unsafe impl Sync for VkDebugMarkerObjectNameInfoEXT<'_> {}

impl Default for VkDebugMarkerObjectNameInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDebugMarkerObjectTagInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// The type of the object
	pub objectType                                   : VkDebugReportObjectTypeEXT,
	/// The handle of the object, cast to uint64_t
	pub object                                       : u64,
	/// The name of the tag to set on the object
	pub tagName                                      : u64,
	/// The length in bytes of the tag data
	pub tagSize                                      : usize,
	/// Tag data to attach to the object
	pub pTag                                         : *const (),
}

unsafe impl Send for VkDebugMarkerObjectTagInfoEXT<'_> {}
unsafe impl Sync for VkDebugMarkerObjectTagInfoEXT<'_> {}

impl Default for VkDebugMarkerObjectTagInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugMarkerMarkerInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Name of the debug marker
	pub pMarkerName                                  : *const u8,
	/// Optional color for debug marker
	pub color                                        : [f32;  4 as usize],
}

unsafe impl Send for VkDebugMarkerMarkerInfoEXT<'_> {}
unsafe impl Sync for VkDebugMarkerMarkerInfoEXT<'_> {}

impl fmt::Debug for VkDebugMarkerMarkerInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDebugMarkerMarkerInfoEXT").finish()
	}
}

impl Default for VkDebugMarkerMarkerInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDedicatedAllocationImageCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Whether this image uses a dedicated allocation
	pub dedicatedAllocation                          : VkBool32,
}

unsafe impl Send for VkDedicatedAllocationImageCreateInfoNV<'_> {}
unsafe impl Sync for VkDedicatedAllocationImageCreateInfoNV<'_> {}

impl Default for VkDedicatedAllocationImageCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDedicatedAllocationBufferCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Whether this buffer uses a dedicated allocation
	pub dedicatedAllocation                          : VkBool32,
}

unsafe impl Send for VkDedicatedAllocationBufferCreateInfoNV<'_> {}
unsafe impl Sync for VkDedicatedAllocationBufferCreateInfoNV<'_> {}

impl Default for VkDedicatedAllocationBufferCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Image that this allocation will be bound to
	pub image                                        : VkImage,
	/// Buffer that this allocation will be bound to
	pub buffer                                       : VkBuffer,
}

unsafe impl Send for VkDedicatedAllocationMemoryAllocateInfoNV<'_> {}
unsafe impl Sync for VkDedicatedAllocationMemoryAllocateInfoNV<'_> {}

impl Default for VkDedicatedAllocationMemoryAllocateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExternalImageFormatPropertiesNV {
	pub imageFormatProperties                        : VkImageFormatProperties,
	pub externalMemoryFeatures                       : VkExternalMemoryFeatureFlagsNV,
	pub exportFromImportedHandleTypes                : VkExternalMemoryHandleTypeFlagsNV,
	pub compatibleHandleTypes                        : VkExternalMemoryHandleTypeFlagsNV,
}

unsafe impl Send for VkExternalImageFormatPropertiesNV {}
unsafe impl Sync for VkExternalImageFormatPropertiesNV {}

impl fmt::Debug for VkExternalImageFormatPropertiesNV {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExternalImageFormatPropertiesNV").finish()
	}
}

impl Default for VkExternalImageFormatPropertiesNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExternalMemoryImageCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalMemoryHandleTypeFlagsNV,
}

unsafe impl Send for VkExternalMemoryImageCreateInfoNV<'_> {}
unsafe impl Sync for VkExternalMemoryImageCreateInfoNV<'_> {}

impl Default for VkExternalMemoryImageCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExportMemoryAllocateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalMemoryHandleTypeFlagsNV,
}

unsafe impl Send for VkExportMemoryAllocateInfoNV<'_> {}
unsafe impl Sync for VkExportMemoryAllocateInfoNV<'_> {}

impl Default for VkExportMemoryAllocateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkImportMemoryWin32HandleInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagsNV,
	pub handle                                       : HANDLE,
}

unsafe impl Send for VkImportMemoryWin32HandleInfoNV<'_> {}
unsafe impl Sync for VkImportMemoryWin32HandleInfoNV<'_> {}

impl fmt::Debug for VkImportMemoryWin32HandleInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportMemoryWin32HandleInfoNV").finish()
	}
}

impl Default for VkImportMemoryWin32HandleInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkExportMemoryWin32HandleInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pAttributes                                  : Option<&'a SECURITY_ATTRIBUTES>,
	pub dwAccess                                     : DWORD,
}

unsafe impl Send for VkExportMemoryWin32HandleInfoNV<'_> {}
unsafe impl Sync for VkExportMemoryWin32HandleInfoNV<'_> {}

impl fmt::Debug for VkExportMemoryWin32HandleInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExportMemoryWin32HandleInfoNV").finish()
	}
}

impl Default for VkExportMemoryWin32HandleInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWin32KeyedMutexAcquireReleaseInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub acquireCount                                 : u32,
	pub pAcquireSyncs                                : *const VkDeviceMemory,
	pub pAcquireKeys                                 : *const u64,
	pub pAcquireTimeoutMilliseconds                  : *const u32,
	pub releaseCount                                 : u32,
	pub pReleaseSyncs                                : *const VkDeviceMemory,
	pub pReleaseKeys                                 : *const u64,
}

unsafe impl Send for VkWin32KeyedMutexAcquireReleaseInfoNV<'_> {}
unsafe impl Sync for VkWin32KeyedMutexAcquireReleaseInfoNV<'_> {}

impl Default for VkWin32KeyedMutexAcquireReleaseInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub deviceGeneratedCommands                      : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDevicePrivateDataCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub privateDataSlotRequestCount                  : u32,
}

unsafe impl Send for VkDevicePrivateDataCreateInfoEXT<'_> {}
unsafe impl Sync for VkDevicePrivateDataCreateInfoEXT<'_> {}

impl Default for VkDevicePrivateDataCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPrivateDataSlotCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPrivateDataSlotCreateFlagsEXT,
}

unsafe impl Send for VkPrivateDataSlotCreateInfoEXT<'_> {}
unsafe impl Sync for VkPrivateDataSlotCreateInfoEXT<'_> {}

impl Default for VkPrivateDataSlotCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePrivateDataFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub privateData                                  : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePrivateDataFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDevicePrivateDataFeaturesEXT<'_> {}

impl Default for VkPhysicalDevicePrivateDataFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxGraphicsShaderGroupCount                  : u32,
	pub maxIndirectSequenceCount                     : u32,
	pub maxIndirectCommandsTokenCount                : u32,
	pub maxIndirectCommandsStreamCount               : u32,
	pub maxIndirectCommandsTokenOffset               : u32,
	pub maxIndirectCommandsStreamStride              : u32,
	pub minSequencesCountBufferOffsetAlignment       : u32,
	pub minSequencesIndexBufferOffsetAlignment       : u32,
	pub minIndirectCommandsBufferOffsetAlignment     : u32,
}

unsafe impl Send for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'_> {}

impl Default for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMultiDrawPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxMultiDrawCount                            : u32,
}

unsafe impl Send for VkPhysicalDeviceMultiDrawPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceMultiDrawPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceMultiDrawPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGraphicsShaderGroupCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub stageCount                                   : u32,
	pub pStages                                      : *const VkPipelineShaderStageCreateInfo<'a>,
	pub pVertexInputState                            : Option<&'a VkPipelineVertexInputStateCreateInfo<'a>>,
	pub pTessellationState                           : Option<&'a VkPipelineTessellationStateCreateInfo<'a>>,
}

unsafe impl Send for VkGraphicsShaderGroupCreateInfoNV<'_> {}
unsafe impl Sync for VkGraphicsShaderGroupCreateInfoNV<'_> {}

impl fmt::Debug for VkGraphicsShaderGroupCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsShaderGroupCreateInfoNV").finish()
	}
}

impl Default for VkGraphicsShaderGroupCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGraphicsPipelineShaderGroupsCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub groupCount                                   : u32,
	pub pGroups                                      : *const VkGraphicsShaderGroupCreateInfoNV<'a>,
	pub pipelineCount                                : u32,
	pub pPipelines                                   : *const VkPipeline,
}

unsafe impl Send for VkGraphicsPipelineShaderGroupsCreateInfoNV<'_> {}
unsafe impl Sync for VkGraphicsPipelineShaderGroupsCreateInfoNV<'_> {}

impl fmt::Debug for VkGraphicsPipelineShaderGroupsCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsPipelineShaderGroupsCreateInfoNV").finish()
	}
}

impl Default for VkGraphicsPipelineShaderGroupsCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkBindShaderGroupIndirectCommandNV {
	pub groupIndex                                   : u32,
}

unsafe impl Send for VkBindShaderGroupIndirectCommandNV {}
unsafe impl Sync for VkBindShaderGroupIndirectCommandNV {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindIndexBufferIndirectCommandNV {
	pub bufferAddress                                : VkDeviceAddress,
	pub size                                         : u32,
	pub indexType                                    : VkIndexType,
}

unsafe impl Send for VkBindIndexBufferIndirectCommandNV {}
unsafe impl Sync for VkBindIndexBufferIndirectCommandNV {}

impl Default for VkBindIndexBufferIndirectCommandNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkBindVertexBufferIndirectCommandNV {
	pub bufferAddress                                : VkDeviceAddress,
	pub size                                         : u32,
	pub stride                                       : u32,
}

unsafe impl Send for VkBindVertexBufferIndirectCommandNV {}
unsafe impl Sync for VkBindVertexBufferIndirectCommandNV {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSetStateFlagsIndirectCommandNV {
	pub data                                         : u32,
}

unsafe impl Send for VkSetStateFlagsIndirectCommandNV {}
unsafe impl Sync for VkSetStateFlagsIndirectCommandNV {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkIndirectCommandsStreamNV {
	pub buffer                                       : VkBuffer,
	pub offset                                       : VkDeviceSize,
}

unsafe impl Send for VkIndirectCommandsStreamNV {}
unsafe impl Sync for VkIndirectCommandsStreamNV {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkIndirectCommandsLayoutTokenNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub tokenType                                    : VkIndirectCommandsTokenTypeNV,
	pub stream                                       : u32,
	pub offset                                       : u32,
	pub vertexBindingUnit                            : u32,
	pub vertexDynamicStride                          : VkBool32,
	pub pushconstantPipelineLayout                   : VkPipelineLayout,
	pub pushconstantShaderStageFlags                 : VkShaderStageFlags,
	pub pushconstantOffset                           : u32,
	pub pushconstantSize                             : u32,
	pub indirectStateFlags                           : VkIndirectStateFlagsNV,
	pub indexTypeCount                               : u32,
	pub pIndexTypes                                  : *const VkIndexType,
	pub pIndexTypeValues                             : *const u32,
}

unsafe impl Send for VkIndirectCommandsLayoutTokenNV<'_> {}
unsafe impl Sync for VkIndirectCommandsLayoutTokenNV<'_> {}

impl Default for VkIndirectCommandsLayoutTokenNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkIndirectCommandsLayoutCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkIndirectCommandsLayoutUsageFlagsNV,
	pub pipelineBindPoint                            : VkPipelineBindPoint,
	pub tokenCount                                   : u32,
	pub pTokens                                      : *const VkIndirectCommandsLayoutTokenNV<'a>,
	pub streamCount                                  : u32,
	pub pStreamStrides                               : *const u32,
}

unsafe impl Send for VkIndirectCommandsLayoutCreateInfoNV<'_> {}
unsafe impl Sync for VkIndirectCommandsLayoutCreateInfoNV<'_> {}

impl fmt::Debug for VkIndirectCommandsLayoutCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsLayoutCreateInfoNV").finish()
	}
}

impl Default for VkIndirectCommandsLayoutCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeneratedCommandsInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pipelineBindPoint                            : VkPipelineBindPoint,
	pub pipeline                                     : VkPipeline,
	pub indirectCommandsLayout                       : VkIndirectCommandsLayoutNV,
	pub streamCount                                  : u32,
	pub pStreams                                     : *const VkIndirectCommandsStreamNV,
	pub sequencesCount                               : u32,
	pub preprocessBuffer                             : VkBuffer,
	pub preprocessOffset                             : VkDeviceSize,
	pub preprocessSize                               : VkDeviceSize,
	pub sequencesCountBuffer                         : VkBuffer,
	pub sequencesCountOffset                         : VkDeviceSize,
	pub sequencesIndexBuffer                         : VkBuffer,
	pub sequencesIndexOffset                         : VkDeviceSize,
}

unsafe impl Send for VkGeneratedCommandsInfoNV<'_> {}
unsafe impl Sync for VkGeneratedCommandsInfoNV<'_> {}

impl fmt::Debug for VkGeneratedCommandsInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsInfoNV").finish()
	}
}

impl Default for VkGeneratedCommandsInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pipelineBindPoint                            : VkPipelineBindPoint,
	pub pipeline                                     : VkPipeline,
	pub indirectCommandsLayout                       : VkIndirectCommandsLayoutNV,
	pub maxSequencesCount                            : u32,
}

unsafe impl Send for VkGeneratedCommandsMemoryRequirementsInfoNV<'_> {}
unsafe impl Sync for VkGeneratedCommandsMemoryRequirementsInfoNV<'_> {}

impl Default for VkGeneratedCommandsMemoryRequirementsInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceFeatures2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub features                                     : VkPhysicalDeviceFeatures,
}

unsafe impl Send for VkPhysicalDeviceFeatures2<'_> {}
unsafe impl Sync for VkPhysicalDeviceFeatures2<'_> {}

impl fmt::Debug for VkPhysicalDeviceFeatures2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFeatures2").finish()
	}
}

impl Default for VkPhysicalDeviceFeatures2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceFeatures2KHR                 <'a> = VkPhysicalDeviceFeatures2<'a>;

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceProperties2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub properties                                   : VkPhysicalDeviceProperties,
}

unsafe impl Send for VkPhysicalDeviceProperties2<'_> {}
unsafe impl Sync for VkPhysicalDeviceProperties2<'_> {}

impl fmt::Debug for VkPhysicalDeviceProperties2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProperties2").finish()
	}
}

impl Default for VkPhysicalDeviceProperties2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceProperties2KHR               <'a> = VkPhysicalDeviceProperties2<'a>;

#[repr(C)]
#[derive()]
pub struct VkFormatProperties2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub formatProperties                             : VkFormatProperties,
}

unsafe impl Send for VkFormatProperties2<'_> {}
unsafe impl Sync for VkFormatProperties2<'_> {}

impl fmt::Debug for VkFormatProperties2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkFormatProperties2").finish()
	}
}

impl Default for VkFormatProperties2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkFormatProperties2KHR                       <'a> = VkFormatProperties2<'a>;

#[repr(C)]
#[derive()]
pub struct VkImageFormatProperties2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub imageFormatProperties                        : VkImageFormatProperties,
}

unsafe impl Send for VkImageFormatProperties2<'_> {}
unsafe impl Sync for VkImageFormatProperties2<'_> {}

impl fmt::Debug for VkImageFormatProperties2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageFormatProperties2").finish()
	}
}

impl Default for VkImageFormatProperties2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImageFormatProperties2KHR                  <'a> = VkImageFormatProperties2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceImageFormatInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub format                                       : VkFormat,
	pub r#type                                       : VkImageType,
	pub tiling                                       : VkImageTiling,
	pub usage                                        : VkImageUsageFlags,
	pub flags                                        : VkImageCreateFlags,
}

unsafe impl Send for VkPhysicalDeviceImageFormatInfo2<'_> {}
unsafe impl Sync for VkPhysicalDeviceImageFormatInfo2<'_> {}

impl Default for VkPhysicalDeviceImageFormatInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceImageFormatInfo2KHR          <'a> = VkPhysicalDeviceImageFormatInfo2<'a>;

#[repr(C)]
#[derive()]
pub struct VkQueueFamilyProperties2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub queueFamilyProperties                        : VkQueueFamilyProperties,
}

unsafe impl Send for VkQueueFamilyProperties2<'_> {}
unsafe impl Sync for VkQueueFamilyProperties2<'_> {}

impl fmt::Debug for VkQueueFamilyProperties2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyProperties2").finish()
	}
}

impl Default for VkQueueFamilyProperties2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkQueueFamilyProperties2KHR                  <'a> = VkQueueFamilyProperties2<'a>;

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceMemoryProperties2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryProperties                             : VkPhysicalDeviceMemoryProperties,
}

unsafe impl Send for VkPhysicalDeviceMemoryProperties2<'_> {}
unsafe impl Sync for VkPhysicalDeviceMemoryProperties2<'_> {}

impl fmt::Debug for VkPhysicalDeviceMemoryProperties2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryProperties2").finish()
	}
}

impl Default for VkPhysicalDeviceMemoryProperties2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceMemoryProperties2KHR         <'a> = VkPhysicalDeviceMemoryProperties2<'a>;

#[repr(C)]
#[derive()]
pub struct VkSparseImageFormatProperties2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub properties                                   : VkSparseImageFormatProperties,
}

unsafe impl Send for VkSparseImageFormatProperties2<'_> {}
unsafe impl Sync for VkSparseImageFormatProperties2<'_> {}

impl fmt::Debug for VkSparseImageFormatProperties2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageFormatProperties2").finish()
	}
}

impl Default for VkSparseImageFormatProperties2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSparseImageFormatProperties2KHR            <'a> = VkSparseImageFormatProperties2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub format                                       : VkFormat,
	pub r#type                                       : VkImageType,
	pub samples                                      : VkSampleCountFlagBits,
	pub usage                                        : VkImageUsageFlags,
	pub tiling                                       : VkImageTiling,
}

unsafe impl Send for VkPhysicalDeviceSparseImageFormatInfo2<'_> {}
unsafe impl Sync for VkPhysicalDeviceSparseImageFormatInfo2<'_> {}

impl Default for VkPhysicalDeviceSparseImageFormatInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceSparseImageFormatInfo2KHR    <'a> = VkPhysicalDeviceSparseImageFormatInfo2<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePushDescriptorPropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxPushDescriptors                           : u32,
}

unsafe impl Send for VkPhysicalDevicePushDescriptorPropertiesKHR<'_> {}
unsafe impl Sync for VkPhysicalDevicePushDescriptorPropertiesKHR<'_> {}

impl Default for VkPhysicalDevicePushDescriptorPropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkConformanceVersion {
	pub major                                        : u8,
	pub minor                                        : u8,
	pub subminor                                     : u8,
	pub patch                                        : u8,
}

unsafe impl Send for VkConformanceVersion {}
unsafe impl Sync for VkConformanceVersion {}


pub type VkConformanceVersionKHR                       = VkConformanceVersion;

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceDriverProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub driverID                                     : VkDriverId,
	pub driverName                                   : [u8;  VK_MAX_DRIVER_NAME_SIZE as usize],
	pub driverInfo                                   : [u8;  VK_MAX_DRIVER_INFO_SIZE as usize],
	pub conformanceVersion                           : VkConformanceVersion,
}

unsafe impl Send for VkPhysicalDeviceDriverProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceDriverProperties<'_> {}

impl fmt::Debug for VkPhysicalDeviceDriverProperties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDriverProperties").finish()
	}
}

impl Default for VkPhysicalDeviceDriverProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceDriverPropertiesKHR          <'a> = VkPhysicalDeviceDriverProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPresentRegionsKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Copy of VkPresentInfoKHR::swapchainCount
	pub swapchainCount                               : u32,
	/// The regions that have changed
	pub pRegions                                     : *const VkPresentRegionKHR,
}

unsafe impl Send for VkPresentRegionsKHR<'_> {}
unsafe impl Sync for VkPresentRegionsKHR<'_> {}

impl fmt::Debug for VkPresentRegionsKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPresentRegionsKHR").finish()
	}
}

impl Default for VkPresentRegionsKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPresentRegionKHR {
	/// Number of rectangles in pRectangles
	pub rectangleCount                               : u32,
	/// Array of rectangles that have changed in a swapchain's image(s)
	pub pRectangles                                  : *const VkRectLayerKHR,
}

unsafe impl Send for VkPresentRegionKHR {}
unsafe impl Sync for VkPresentRegionKHR {}

impl fmt::Debug for VkPresentRegionKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPresentRegionKHR").finish()
	}
}

impl Default for VkPresentRegionKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRectLayerKHR {
	/// upper-left corner of a rectangle that has not changed, in pixels of a presentation images
	pub offset                                       : VkOffset2D,
	/// Dimensions of a rectangle that has not changed, in pixels of a presentation images
	pub extent                                       : VkExtent2D,
	/// Layer of a swapchain's image(s), for stereoscopic-3D images
	pub layer                                        : u32,
}

unsafe impl Send for VkRectLayerKHR {}
unsafe impl Sync for VkRectLayerKHR {}

impl fmt::Debug for VkRectLayerKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRectLayerKHR").finish()
	}
}

impl Default for VkRectLayerKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVariablePointersFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub variablePointersStorageBuffer                : VkBool32,
	pub variablePointers                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceVariablePointersFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceVariablePointersFeatures<'_> {}

impl Default for VkPhysicalDeviceVariablePointersFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceVariablePointersFeaturesKHR  <'a> = VkPhysicalDeviceVariablePointersFeatures<'a>;

pub type VkPhysicalDeviceVariablePointerFeaturesKHR   <'a> = VkPhysicalDeviceVariablePointersFeatures<'a>;

pub type VkPhysicalDeviceVariablePointerFeatures      <'a> = VkPhysicalDeviceVariablePointersFeatures<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkExternalMemoryProperties {
	pub externalMemoryFeatures                       : VkExternalMemoryFeatureFlags,
	pub exportFromImportedHandleTypes                : VkExternalMemoryHandleTypeFlags,
	pub compatibleHandleTypes                        : VkExternalMemoryHandleTypeFlags,
}

unsafe impl Send for VkExternalMemoryProperties {}
unsafe impl Sync for VkExternalMemoryProperties {}


pub type VkExternalMemoryPropertiesKHR                 = VkExternalMemoryProperties;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceExternalImageFormatInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
}

unsafe impl Send for VkPhysicalDeviceExternalImageFormatInfo<'_> {}
unsafe impl Sync for VkPhysicalDeviceExternalImageFormatInfo<'_> {}

impl Default for VkPhysicalDeviceExternalImageFormatInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceExternalImageFormatInfoKHR   <'a> = VkPhysicalDeviceExternalImageFormatInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkExternalImageFormatProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub externalMemoryProperties                     : VkExternalMemoryProperties,
}

unsafe impl Send for VkExternalImageFormatProperties<'_> {}
unsafe impl Sync for VkExternalImageFormatProperties<'_> {}

impl fmt::Debug for VkExternalImageFormatProperties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExternalImageFormatProperties").finish()
	}
}

impl Default for VkExternalImageFormatProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExternalImageFormatPropertiesKHR           <'a> = VkExternalImageFormatProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceExternalBufferInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkBufferCreateFlags,
	pub usage                                        : VkBufferUsageFlags,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
}

unsafe impl Send for VkPhysicalDeviceExternalBufferInfo<'_> {}
unsafe impl Sync for VkPhysicalDeviceExternalBufferInfo<'_> {}

impl Default for VkPhysicalDeviceExternalBufferInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceExternalBufferInfoKHR        <'a> = VkPhysicalDeviceExternalBufferInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkExternalBufferProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub externalMemoryProperties                     : VkExternalMemoryProperties,
}

unsafe impl Send for VkExternalBufferProperties<'_> {}
unsafe impl Sync for VkExternalBufferProperties<'_> {}

impl fmt::Debug for VkExternalBufferProperties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExternalBufferProperties").finish()
	}
}

impl Default for VkExternalBufferProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExternalBufferPropertiesKHR                <'a> = VkExternalBufferProperties<'a>;

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceIDProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub deviceUUID                                   : [u8;  VK_UUID_SIZE as usize],
	pub driverUUID                                   : [u8;  VK_UUID_SIZE as usize],
	pub deviceLUID                                   : [u8;  VK_LUID_SIZE as usize],
	pub deviceNodeMask                               : u32,
	pub deviceLUIDValid                              : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceIDProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceIDProperties<'_> {}

impl fmt::Debug for VkPhysicalDeviceIDProperties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceIDProperties").finish()
	}
}

impl Default for VkPhysicalDeviceIDProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceIDPropertiesKHR              <'a> = VkPhysicalDeviceIDProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExternalMemoryImageCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalMemoryHandleTypeFlags,
}

unsafe impl Send for VkExternalMemoryImageCreateInfo<'_> {}
unsafe impl Sync for VkExternalMemoryImageCreateInfo<'_> {}

impl Default for VkExternalMemoryImageCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExternalMemoryImageCreateInfoKHR           <'a> = VkExternalMemoryImageCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExternalMemoryBufferCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalMemoryHandleTypeFlags,
}

unsafe impl Send for VkExternalMemoryBufferCreateInfo<'_> {}
unsafe impl Sync for VkExternalMemoryBufferCreateInfo<'_> {}

impl Default for VkExternalMemoryBufferCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExternalMemoryBufferCreateInfoKHR          <'a> = VkExternalMemoryBufferCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExportMemoryAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalMemoryHandleTypeFlags,
}

unsafe impl Send for VkExportMemoryAllocateInfo<'_> {}
unsafe impl Sync for VkExportMemoryAllocateInfo<'_> {}

impl Default for VkExportMemoryAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExportMemoryAllocateInfoKHR                <'a> = VkExportMemoryAllocateInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkImportMemoryWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
	pub handle                                       : HANDLE,
	pub name                                         : LPCWSTR,
}

unsafe impl Send for VkImportMemoryWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkImportMemoryWin32HandleInfoKHR<'_> {}

impl fmt::Debug for VkImportMemoryWin32HandleInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportMemoryWin32HandleInfoKHR").finish()
	}
}

impl Default for VkImportMemoryWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkExportMemoryWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pAttributes                                  : Option<&'a SECURITY_ATTRIBUTES>,
	pub dwAccess                                     : DWORD,
	pub name                                         : LPCWSTR,
}

unsafe impl Send for VkExportMemoryWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkExportMemoryWin32HandleInfoKHR<'_> {}

impl fmt::Debug for VkExportMemoryWin32HandleInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExportMemoryWin32HandleInfoKHR").finish()
	}
}

impl Default for VkExportMemoryWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkImportMemoryZirconHandleInfoFUCHSIA<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
	pub handle                                       : zx_handle_t,
}

unsafe impl Send for VkImportMemoryZirconHandleInfoFUCHSIA<'_> {}
unsafe impl Sync for VkImportMemoryZirconHandleInfoFUCHSIA<'_> {}

impl fmt::Debug for VkImportMemoryZirconHandleInfoFUCHSIA<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportMemoryZirconHandleInfoFUCHSIA").finish()
	}
}

impl Default for VkImportMemoryZirconHandleInfoFUCHSIA<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkMemoryZirconHandlePropertiesFUCHSIA<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub memoryTypeBits                               : u32,
}

unsafe impl Send for VkMemoryZirconHandlePropertiesFUCHSIA<'_> {}
unsafe impl Sync for VkMemoryZirconHandlePropertiesFUCHSIA<'_> {}

impl Default for VkMemoryZirconHandlePropertiesFUCHSIA<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryGetZirconHandleInfoFUCHSIA<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub memory                                       : VkDeviceMemory,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
}

unsafe impl Send for VkMemoryGetZirconHandleInfoFUCHSIA<'_> {}
unsafe impl Sync for VkMemoryGetZirconHandleInfoFUCHSIA<'_> {}

impl Default for VkMemoryGetZirconHandleInfoFUCHSIA<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkMemoryWin32HandlePropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryTypeBits                               : u32,
}

unsafe impl Send for VkMemoryWin32HandlePropertiesKHR<'_> {}
unsafe impl Sync for VkMemoryWin32HandlePropertiesKHR<'_> {}

impl Default for VkMemoryWin32HandlePropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryGetWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub memory                                       : VkDeviceMemory,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
}

unsafe impl Send for VkMemoryGetWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkMemoryGetWin32HandleInfoKHR<'_> {}

impl Default for VkMemoryGetWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImportMemoryFdInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
	pub fd                                           : i32,
}

unsafe impl Send for VkImportMemoryFdInfoKHR<'_> {}
unsafe impl Sync for VkImportMemoryFdInfoKHR<'_> {}

impl Default for VkImportMemoryFdInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkMemoryFdPropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryTypeBits                               : u32,
}

unsafe impl Send for VkMemoryFdPropertiesKHR<'_> {}
unsafe impl Sync for VkMemoryFdPropertiesKHR<'_> {}

impl Default for VkMemoryFdPropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryGetFdInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub memory                                       : VkDeviceMemory,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
}

unsafe impl Send for VkMemoryGetFdInfoKHR<'_> {}
unsafe impl Sync for VkMemoryGetFdInfoKHR<'_> {}

impl Default for VkMemoryGetFdInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWin32KeyedMutexAcquireReleaseInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub acquireCount                                 : u32,
	pub pAcquireSyncs                                : *const VkDeviceMemory,
	pub pAcquireKeys                                 : *const u64,
	pub pAcquireTimeouts                             : *const u32,
	pub releaseCount                                 : u32,
	pub pReleaseSyncs                                : *const VkDeviceMemory,
	pub pReleaseKeys                                 : *const u64,
}

unsafe impl Send for VkWin32KeyedMutexAcquireReleaseInfoKHR<'_> {}
unsafe impl Sync for VkWin32KeyedMutexAcquireReleaseInfoKHR<'_> {}

impl Default for VkWin32KeyedMutexAcquireReleaseInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
}

unsafe impl Send for VkPhysicalDeviceExternalSemaphoreInfo<'_> {}
unsafe impl Sync for VkPhysicalDeviceExternalSemaphoreInfo<'_> {}

impl Default for VkPhysicalDeviceExternalSemaphoreInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceExternalSemaphoreInfoKHR     <'a> = VkPhysicalDeviceExternalSemaphoreInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkExternalSemaphoreProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub exportFromImportedHandleTypes                : VkExternalSemaphoreHandleTypeFlags,
	pub compatibleHandleTypes                        : VkExternalSemaphoreHandleTypeFlags,
	pub externalSemaphoreFeatures                    : VkExternalSemaphoreFeatureFlags,
}

unsafe impl Send for VkExternalSemaphoreProperties<'_> {}
unsafe impl Sync for VkExternalSemaphoreProperties<'_> {}

impl Default for VkExternalSemaphoreProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExternalSemaphorePropertiesKHR             <'a> = VkExternalSemaphoreProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExportSemaphoreCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalSemaphoreHandleTypeFlags,
}

unsafe impl Send for VkExportSemaphoreCreateInfo<'_> {}
unsafe impl Sync for VkExportSemaphoreCreateInfo<'_> {}

impl Default for VkExportSemaphoreCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExportSemaphoreCreateInfoKHR               <'a> = VkExportSemaphoreCreateInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkImportSemaphoreWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub flags                                        : VkSemaphoreImportFlags,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
	pub handle                                       : HANDLE,
	pub name                                         : LPCWSTR,
}

unsafe impl Send for VkImportSemaphoreWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkImportSemaphoreWin32HandleInfoKHR<'_> {}

impl fmt::Debug for VkImportSemaphoreWin32HandleInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportSemaphoreWin32HandleInfoKHR").finish()
	}
}

impl Default for VkImportSemaphoreWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkExportSemaphoreWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pAttributes                                  : Option<&'a SECURITY_ATTRIBUTES>,
	pub dwAccess                                     : DWORD,
	pub name                                         : LPCWSTR,
}

unsafe impl Send for VkExportSemaphoreWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkExportSemaphoreWin32HandleInfoKHR<'_> {}

impl fmt::Debug for VkExportSemaphoreWin32HandleInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExportSemaphoreWin32HandleInfoKHR").finish()
	}
}

impl Default for VkExportSemaphoreWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkD3D12FenceSubmitInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub waitSemaphoreValuesCount                     : u32,
	pub pWaitSemaphoreValues                         : *const u64,
	pub signalSemaphoreValuesCount                   : u32,
	pub pSignalSemaphoreValues                       : *const u64,
}

unsafe impl Send for VkD3D12FenceSubmitInfoKHR<'_> {}
unsafe impl Sync for VkD3D12FenceSubmitInfoKHR<'_> {}

impl Default for VkD3D12FenceSubmitInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreGetWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
}

unsafe impl Send for VkSemaphoreGetWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkSemaphoreGetWin32HandleInfoKHR<'_> {}

impl Default for VkSemaphoreGetWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImportSemaphoreFdInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub flags                                        : VkSemaphoreImportFlags,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
	pub fd                                           : i32,
}

unsafe impl Send for VkImportSemaphoreFdInfoKHR<'_> {}
unsafe impl Sync for VkImportSemaphoreFdInfoKHR<'_> {}

impl Default for VkImportSemaphoreFdInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreGetFdInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
}

unsafe impl Send for VkSemaphoreGetFdInfoKHR<'_> {}
unsafe impl Sync for VkSemaphoreGetFdInfoKHR<'_> {}

impl Default for VkSemaphoreGetFdInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub flags                                        : VkSemaphoreImportFlags,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
	pub zirconHandle                                 : zx_handle_t,
}

unsafe impl Send for VkImportSemaphoreZirconHandleInfoFUCHSIA<'_> {}
unsafe impl Sync for VkImportSemaphoreZirconHandleInfoFUCHSIA<'_> {}

impl fmt::Debug for VkImportSemaphoreZirconHandleInfoFUCHSIA<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportSemaphoreZirconHandleInfoFUCHSIA").finish()
	}
}

impl Default for VkImportSemaphoreZirconHandleInfoFUCHSIA<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreGetZirconHandleInfoFUCHSIA<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub handleType                                   : VkExternalSemaphoreHandleTypeFlagBits,
}

unsafe impl Send for VkSemaphoreGetZirconHandleInfoFUCHSIA<'_> {}
unsafe impl Sync for VkSemaphoreGetZirconHandleInfoFUCHSIA<'_> {}

impl Default for VkSemaphoreGetZirconHandleInfoFUCHSIA<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceExternalFenceInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalFenceHandleTypeFlagBits,
}

unsafe impl Send for VkPhysicalDeviceExternalFenceInfo<'_> {}
unsafe impl Sync for VkPhysicalDeviceExternalFenceInfo<'_> {}

impl Default for VkPhysicalDeviceExternalFenceInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceExternalFenceInfoKHR         <'a> = VkPhysicalDeviceExternalFenceInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkExternalFenceProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub exportFromImportedHandleTypes                : VkExternalFenceHandleTypeFlags,
	pub compatibleHandleTypes                        : VkExternalFenceHandleTypeFlags,
	pub externalFenceFeatures                        : VkExternalFenceFeatureFlags,
}

unsafe impl Send for VkExternalFenceProperties<'_> {}
unsafe impl Sync for VkExternalFenceProperties<'_> {}

impl Default for VkExternalFenceProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExternalFencePropertiesKHR                 <'a> = VkExternalFenceProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExportFenceCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleTypes                                  : VkExternalFenceHandleTypeFlags,
}

unsafe impl Send for VkExportFenceCreateInfo<'_> {}
unsafe impl Sync for VkExportFenceCreateInfo<'_> {}

impl Default for VkExportFenceCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkExportFenceCreateInfoKHR                   <'a> = VkExportFenceCreateInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkImportFenceWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub fence                                        : VkFence,
	pub flags                                        : VkFenceImportFlags,
	pub handleType                                   : VkExternalFenceHandleTypeFlagBits,
	pub handle                                       : HANDLE,
	pub name                                         : LPCWSTR,
}

unsafe impl Send for VkImportFenceWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkImportFenceWin32HandleInfoKHR<'_> {}

impl fmt::Debug for VkImportFenceWin32HandleInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportFenceWin32HandleInfoKHR").finish()
	}
}

impl Default for VkImportFenceWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkExportFenceWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pAttributes                                  : Option<&'a SECURITY_ATTRIBUTES>,
	pub dwAccess                                     : DWORD,
	pub name                                         : LPCWSTR,
}

unsafe impl Send for VkExportFenceWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkExportFenceWin32HandleInfoKHR<'_> {}

impl fmt::Debug for VkExportFenceWin32HandleInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkExportFenceWin32HandleInfoKHR").finish()
	}
}

impl Default for VkExportFenceWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFenceGetWin32HandleInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub fence                                        : VkFence,
	pub handleType                                   : VkExternalFenceHandleTypeFlagBits,
}

unsafe impl Send for VkFenceGetWin32HandleInfoKHR<'_> {}
unsafe impl Sync for VkFenceGetWin32HandleInfoKHR<'_> {}

impl Default for VkFenceGetWin32HandleInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImportFenceFdInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub fence                                        : VkFence,
	pub flags                                        : VkFenceImportFlags,
	pub handleType                                   : VkExternalFenceHandleTypeFlagBits,
	pub fd                                           : i32,
}

unsafe impl Send for VkImportFenceFdInfoKHR<'_> {}
unsafe impl Sync for VkImportFenceFdInfoKHR<'_> {}

impl Default for VkImportFenceFdInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFenceGetFdInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub fence                                        : VkFence,
	pub handleType                                   : VkExternalFenceHandleTypeFlagBits,
}

unsafe impl Send for VkFenceGetFdInfoKHR<'_> {}
unsafe impl Sync for VkFenceGetFdInfoKHR<'_> {}

impl Default for VkFenceGetFdInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMultiviewFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// Multiple views in a renderpass
	pub multiview                                    : VkBool32,
	/// Multiple views in a renderpass w/ geometry shader
	pub multiviewGeometryShader                      : VkBool32,
	/// Multiple views in a renderpass w/ tessellation shader
	pub multiviewTessellationShader                  : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceMultiviewFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceMultiviewFeatures<'_> {}

impl Default for VkPhysicalDeviceMultiviewFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceMultiviewFeaturesKHR         <'a> = VkPhysicalDeviceMultiviewFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMultiviewProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// max number of views in a subpass
	pub maxMultiviewViewCount                        : u32,
	/// max instance index for a draw in a multiview subpass
	pub maxMultiviewInstanceIndex                    : u32,
}

unsafe impl Send for VkPhysicalDeviceMultiviewProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceMultiviewProperties<'_> {}

impl Default for VkPhysicalDeviceMultiviewProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceMultiviewPropertiesKHR       <'a> = VkPhysicalDeviceMultiviewProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRenderPassMultiviewCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub subpassCount                                 : u32,
	pub pViewMasks                                   : *const u32,
	pub dependencyCount                              : u32,
	pub pViewOffsets                                 : *const i32,
	pub correlationMaskCount                         : u32,
	pub pCorrelationMasks                            : *const u32,
}

unsafe impl Send for VkRenderPassMultiviewCreateInfo<'_> {}
unsafe impl Sync for VkRenderPassMultiviewCreateInfo<'_> {}

impl Default for VkRenderPassMultiviewCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkRenderPassMultiviewCreateInfoKHR           <'a> = VkRenderPassMultiviewCreateInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkSurfaceCapabilities2EXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// Supported minimum number of images for the surface
	pub minImageCount                                : u32,
	/// Supported maximum number of images for the surface, 0 for unlimited
	pub maxImageCount                                : u32,
	/// Current image width and height for the surface, (0, 0) if undefined
	pub currentExtent                                : VkExtent2D,
	/// Supported minimum image width and height for the surface
	pub minImageExtent                               : VkExtent2D,
	/// Supported maximum image width and height for the surface
	pub maxImageExtent                               : VkExtent2D,
	/// Supported maximum number of image layers for the surface
	pub maxImageArrayLayers                          : u32,
	/// 1 or more bits representing the transforms supported
	pub supportedTransforms                          : VkSurfaceTransformFlagsKHR,
	/// The surface's current transform relative to the device's natural orientation
	pub currentTransform                             : VkSurfaceTransformFlagBitsKHR,
	/// 1 or more bits representing the alpha compositing modes supported
	pub supportedCompositeAlpha                      : VkCompositeAlphaFlagsKHR,
	/// Supported image usage flags for the surface
	pub supportedUsageFlags                          : VkImageUsageFlags,
	pub supportedSurfaceCounters                     : VkSurfaceCounterFlagsEXT,
}

unsafe impl Send for VkSurfaceCapabilities2EXT<'_> {}
unsafe impl Sync for VkSurfaceCapabilities2EXT<'_> {}

impl fmt::Debug for VkSurfaceCapabilities2EXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilities2EXT").finish()
	}
}

impl Default for VkSurfaceCapabilities2EXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayPowerInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub powerState                                   : VkDisplayPowerStateEXT,
}

unsafe impl Send for VkDisplayPowerInfoEXT<'_> {}
unsafe impl Sync for VkDisplayPowerInfoEXT<'_> {}

impl Default for VkDisplayPowerInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceEventInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub deviceEvent                                  : VkDeviceEventTypeEXT,
}

unsafe impl Send for VkDeviceEventInfoEXT<'_> {}
unsafe impl Sync for VkDeviceEventInfoEXT<'_> {}

impl Default for VkDeviceEventInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayEventInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub displayEvent                                 : VkDisplayEventTypeEXT,
}

unsafe impl Send for VkDisplayEventInfoEXT<'_> {}
unsafe impl Sync for VkDisplayEventInfoEXT<'_> {}

impl Default for VkDisplayEventInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSwapchainCounterCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub surfaceCounters                              : VkSurfaceCounterFlagsEXT,
}

unsafe impl Send for VkSwapchainCounterCreateInfoEXT<'_> {}
unsafe impl Sync for VkSwapchainCounterCreateInfoEXT<'_> {}

impl Default for VkSwapchainCounterCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceGroupProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub physicalDeviceCount                          : u32,
	pub physicalDevices                              : [VkPhysicalDevice;  VK_MAX_DEVICE_GROUP_SIZE as usize],
	pub subsetAllocation                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceGroupProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceGroupProperties<'_> {}

impl fmt::Debug for VkPhysicalDeviceGroupProperties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceGroupProperties").finish()
	}
}

impl Default for VkPhysicalDeviceGroupProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceGroupPropertiesKHR           <'a> = VkPhysicalDeviceGroupProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryAllocateFlagsInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkMemoryAllocateFlags,
	pub deviceMask                                   : u32,
}

unsafe impl Send for VkMemoryAllocateFlagsInfo<'_> {}
unsafe impl Sync for VkMemoryAllocateFlagsInfo<'_> {}

impl Default for VkMemoryAllocateFlagsInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkMemoryAllocateFlagsInfoKHR                 <'a> = VkMemoryAllocateFlagsInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindBufferMemoryInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub buffer                                       : VkBuffer,
	pub memory                                       : VkDeviceMemory,
	pub memoryOffset                                 : VkDeviceSize,
}

unsafe impl Send for VkBindBufferMemoryInfo<'_> {}
unsafe impl Sync for VkBindBufferMemoryInfo<'_> {}

impl Default for VkBindBufferMemoryInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBindBufferMemoryInfoKHR                    <'a> = VkBindBufferMemoryInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindBufferMemoryDeviceGroupInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub deviceIndexCount                             : u32,
	pub pDeviceIndices                               : *const u32,
}

unsafe impl Send for VkBindBufferMemoryDeviceGroupInfo<'_> {}
unsafe impl Sync for VkBindBufferMemoryDeviceGroupInfo<'_> {}

impl Default for VkBindBufferMemoryDeviceGroupInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBindBufferMemoryDeviceGroupInfoKHR         <'a> = VkBindBufferMemoryDeviceGroupInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindImageMemoryInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub image                                        : VkImage,
	pub memory                                       : VkDeviceMemory,
	pub memoryOffset                                 : VkDeviceSize,
}

unsafe impl Send for VkBindImageMemoryInfo<'_> {}
unsafe impl Sync for VkBindImageMemoryInfo<'_> {}

impl Default for VkBindImageMemoryInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBindImageMemoryInfoKHR                     <'a> = VkBindImageMemoryInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBindImageMemoryDeviceGroupInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub deviceIndexCount                             : u32,
	pub pDeviceIndices                               : *const u32,
	pub splitInstanceBindRegionCount                 : u32,
	pub pSplitInstanceBindRegions                    : *const VkRect2D,
}

unsafe impl Send for VkBindImageMemoryDeviceGroupInfo<'_> {}
unsafe impl Sync for VkBindImageMemoryDeviceGroupInfo<'_> {}

impl fmt::Debug for VkBindImageMemoryDeviceGroupInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBindImageMemoryDeviceGroupInfo").finish()
	}
}

impl Default for VkBindImageMemoryDeviceGroupInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBindImageMemoryDeviceGroupInfoKHR          <'a> = VkBindImageMemoryDeviceGroupInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDeviceGroupRenderPassBeginInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub deviceMask                                   : u32,
	pub deviceRenderAreaCount                        : u32,
	pub pDeviceRenderAreas                           : *const VkRect2D,
}

unsafe impl Send for VkDeviceGroupRenderPassBeginInfo<'_> {}
unsafe impl Sync for VkDeviceGroupRenderPassBeginInfo<'_> {}

impl fmt::Debug for VkDeviceGroupRenderPassBeginInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupRenderPassBeginInfo").finish()
	}
}

impl Default for VkDeviceGroupRenderPassBeginInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDeviceGroupRenderPassBeginInfoKHR          <'a> = VkDeviceGroupRenderPassBeginInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceGroupCommandBufferBeginInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub deviceMask                                   : u32,
}

unsafe impl Send for VkDeviceGroupCommandBufferBeginInfo<'_> {}
unsafe impl Sync for VkDeviceGroupCommandBufferBeginInfo<'_> {}

impl Default for VkDeviceGroupCommandBufferBeginInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDeviceGroupCommandBufferBeginInfoKHR       <'a> = VkDeviceGroupCommandBufferBeginInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceGroupSubmitInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub waitSemaphoreCount                           : u32,
	pub pWaitSemaphoreDeviceIndices                  : *const u32,
	pub commandBufferCount                           : u32,
	pub pCommandBufferDeviceMasks                    : *const u32,
	pub signalSemaphoreCount                         : u32,
	pub pSignalSemaphoreDeviceIndices                : *const u32,
}

unsafe impl Send for VkDeviceGroupSubmitInfo<'_> {}
unsafe impl Sync for VkDeviceGroupSubmitInfo<'_> {}

impl Default for VkDeviceGroupSubmitInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDeviceGroupSubmitInfoKHR                   <'a> = VkDeviceGroupSubmitInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceGroupBindSparseInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub resourceDeviceIndex                          : u32,
	pub memoryDeviceIndex                            : u32,
}

unsafe impl Send for VkDeviceGroupBindSparseInfo<'_> {}
unsafe impl Sync for VkDeviceGroupBindSparseInfo<'_> {}

impl Default for VkDeviceGroupBindSparseInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDeviceGroupBindSparseInfoKHR               <'a> = VkDeviceGroupBindSparseInfo<'a>;

#[repr(C)]
#[derive()]
pub struct VkDeviceGroupPresentCapabilitiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub presentMask                                  : [u32;  VK_MAX_DEVICE_GROUP_SIZE as usize],
	pub modes                                        : VkDeviceGroupPresentModeFlagsKHR,
}

unsafe impl Send for VkDeviceGroupPresentCapabilitiesKHR<'_> {}
unsafe impl Sync for VkDeviceGroupPresentCapabilitiesKHR<'_> {}

impl fmt::Debug for VkDeviceGroupPresentCapabilitiesKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupPresentCapabilitiesKHR").finish()
	}
}

impl Default for VkDeviceGroupPresentCapabilitiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageSwapchainCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub swapchain                                    : VkSwapchainKHR,
}

unsafe impl Send for VkImageSwapchainCreateInfoKHR<'_> {}
unsafe impl Sync for VkImageSwapchainCreateInfoKHR<'_> {}

impl Default for VkImageSwapchainCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindImageMemorySwapchainInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub swapchain                                    : VkSwapchainKHR,
	pub imageIndex                                   : u32,
}

unsafe impl Send for VkBindImageMemorySwapchainInfoKHR<'_> {}
unsafe impl Sync for VkBindImageMemorySwapchainInfoKHR<'_> {}

impl Default for VkBindImageMemorySwapchainInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAcquireNextImageInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub swapchain                                    : VkSwapchainKHR,
	pub timeout                                      : u64,
	pub semaphore                                    : VkSemaphore,
	pub fence                                        : VkFence,
	pub deviceMask                                   : u32,
}

unsafe impl Send for VkAcquireNextImageInfoKHR<'_> {}
unsafe impl Sync for VkAcquireNextImageInfoKHR<'_> {}

impl Default for VkAcquireNextImageInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceGroupPresentInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub swapchainCount                               : u32,
	pub pDeviceMasks                                 : *const u32,
	pub mode                                         : VkDeviceGroupPresentModeFlagBitsKHR,
}

unsafe impl Send for VkDeviceGroupPresentInfoKHR<'_> {}
unsafe impl Sync for VkDeviceGroupPresentInfoKHR<'_> {}

impl Default for VkDeviceGroupPresentInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceGroupDeviceCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub physicalDeviceCount                          : u32,
	pub pPhysicalDevices                             : *const VkPhysicalDevice,
}

unsafe impl Send for VkDeviceGroupDeviceCreateInfo<'_> {}
unsafe impl Sync for VkDeviceGroupDeviceCreateInfo<'_> {}

impl Default for VkDeviceGroupDeviceCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDeviceGroupDeviceCreateInfoKHR             <'a> = VkDeviceGroupDeviceCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceGroupSwapchainCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub modes                                        : VkDeviceGroupPresentModeFlagsKHR,
}

unsafe impl Send for VkDeviceGroupSwapchainCreateInfoKHR<'_> {}
unsafe impl Sync for VkDeviceGroupSwapchainCreateInfoKHR<'_> {}

impl Default for VkDeviceGroupSwapchainCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorUpdateTemplateEntry {
	/// Binding within the destination descriptor set to write
	pub dstBinding                                   : u32,
	/// Array element within the destination binding to write
	pub dstArrayElement                              : u32,
	/// Number of descriptors to write
	pub descriptorCount                              : u32,
	/// Descriptor type to write
	pub descriptorType                               : VkDescriptorType,
	/// Offset into pData where the descriptors to update are stored
	pub offset                                       : usize,
	/// Stride between two descriptors in pData when writing more than one descriptor
	pub stride                                       : usize,
}

unsafe impl Send for VkDescriptorUpdateTemplateEntry {}
unsafe impl Sync for VkDescriptorUpdateTemplateEntry {}

impl Default for VkDescriptorUpdateTemplateEntry {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDescriptorUpdateTemplateEntryKHR            = VkDescriptorUpdateTemplateEntry;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorUpdateTemplateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDescriptorUpdateTemplateCreateFlags,
	/// Number of descriptor update entries to use for the update template
	pub descriptorUpdateEntryCount                   : u32,
	/// Descriptor update entries for the template
	pub pDescriptorUpdateEntries                     : *const VkDescriptorUpdateTemplateEntry,
	pub templateType                                 : VkDescriptorUpdateTemplateType,
	pub descriptorSetLayout                          : VkDescriptorSetLayout,
	pub pipelineBindPoint                            : VkPipelineBindPoint,
	/// If used for push descriptors, this is the only allowed layout
	pub pipelineLayout                               : VkPipelineLayout,
	pub set                                          : u32,
}

unsafe impl Send for VkDescriptorUpdateTemplateCreateInfo<'_> {}
unsafe impl Sync for VkDescriptorUpdateTemplateCreateInfo<'_> {}

impl fmt::Debug for VkDescriptorUpdateTemplateCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorUpdateTemplateCreateInfo").finish()
	}
}

impl Default for VkDescriptorUpdateTemplateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDescriptorUpdateTemplateCreateInfoKHR      <'a> = VkDescriptorUpdateTemplateCreateInfo<'a>;

/// Chromaticity coordinate
#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkXYColorEXT {
	pub x                                            : f32,
	pub y                                            : f32,
}

unsafe impl Send for VkXYColorEXT {}
unsafe impl Sync for VkXYColorEXT {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkHdrMetadataEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Display primary's Red
	pub displayPrimaryRed                            : VkXYColorEXT,
	/// Display primary's Green
	pub displayPrimaryGreen                          : VkXYColorEXT,
	/// Display primary's Blue
	pub displayPrimaryBlue                           : VkXYColorEXT,
	/// Display primary's Blue
	pub whitePoint                                   : VkXYColorEXT,
	/// Display maximum luminance
	pub maxLuminance                                 : f32,
	/// Display minimum luminance
	pub minLuminance                                 : f32,
	/// Content maximum luminance
	pub maxContentLightLevel                         : f32,
	pub maxFrameAverageLightLevel                    : f32,
}

unsafe impl Send for VkHdrMetadataEXT<'_> {}
unsafe impl Sync for VkHdrMetadataEXT<'_> {}

impl fmt::Debug for VkHdrMetadataEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkHdrMetadataEXT").finish()
	}
}

impl Default for VkHdrMetadataEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkDisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub localDimmingSupport                          : VkBool32,
}

unsafe impl Send for VkDisplayNativeHdrSurfaceCapabilitiesAMD<'_> {}
unsafe impl Sync for VkDisplayNativeHdrSurfaceCapabilitiesAMD<'_> {}

impl Default for VkDisplayNativeHdrSurfaceCapabilitiesAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSwapchainDisplayNativeHdrCreateInfoAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub localDimmingEnable                           : VkBool32,
}

unsafe impl Send for VkSwapchainDisplayNativeHdrCreateInfoAMD<'_> {}
unsafe impl Sync for VkSwapchainDisplayNativeHdrCreateInfoAMD<'_> {}

impl Default for VkSwapchainDisplayNativeHdrCreateInfoAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkRefreshCycleDurationGOOGLE {
	/// Number of nanoseconds from the start of one refresh cycle to the next
	pub refreshDuration                              : u64,
}

unsafe impl Send for VkRefreshCycleDurationGOOGLE {}
unsafe impl Sync for VkRefreshCycleDurationGOOGLE {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkPastPresentationTimingGOOGLE {
	/// Application-provided identifier, previously given to vkQueuePresentKHR
	pub presentID                                    : u32,
	/// Earliest time an image should have been presented, previously given to vkQueuePresentKHR
	pub desiredPresentTime                           : u64,
	/// Time the image was actually displayed
	pub actualPresentTime                            : u64,
	/// Earliest time the image could have been displayed
	pub earliestPresentTime                          : u64,
	/// How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
	pub presentMargin                                : u64,
}

unsafe impl Send for VkPastPresentationTimingGOOGLE {}
unsafe impl Sync for VkPastPresentationTimingGOOGLE {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPresentTimesInfoGOOGLE<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Copy of VkPresentInfoKHR::swapchainCount
	pub swapchainCount                               : u32,
	/// The earliest times to present images
	pub pTimes                                       : *const VkPresentTimeGOOGLE,
}

unsafe impl Send for VkPresentTimesInfoGOOGLE<'_> {}
unsafe impl Sync for VkPresentTimesInfoGOOGLE<'_> {}

impl fmt::Debug for VkPresentTimesInfoGOOGLE<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPresentTimesInfoGOOGLE").finish()
	}
}

impl Default for VkPresentTimesInfoGOOGLE<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkPresentTimeGOOGLE {
	/// Application-provided identifier
	pub presentID                                    : u32,
	/// Earliest time an image should be presented
	pub desiredPresentTime                           : u64,
}

unsafe impl Send for VkPresentTimeGOOGLE {}
unsafe impl Sync for VkPresentTimeGOOGLE {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkIOSSurfaceCreateInfoMVK<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkIOSSurfaceCreateFlagsMVK,
	pub pView                                        : VkAnyRef<'a>,
}

unsafe impl Send for VkIOSSurfaceCreateInfoMVK<'_> {}
unsafe impl Sync for VkIOSSurfaceCreateInfoMVK<'_> {}

impl Default for VkIOSSurfaceCreateInfoMVK<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMacOSSurfaceCreateInfoMVK<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkMacOSSurfaceCreateFlagsMVK,
	pub pView                                        : VkAnyRef<'a>,
}

unsafe impl Send for VkMacOSSurfaceCreateInfoMVK<'_> {}
unsafe impl Sync for VkMacOSSurfaceCreateInfoMVK<'_> {}

impl Default for VkMacOSSurfaceCreateInfoMVK<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMetalSurfaceCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkMetalSurfaceCreateFlagsEXT,
	pub pLayer                                       : &'a CAMetalLayer,
}

unsafe impl Send for VkMetalSurfaceCreateInfoEXT<'_> {}
unsafe impl Sync for VkMetalSurfaceCreateInfoEXT<'_> {}

impl fmt::Debug for VkMetalSurfaceCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkMetalSurfaceCreateInfoEXT").finish()
	}
}

impl Default for VkMetalSurfaceCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkViewportWScalingNV {
	pub xcoeff                                       : f32,
	pub ycoeff                                       : f32,
}

unsafe impl Send for VkViewportWScalingNV {}
unsafe impl Sync for VkViewportWScalingNV {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub viewportWScalingEnable                       : VkBool32,
	pub viewportCount                                : u32,
	pub pViewportWScalings                           : *const VkViewportWScalingNV,
}

unsafe impl Send for VkPipelineViewportWScalingStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineViewportWScalingStateCreateInfoNV<'_> {}

impl fmt::Debug for VkPipelineViewportWScalingStateCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportWScalingStateCreateInfoNV").finish()
	}
}

impl Default for VkPipelineViewportWScalingStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkViewportSwizzleNV {
	pub x                                            : VkViewportCoordinateSwizzleNV,
	pub y                                            : VkViewportCoordinateSwizzleNV,
	pub z                                            : VkViewportCoordinateSwizzleNV,
	pub w                                            : VkViewportCoordinateSwizzleNV,
}

unsafe impl Send for VkViewportSwizzleNV {}
unsafe impl Sync for VkViewportSwizzleNV {}

impl Default for VkViewportSwizzleNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineViewportSwizzleStateCreateFlagsNV,
	pub viewportCount                                : u32,
	pub pViewportSwizzles                            : *const VkViewportSwizzleNV,
}

unsafe impl Send for VkPipelineViewportSwizzleStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineViewportSwizzleStateCreateInfoNV<'_> {}

impl fmt::Debug for VkPipelineViewportSwizzleStateCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportSwizzleStateCreateInfoNV").finish()
	}
}

impl Default for VkPipelineViewportSwizzleStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// max number of active discard rectangles
	pub maxDiscardRectangles                         : u32,
}

unsafe impl Send for VkPhysicalDeviceDiscardRectanglePropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceDiscardRectanglePropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceDiscardRectanglePropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineDiscardRectangleStateCreateFlagsEXT,
	pub discardRectangleMode                         : VkDiscardRectangleModeEXT,
	pub discardRectangleCount                        : u32,
	pub pDiscardRectangles                           : *const VkRect2D,
}

unsafe impl Send for VkPipelineDiscardRectangleStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineDiscardRectangleStateCreateInfoEXT<'_> {}

impl fmt::Debug for VkPipelineDiscardRectangleStateCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineDiscardRectangleStateCreateInfoEXT").finish()
	}
}

impl Default for VkPipelineDiscardRectangleStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub perViewPositionAllComponents                 : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'_> {}
unsafe impl Sync for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'_> {}

impl Default for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkInputAttachmentAspectReference {
	pub subpass                                      : u32,
	pub inputAttachmentIndex                         : u32,
	pub aspectMask                                   : VkImageAspectFlags,
}

unsafe impl Send for VkInputAttachmentAspectReference {}
unsafe impl Sync for VkInputAttachmentAspectReference {}


pub type VkInputAttachmentAspectReferenceKHR           = VkInputAttachmentAspectReference;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassInputAttachmentAspectCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub aspectReferenceCount                         : u32,
	pub pAspectReferences                            : *const VkInputAttachmentAspectReference,
}

unsafe impl Send for VkRenderPassInputAttachmentAspectCreateInfo<'_> {}
unsafe impl Sync for VkRenderPassInputAttachmentAspectCreateInfo<'_> {}

impl fmt::Debug for VkRenderPassInputAttachmentAspectCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassInputAttachmentAspectCreateInfo").finish()
	}
}

impl Default for VkRenderPassInputAttachmentAspectCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkRenderPassInputAttachmentAspectCreateInfoKHR<'a> = VkRenderPassInputAttachmentAspectCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub surface                                      : VkSurfaceKHR,
}

unsafe impl Send for VkPhysicalDeviceSurfaceInfo2KHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceSurfaceInfo2KHR<'_> {}

impl Default for VkPhysicalDeviceSurfaceInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkSurfaceCapabilities2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub surfaceCapabilities                          : VkSurfaceCapabilitiesKHR,
}

unsafe impl Send for VkSurfaceCapabilities2KHR<'_> {}
unsafe impl Sync for VkSurfaceCapabilities2KHR<'_> {}

impl fmt::Debug for VkSurfaceCapabilities2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilities2KHR").finish()
	}
}

impl Default for VkSurfaceCapabilities2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkSurfaceFormat2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub surfaceFormat                                : VkSurfaceFormatKHR,
}

unsafe impl Send for VkSurfaceFormat2KHR<'_> {}
unsafe impl Sync for VkSurfaceFormat2KHR<'_> {}

impl fmt::Debug for VkSurfaceFormat2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceFormat2KHR").finish()
	}
}

impl Default for VkSurfaceFormat2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDisplayProperties2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub displayProperties                            : VkDisplayPropertiesKHR,
}

unsafe impl Send for VkDisplayProperties2KHR<'_> {}
unsafe impl Sync for VkDisplayProperties2KHR<'_> {}

impl fmt::Debug for VkDisplayProperties2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayProperties2KHR").finish()
	}
}

impl Default for VkDisplayProperties2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDisplayPlaneProperties2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub displayPlaneProperties                       : VkDisplayPlanePropertiesKHR,
}

unsafe impl Send for VkDisplayPlaneProperties2KHR<'_> {}
unsafe impl Sync for VkDisplayPlaneProperties2KHR<'_> {}

impl fmt::Debug for VkDisplayPlaneProperties2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneProperties2KHR").finish()
	}
}

impl Default for VkDisplayPlaneProperties2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDisplayModeProperties2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub displayModeProperties                        : VkDisplayModePropertiesKHR,
}

unsafe impl Send for VkDisplayModeProperties2KHR<'_> {}
unsafe impl Sync for VkDisplayModeProperties2KHR<'_> {}

impl fmt::Debug for VkDisplayModeProperties2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeProperties2KHR").finish()
	}
}

impl Default for VkDisplayModeProperties2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayPlaneInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub mode                                         : VkDisplayModeKHR,
	pub planeIndex                                   : u32,
}

unsafe impl Send for VkDisplayPlaneInfo2KHR<'_> {}
unsafe impl Sync for VkDisplayPlaneInfo2KHR<'_> {}

impl Default for VkDisplayPlaneInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDisplayPlaneCapabilities2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub capabilities                                 : VkDisplayPlaneCapabilitiesKHR,
}

unsafe impl Send for VkDisplayPlaneCapabilities2KHR<'_> {}
unsafe impl Sync for VkDisplayPlaneCapabilities2KHR<'_> {}

impl fmt::Debug for VkDisplayPlaneCapabilities2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneCapabilities2KHR").finish()
	}
}

impl Default for VkDisplayPlaneCapabilities2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkSharedPresentSurfaceCapabilitiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// Supported image usage flags if swapchain created using a shared present mode
	pub sharedPresentSupportedUsageFlags             : VkImageUsageFlags,
}

unsafe impl Send for VkSharedPresentSurfaceCapabilitiesKHR<'_> {}
unsafe impl Sync for VkSharedPresentSurfaceCapabilitiesKHR<'_> {}

impl Default for VkSharedPresentSurfaceCapabilitiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevice16BitStorageFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// 16-bit integer/floating-point variables supported in BufferBlock
	pub storageBuffer16BitAccess                     : VkBool32,
	/// 16-bit integer/floating-point variables supported in BufferBlock and Block
	pub uniformAndStorageBuffer16BitAccess           : VkBool32,
	/// 16-bit integer/floating-point variables supported in PushConstant
	pub storagePushConstant16                        : VkBool32,
	/// 16-bit integer/floating-point variables supported in shader inputs and outputs
	pub storageInputOutput16                         : VkBool32,
}

unsafe impl Send for VkPhysicalDevice16BitStorageFeatures<'_> {}
unsafe impl Sync for VkPhysicalDevice16BitStorageFeatures<'_> {}

impl Default for VkPhysicalDevice16BitStorageFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDevice16BitStorageFeaturesKHR      <'a> = VkPhysicalDevice16BitStorageFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSubgroupProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// The size of a subgroup for this queue.
	pub subgroupSize                                 : u32,
	/// Bitfield of what shader stages support subgroup operations
	pub supportedStages                              : VkShaderStageFlags,
	/// Bitfield of what subgroup operations are supported.
	pub supportedOperations                          : VkSubgroupFeatureFlags,
	/// Flag to specify whether quad operations are available in all stages.
	pub quadOperationsInAllStages                    : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSubgroupProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceSubgroupProperties<'_> {}

impl Default for VkPhysicalDeviceSubgroupProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// Flag to specify whether subgroup operations with extended types are supported
	pub shaderSubgroupExtendedTypes                  : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures<'_> {}

impl Default for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR<'a> = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferMemoryRequirementsInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub buffer                                       : VkBuffer,
}

unsafe impl Send for VkBufferMemoryRequirementsInfo2<'_> {}
unsafe impl Sync for VkBufferMemoryRequirementsInfo2<'_> {}

impl Default for VkBufferMemoryRequirementsInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBufferMemoryRequirementsInfo2KHR           <'a> = VkBufferMemoryRequirementsInfo2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageMemoryRequirementsInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub image                                        : VkImage,
}

unsafe impl Send for VkImageMemoryRequirementsInfo2<'_> {}
unsafe impl Sync for VkImageMemoryRequirementsInfo2<'_> {}

impl Default for VkImageMemoryRequirementsInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImageMemoryRequirementsInfo2KHR            <'a> = VkImageMemoryRequirementsInfo2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageSparseMemoryRequirementsInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub image                                        : VkImage,
}

unsafe impl Send for VkImageSparseMemoryRequirementsInfo2<'_> {}
unsafe impl Sync for VkImageSparseMemoryRequirementsInfo2<'_> {}

impl Default for VkImageSparseMemoryRequirementsInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImageSparseMemoryRequirementsInfo2KHR      <'a> = VkImageSparseMemoryRequirementsInfo2<'a>;

#[repr(C)]
#[derive()]
pub struct VkMemoryRequirements2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryRequirements                           : VkMemoryRequirements,
}

unsafe impl Send for VkMemoryRequirements2<'_> {}
unsafe impl Sync for VkMemoryRequirements2<'_> {}

impl fmt::Debug for VkMemoryRequirements2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryRequirements2").finish()
	}
}

impl Default for VkMemoryRequirements2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkMemoryRequirements2KHR                     <'a> = VkMemoryRequirements2<'a>;

#[repr(C)]
#[derive()]
pub struct VkSparseImageMemoryRequirements2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryRequirements                           : VkSparseImageMemoryRequirements,
}

unsafe impl Send for VkSparseImageMemoryRequirements2<'_> {}
unsafe impl Sync for VkSparseImageMemoryRequirements2<'_> {}

impl fmt::Debug for VkSparseImageMemoryRequirements2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryRequirements2").finish()
	}
}

impl Default for VkSparseImageMemoryRequirements2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSparseImageMemoryRequirements2KHR          <'a> = VkSparseImageMemoryRequirements2<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePointClippingProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub pointClippingBehavior                        : VkPointClippingBehavior,
}

unsafe impl Send for VkPhysicalDevicePointClippingProperties<'_> {}
unsafe impl Sync for VkPhysicalDevicePointClippingProperties<'_> {}

impl Default for VkPhysicalDevicePointClippingProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDevicePointClippingPropertiesKHR   <'a> = VkPhysicalDevicePointClippingProperties<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkMemoryDedicatedRequirements<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub prefersDedicatedAllocation                   : VkBool32,
	pub requiresDedicatedAllocation                  : VkBool32,
}

unsafe impl Send for VkMemoryDedicatedRequirements<'_> {}
unsafe impl Sync for VkMemoryDedicatedRequirements<'_> {}

impl Default for VkMemoryDedicatedRequirements<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkMemoryDedicatedRequirementsKHR             <'a> = VkMemoryDedicatedRequirements<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryDedicatedAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Image that this allocation will be bound to
	pub image                                        : VkImage,
	/// Buffer that this allocation will be bound to
	pub buffer                                       : VkBuffer,
}

unsafe impl Send for VkMemoryDedicatedAllocateInfo<'_> {}
unsafe impl Sync for VkMemoryDedicatedAllocateInfo<'_> {}

impl Default for VkMemoryDedicatedAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkMemoryDedicatedAllocateInfoKHR             <'a> = VkMemoryDedicatedAllocateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageViewUsageCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub usage                                        : VkImageUsageFlags,
}

unsafe impl Send for VkImageViewUsageCreateInfo<'_> {}
unsafe impl Sync for VkImageViewUsageCreateInfo<'_> {}

impl Default for VkImageViewUsageCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImageViewUsageCreateInfoKHR                <'a> = VkImageViewUsageCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub domainOrigin                                 : VkTessellationDomainOrigin,
}

unsafe impl Send for VkPipelineTessellationDomainOriginStateCreateInfo<'_> {}
unsafe impl Sync for VkPipelineTessellationDomainOriginStateCreateInfo<'_> {}

impl Default for VkPipelineTessellationDomainOriginStateCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPipelineTessellationDomainOriginStateCreateInfoKHR<'a> = VkPipelineTessellationDomainOriginStateCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSamplerYcbcrConversionInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub conversion                                   : VkSamplerYcbcrConversion,
}

unsafe impl Send for VkSamplerYcbcrConversionInfo<'_> {}
unsafe impl Sync for VkSamplerYcbcrConversionInfo<'_> {}

impl Default for VkSamplerYcbcrConversionInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSamplerYcbcrConversionInfoKHR              <'a> = VkSamplerYcbcrConversionInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerYcbcrConversionCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub format                                       : VkFormat,
	pub ycbcrModel                                   : VkSamplerYcbcrModelConversion,
	pub ycbcrRange                                   : VkSamplerYcbcrRange,
	pub components                                   : VkComponentMapping,
	pub xChromaOffset                                : VkChromaLocation,
	pub yChromaOffset                                : VkChromaLocation,
	pub chromaFilter                                 : VkFilter,
	pub forceExplicitReconstruction                  : VkBool32,
}

unsafe impl Send for VkSamplerYcbcrConversionCreateInfo<'_> {}
unsafe impl Sync for VkSamplerYcbcrConversionCreateInfo<'_> {}

impl fmt::Debug for VkSamplerYcbcrConversionCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerYcbcrConversionCreateInfo").finish()
	}
}

impl Default for VkSamplerYcbcrConversionCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSamplerYcbcrConversionCreateInfoKHR        <'a> = VkSamplerYcbcrConversionCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindImagePlaneMemoryInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub planeAspect                                  : VkImageAspectFlagBits,
}

unsafe impl Send for VkBindImagePlaneMemoryInfo<'_> {}
unsafe impl Sync for VkBindImagePlaneMemoryInfo<'_> {}

impl Default for VkBindImagePlaneMemoryInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBindImagePlaneMemoryInfoKHR                <'a> = VkBindImagePlaneMemoryInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImagePlaneMemoryRequirementsInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub planeAspect                                  : VkImageAspectFlagBits,
}

unsafe impl Send for VkImagePlaneMemoryRequirementsInfo<'_> {}
unsafe impl Sync for VkImagePlaneMemoryRequirementsInfo<'_> {}

impl Default for VkImagePlaneMemoryRequirementsInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImagePlaneMemoryRequirementsInfoKHR        <'a> = VkImagePlaneMemoryRequirementsInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// Sampler color conversion supported
	pub samplerYcbcrConversion                       : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSamplerYcbcrConversionFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceSamplerYcbcrConversionFeatures<'_> {}

impl Default for VkPhysicalDeviceSamplerYcbcrConversionFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR<'a> = VkPhysicalDeviceSamplerYcbcrConversionFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkSamplerYcbcrConversionImageFormatProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub combinedImageSamplerDescriptorCount          : u32,
}

unsafe impl Send for VkSamplerYcbcrConversionImageFormatProperties<'_> {}
unsafe impl Sync for VkSamplerYcbcrConversionImageFormatProperties<'_> {}

impl Default for VkSamplerYcbcrConversionImageFormatProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSamplerYcbcrConversionImageFormatPropertiesKHR<'a> = VkSamplerYcbcrConversionImageFormatProperties<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkTextureLODGatherFormatPropertiesAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub supportsTextureGatherLODBiasAMD              : VkBool32,
}

unsafe impl Send for VkTextureLODGatherFormatPropertiesAMD<'_> {}
unsafe impl Sync for VkTextureLODGatherFormatPropertiesAMD<'_> {}

impl Default for VkTextureLODGatherFormatPropertiesAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkConditionalRenderingBeginInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub buffer                                       : VkBuffer,
	pub offset                                       : VkDeviceSize,
	pub flags                                        : VkConditionalRenderingFlagsEXT,
}

unsafe impl Send for VkConditionalRenderingBeginInfoEXT<'_> {}
unsafe impl Sync for VkConditionalRenderingBeginInfoEXT<'_> {}

impl Default for VkConditionalRenderingBeginInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkProtectedSubmitInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Submit protected command buffers
	pub protectedSubmit                              : VkBool32,
}

unsafe impl Send for VkProtectedSubmitInfo<'_> {}
unsafe impl Sync for VkProtectedSubmitInfo<'_> {}

impl Default for VkProtectedSubmitInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceProtectedMemoryFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub protectedMemory                              : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceProtectedMemoryFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceProtectedMemoryFeatures<'_> {}

impl Default for VkPhysicalDeviceProtectedMemoryFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceProtectedMemoryProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub protectedNoFault                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceProtectedMemoryProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceProtectedMemoryProperties<'_> {}

impl Default for VkPhysicalDeviceProtectedMemoryProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceQueueInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDeviceQueueCreateFlags,
	pub queueFamilyIndex                             : u32,
	pub queueIndex                                   : u32,
}

unsafe impl Send for VkDeviceQueueInfo2<'_> {}
unsafe impl Sync for VkDeviceQueueInfo2<'_> {}

impl Default for VkDeviceQueueInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineCoverageToColorStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineCoverageToColorStateCreateFlagsNV,
	pub coverageToColorEnable                        : VkBool32,
	pub coverageToColorLocation                      : u32,
}

unsafe impl Send for VkPipelineCoverageToColorStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineCoverageToColorStateCreateInfoNV<'_> {}

impl Default for VkPipelineCoverageToColorStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub filterMinmaxSingleComponentFormats           : VkBool32,
	pub filterMinmaxImageComponentMapping            : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSamplerFilterMinmaxProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceSamplerFilterMinmaxProperties<'_> {}

impl Default for VkPhysicalDeviceSamplerFilterMinmaxProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT<'a> = VkPhysicalDeviceSamplerFilterMinmaxProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSampleLocationEXT {
	pub x                                            : f32,
	pub y                                            : f32,
}

unsafe impl Send for VkSampleLocationEXT {}
unsafe impl Sync for VkSampleLocationEXT {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSampleLocationsInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub sampleLocationsPerPixel                      : VkSampleCountFlagBits,
	pub sampleLocationGridSize                       : VkExtent2D,
	pub sampleLocationsCount                         : u32,
	pub pSampleLocations                             : *const VkSampleLocationEXT,
}

unsafe impl Send for VkSampleLocationsInfoEXT<'_> {}
unsafe impl Sync for VkSampleLocationsInfoEXT<'_> {}

impl fmt::Debug for VkSampleLocationsInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSampleLocationsInfoEXT").finish()
	}
}

impl Default for VkSampleLocationsInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAttachmentSampleLocationsEXT<'a> {
	pub attachmentIndex                              : u32,
	pub sampleLocationsInfo                          : VkSampleLocationsInfoEXT<'a>,
}

unsafe impl Send for VkAttachmentSampleLocationsEXT<'_> {}
unsafe impl Sync for VkAttachmentSampleLocationsEXT<'_> {}

impl fmt::Debug for VkAttachmentSampleLocationsEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentSampleLocationsEXT").finish()
	}
}

impl Default for VkAttachmentSampleLocationsEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassSampleLocationsEXT<'a> {
	pub subpassIndex                                 : u32,
	pub sampleLocationsInfo                          : VkSampleLocationsInfoEXT<'a>,
}

unsafe impl Send for VkSubpassSampleLocationsEXT<'_> {}
unsafe impl Sync for VkSubpassSampleLocationsEXT<'_> {}

impl fmt::Debug for VkSubpassSampleLocationsEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassSampleLocationsEXT").finish()
	}
}

impl Default for VkSubpassSampleLocationsEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassSampleLocationsBeginInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub attachmentInitialSampleLocationsCount        : u32,
	pub pAttachmentInitialSampleLocations            : *const VkAttachmentSampleLocationsEXT<'a>,
	pub postSubpassSampleLocationsCount              : u32,
	pub pPostSubpassSampleLocations                  : *const VkSubpassSampleLocationsEXT<'a>,
}

unsafe impl Send for VkRenderPassSampleLocationsBeginInfoEXT<'_> {}
unsafe impl Sync for VkRenderPassSampleLocationsBeginInfoEXT<'_> {}

impl fmt::Debug for VkRenderPassSampleLocationsBeginInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassSampleLocationsBeginInfoEXT").finish()
	}
}

impl Default for VkRenderPassSampleLocationsBeginInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineSampleLocationsStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub sampleLocationsEnable                        : VkBool32,
	pub sampleLocationsInfo                          : VkSampleLocationsInfoEXT<'a>,
}

unsafe impl Send for VkPipelineSampleLocationsStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineSampleLocationsStateCreateInfoEXT<'_> {}

impl fmt::Debug for VkPipelineSampleLocationsStateCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineSampleLocationsStateCreateInfoEXT").finish()
	}
}

impl Default for VkPipelineSampleLocationsStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceSampleLocationsPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub sampleLocationSampleCounts                   : VkSampleCountFlags,
	pub maxSampleLocationGridSize                    : VkExtent2D,
	pub sampleLocationCoordinateRange                : [f32;  2 as usize],
	pub sampleLocationSubPixelBits                   : u32,
	pub variableSampleLocations                      : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSampleLocationsPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceSampleLocationsPropertiesEXT<'_> {}

impl fmt::Debug for VkPhysicalDeviceSampleLocationsPropertiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSampleLocationsPropertiesEXT").finish()
	}
}

impl Default for VkPhysicalDeviceSampleLocationsPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkMultisamplePropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxSampleLocationGridSize                    : VkExtent2D,
}

unsafe impl Send for VkMultisamplePropertiesEXT<'_> {}
unsafe impl Sync for VkMultisamplePropertiesEXT<'_> {}

impl fmt::Debug for VkMultisamplePropertiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkMultisamplePropertiesEXT").finish()
	}
}

impl Default for VkMultisamplePropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSamplerReductionModeCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub reductionMode                                : VkSamplerReductionMode,
}

unsafe impl Send for VkSamplerReductionModeCreateInfo<'_> {}
unsafe impl Sync for VkSamplerReductionModeCreateInfo<'_> {}

impl Default for VkSamplerReductionModeCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSamplerReductionModeCreateInfoEXT          <'a> = VkSamplerReductionModeCreateInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub advancedBlendCoherentOperations              : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMultiDrawFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub multiDraw                                    : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceMultiDrawFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceMultiDrawFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceMultiDrawFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub advancedBlendMaxColorAttachments             : u32,
	pub advancedBlendIndependentBlend                : VkBool32,
	pub advancedBlendNonPremultipliedSrcColor        : VkBool32,
	pub advancedBlendNonPremultipliedDstColor        : VkBool32,
	pub advancedBlendCorrelatedOverlap               : VkBool32,
	pub advancedBlendAllOperations                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcPremultiplied                             : VkBool32,
	pub dstPremultiplied                             : VkBool32,
	pub blendOverlap                                 : VkBlendOverlapEXT,
}

unsafe impl Send for VkPipelineColorBlendAdvancedStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineColorBlendAdvancedStateCreateInfoEXT<'_> {}

impl Default for VkPipelineColorBlendAdvancedStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub inlineUniformBlock                           : VkBool32,
	pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
}

unsafe impl Send for VkPhysicalDeviceInlineUniformBlockFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceInlineUniformBlockFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceInlineUniformBlockFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxInlineUniformBlockSize                    : u32,
	pub maxPerStageDescriptorInlineUniformBlocks     : u32,
	pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
	pub maxDescriptorSetInlineUniformBlocks          : u32,
	pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
}

unsafe impl Send for VkPhysicalDeviceInlineUniformBlockPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceInlineUniformBlockPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceInlineUniformBlockPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWriteDescriptorSetInlineUniformBlockEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub dataSize                                     : u32,
	pub pData                                        : *const (),
}

unsafe impl Send for VkWriteDescriptorSetInlineUniformBlockEXT<'_> {}
unsafe impl Sync for VkWriteDescriptorSetInlineUniformBlockEXT<'_> {}

impl Default for VkWriteDescriptorSetInlineUniformBlockEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub maxInlineUniformBlockBindings                : u32,
}

unsafe impl Send for VkDescriptorPoolInlineUniformBlockCreateInfoEXT<'_> {}
unsafe impl Sync for VkDescriptorPoolInlineUniformBlockCreateInfoEXT<'_> {}

impl Default for VkDescriptorPoolInlineUniformBlockCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineCoverageModulationStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineCoverageModulationStateCreateFlagsNV,
	pub coverageModulationMode                       : VkCoverageModulationModeNV,
	pub coverageModulationTableEnable                : VkBool32,
	pub coverageModulationTableCount                 : u32,
	pub pCoverageModulationTable                     : *const f32,
}

unsafe impl Send for VkPipelineCoverageModulationStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineCoverageModulationStateCreateInfoNV<'_> {}

impl Default for VkPipelineCoverageModulationStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageFormatListCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub viewFormatCount                              : u32,
	pub pViewFormats                                 : *const VkFormat,
}

unsafe impl Send for VkImageFormatListCreateInfo<'_> {}
unsafe impl Sync for VkImageFormatListCreateInfo<'_> {}

impl Default for VkImageFormatListCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImageFormatListCreateInfoKHR               <'a> = VkImageFormatListCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkValidationCacheCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkValidationCacheCreateFlagsEXT,
	pub initialDataSize                              : usize,
	pub pInitialData                                 : *const (),
}

unsafe impl Send for VkValidationCacheCreateInfoEXT<'_> {}
unsafe impl Sync for VkValidationCacheCreateInfoEXT<'_> {}

impl Default for VkValidationCacheCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkShaderModuleValidationCacheCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub validationCache                              : VkValidationCacheEXT,
}

unsafe impl Send for VkShaderModuleValidationCacheCreateInfoEXT<'_> {}
unsafe impl Sync for VkShaderModuleValidationCacheCreateInfoEXT<'_> {}

impl Default for VkShaderModuleValidationCacheCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMaintenance3Properties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxPerSetDescriptors                         : u32,
	pub maxMemoryAllocationSize                      : VkDeviceSize,
}

unsafe impl Send for VkPhysicalDeviceMaintenance3Properties<'_> {}
unsafe impl Sync for VkPhysicalDeviceMaintenance3Properties<'_> {}

impl Default for VkPhysicalDeviceMaintenance3Properties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceMaintenance3PropertiesKHR    <'a> = VkPhysicalDeviceMaintenance3Properties<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkDescriptorSetLayoutSupport<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub supported                                    : VkBool32,
}

unsafe impl Send for VkDescriptorSetLayoutSupport<'_> {}
unsafe impl Sync for VkDescriptorSetLayoutSupport<'_> {}

impl Default for VkDescriptorSetLayoutSupport<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDescriptorSetLayoutSupportKHR              <'a> = VkDescriptorSetLayoutSupport<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderDrawParametersFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderDrawParameters                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderDrawParametersFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderDrawParametersFeatures<'_> {}

impl Default for VkPhysicalDeviceShaderDrawParametersFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceShaderDrawParameterFeatures  <'a> = VkPhysicalDeviceShaderDrawParametersFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderFloat16Int8Features<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// 16-bit floats (halfs) in shaders
	pub shaderFloat16                                : VkBool32,
	/// 8-bit integers in shaders
	pub shaderInt8                                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderFloat16Int8Features<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderFloat16Int8Features<'_> {}

impl Default for VkPhysicalDeviceShaderFloat16Int8Features<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceShaderFloat16Int8FeaturesKHR <'a> = VkPhysicalDeviceShaderFloat16Int8Features<'a>;

pub type VkPhysicalDeviceFloat16Int8FeaturesKHR       <'a> = VkPhysicalDeviceShaderFloat16Int8Features<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFloatControlsProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub denormBehaviorIndependence                   : VkShaderFloatControlsIndependence,
	pub roundingModeIndependence                     : VkShaderFloatControlsIndependence,
	/// An implementation can preserve signed zero, nan, inf
	pub shaderSignedZeroInfNanPreserveFloat16        : VkBool32,
	/// An implementation can preserve signed zero, nan, inf
	pub shaderSignedZeroInfNanPreserveFloat32        : VkBool32,
	/// An implementation can preserve signed zero, nan, inf
	pub shaderSignedZeroInfNanPreserveFloat64        : VkBool32,
	/// An implementation can preserve  denormals
	pub shaderDenormPreserveFloat16                  : VkBool32,
	/// An implementation can preserve  denormals
	pub shaderDenormPreserveFloat32                  : VkBool32,
	/// An implementation can preserve  denormals
	pub shaderDenormPreserveFloat64                  : VkBool32,
	/// An implementation can flush to zero  denormals
	pub shaderDenormFlushToZeroFloat16               : VkBool32,
	/// An implementation can flush to zero  denormals
	pub shaderDenormFlushToZeroFloat32               : VkBool32,
	/// An implementation can flush to zero  denormals
	pub shaderDenormFlushToZeroFloat64               : VkBool32,
	/// An implementation can support RTE
	pub shaderRoundingModeRTEFloat16                 : VkBool32,
	/// An implementation can support RTE
	pub shaderRoundingModeRTEFloat32                 : VkBool32,
	/// An implementation can support RTE
	pub shaderRoundingModeRTEFloat64                 : VkBool32,
	/// An implementation can support RTZ
	pub shaderRoundingModeRTZFloat16                 : VkBool32,
	/// An implementation can support RTZ
	pub shaderRoundingModeRTZFloat32                 : VkBool32,
	/// An implementation can support RTZ
	pub shaderRoundingModeRTZFloat64                 : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFloatControlsProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceFloatControlsProperties<'_> {}

impl Default for VkPhysicalDeviceFloatControlsProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceFloatControlsPropertiesKHR   <'a> = VkPhysicalDeviceFloatControlsProperties<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceHostQueryResetFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub hostQueryReset                               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceHostQueryResetFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceHostQueryResetFeatures<'_> {}

impl Default for VkPhysicalDeviceHostQueryResetFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceHostQueryResetFeaturesEXT    <'a> = VkPhysicalDeviceHostQueryResetFeatures<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkNativeBufferUsage2ANDROID {
	pub consumer                                     : u64,
	pub producer                                     : u64,
}

unsafe impl Send for VkNativeBufferUsage2ANDROID {}
unsafe impl Sync for VkNativeBufferUsage2ANDROID {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkNativeBufferANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handle                                       : VkAnyRef<'a>,
	pub stride                                       : i32,
	pub format                                       : i32,
	pub usage                                        : i32,
	pub usage2                                       : VkNativeBufferUsage2ANDROID,
}

unsafe impl Send for VkNativeBufferANDROID<'_> {}
unsafe impl Sync for VkNativeBufferANDROID<'_> {}

impl fmt::Debug for VkNativeBufferANDROID<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkNativeBufferANDROID").finish()
	}
}

impl Default for VkNativeBufferANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSwapchainImageCreateInfoANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub usage                                        : VkSwapchainImageUsageFlagsANDROID,
}

unsafe impl Send for VkSwapchainImageCreateInfoANDROID<'_> {}
unsafe impl Sync for VkSwapchainImageCreateInfoANDROID<'_> {}

impl Default for VkSwapchainImageCreateInfoANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDevicePresentationPropertiesANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub sharedImage                                  : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePresentationPropertiesANDROID<'_> {}
unsafe impl Sync for VkPhysicalDevicePresentationPropertiesANDROID<'_> {}

impl Default for VkPhysicalDevicePresentationPropertiesANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkShaderResourceUsageAMD {
	pub numUsedVgprs                                 : u32,
	pub numUsedSgprs                                 : u32,
	pub ldsSizePerLocalWorkGroup                     : u32,
	pub ldsUsageSizeInBytes                          : usize,
	pub scratchMemUsageInBytes                       : usize,
}

unsafe impl Send for VkShaderResourceUsageAMD {}
unsafe impl Sync for VkShaderResourceUsageAMD {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkShaderStatisticsInfoAMD {
	pub shaderStageMask                              : VkShaderStageFlags,
	pub resourceUsage                                : VkShaderResourceUsageAMD,
	pub numPhysicalVgprs                             : u32,
	pub numPhysicalSgprs                             : u32,
	pub numAvailableVgprs                            : u32,
	pub numAvailableSgprs                            : u32,
	pub computeWorkGroupSize                         : [u32;  3 as usize],
}

unsafe impl Send for VkShaderStatisticsInfoAMD {}
unsafe impl Sync for VkShaderStatisticsInfoAMD {}

impl fmt::Debug for VkShaderStatisticsInfoAMD {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkShaderStatisticsInfoAMD").finish()
	}
}

impl Default for VkShaderStatisticsInfoAMD {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceQueueGlobalPriorityCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub globalPriority                               : VkQueueGlobalPriorityEXT,
}

unsafe impl Send for VkDeviceQueueGlobalPriorityCreateInfoEXT<'_> {}
unsafe impl Sync for VkDeviceQueueGlobalPriorityCreateInfoEXT<'_> {}

impl Default for VkDeviceQueueGlobalPriorityCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub globalPriorityQuery                          : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkQueueFamilyGlobalPriorityPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub priorityCount                                : u32,
	pub priorities                                   : [VkQueueGlobalPriorityEXT;  VK_MAX_GLOBAL_PRIORITY_SIZE_EXT as usize],
}

unsafe impl Send for VkQueueFamilyGlobalPriorityPropertiesEXT<'_> {}
unsafe impl Sync for VkQueueFamilyGlobalPriorityPropertiesEXT<'_> {}

impl fmt::Debug for VkQueueFamilyGlobalPriorityPropertiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyGlobalPriorityPropertiesEXT").finish()
	}
}

impl Default for VkQueueFamilyGlobalPriorityPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDebugUtilsObjectNameInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub objectType                                   : VkObjectType,
	pub objectHandle                                 : u64,
	pub pObjectName                                  : *const u8,
}

unsafe impl Send for VkDebugUtilsObjectNameInfoEXT<'_> {}
unsafe impl Sync for VkDebugUtilsObjectNameInfoEXT<'_> {}

impl Default for VkDebugUtilsObjectNameInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDebugUtilsObjectTagInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub objectType                                   : VkObjectType,
	pub objectHandle                                 : u64,
	pub tagName                                      : u64,
	pub tagSize                                      : usize,
	pub pTag                                         : *const (),
}

unsafe impl Send for VkDebugUtilsObjectTagInfoEXT<'_> {}
unsafe impl Sync for VkDebugUtilsObjectTagInfoEXT<'_> {}

impl Default for VkDebugUtilsObjectTagInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugUtilsLabelEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pLabelName                                   : *const u8,
	pub color                                        : [f32;  4 as usize],
}

unsafe impl Send for VkDebugUtilsLabelEXT<'_> {}
unsafe impl Sync for VkDebugUtilsLabelEXT<'_> {}

impl fmt::Debug for VkDebugUtilsLabelEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsLabelEXT").finish()
	}
}

impl Default for VkDebugUtilsLabelEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDebugUtilsMessengerCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDebugUtilsMessengerCreateFlagsEXT,
	pub messageSeverity                              : VkDebugUtilsMessageSeverityFlagsEXT,
	pub messageType                                  : VkDebugUtilsMessageTypeFlagsEXT,
	pub pfnUserCallback                              : PFN_vkDebugUtilsMessengerCallbackEXT,
	pub pUserData                                    : Option<VkAnyMut<'a>>,
}

unsafe impl Send for VkDebugUtilsMessengerCreateInfoEXT<'_> {}
unsafe impl Sync for VkDebugUtilsMessengerCreateInfoEXT<'_> {}

impl fmt::Debug for VkDebugUtilsMessengerCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsMessengerCreateInfoEXT").finish()
	}
}

impl Default for VkDebugUtilsMessengerCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDebugUtilsMessengerCallbackDataEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDebugUtilsMessengerCallbackDataFlagsEXT,
	pub pMessageIdName                               : *const u8,
	pub messageIdNumber                              : i32,
	pub pMessage                                     : *const u8,
	pub queueLabelCount                              : u32,
	pub pQueueLabels                                 : *const VkDebugUtilsLabelEXT<'a>,
	pub cmdBufLabelCount                             : u32,
	pub pCmdBufLabels                                : *const VkDebugUtilsLabelEXT<'a>,
	pub objectCount                                  : u32,
	pub pObjects                                     : *const VkDebugUtilsObjectNameInfoEXT<'a>,
}

unsafe impl Send for VkDebugUtilsMessengerCallbackDataEXT<'_> {}
unsafe impl Sync for VkDebugUtilsMessengerCallbackDataEXT<'_> {}

impl fmt::Debug for VkDebugUtilsMessengerCallbackDataEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsMessengerCallbackDataEXT").finish()
	}
}

impl Default for VkDebugUtilsMessengerCallbackDataEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub deviceMemoryReport                           : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkDeviceDeviceMemoryReportCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDeviceMemoryReportFlagsEXT,
	pub pfnUserCallback                              : PFN_vkDeviceMemoryReportCallbackEXT,
	pub pUserData                                    : VkAnyMut<'a>,
}

unsafe impl Send for VkDeviceDeviceMemoryReportCreateInfoEXT<'_> {}
unsafe impl Sync for VkDeviceDeviceMemoryReportCreateInfoEXT<'_> {}

impl fmt::Debug for VkDeviceDeviceMemoryReportCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceDeviceMemoryReportCreateInfoEXT").finish()
	}
}

impl Default for VkDeviceDeviceMemoryReportCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkDeviceMemoryReportCallbackDataEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub flags                                        : VkDeviceMemoryReportFlagsEXT,
	pub r#type                                       : VkDeviceMemoryReportEventTypeEXT,
	pub memoryObjectId                               : u64,
	pub size                                         : VkDeviceSize,
	pub objectType                                   : VkObjectType,
	pub objectHandle                                 : u64,
	pub heapIndex                                    : u32,
}

unsafe impl Send for VkDeviceMemoryReportCallbackDataEXT<'_> {}
unsafe impl Sync for VkDeviceMemoryReportCallbackDataEXT<'_> {}

impl Default for VkDeviceMemoryReportCallbackDataEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkImportMemoryHostPointerInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
	pub pHostPointer                                 : VkAnyMut<'a>,
}

unsafe impl Send for VkImportMemoryHostPointerInfoEXT<'_> {}
unsafe impl Sync for VkImportMemoryHostPointerInfoEXT<'_> {}

impl Default for VkImportMemoryHostPointerInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkMemoryHostPointerPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryTypeBits                               : u32,
}

unsafe impl Send for VkMemoryHostPointerPropertiesEXT<'_> {}
unsafe impl Sync for VkMemoryHostPointerPropertiesEXT<'_> {}

impl Default for VkMemoryHostPointerPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub minImportedHostPointerAlignment              : VkDeviceSize,
}

unsafe impl Send for VkPhysicalDeviceExternalMemoryHostPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceExternalMemoryHostPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceExternalMemoryHostPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// The size in pixels the primitive is enlarged at each edge during conservative rasterization
	pub primitiveOverestimationSize                  : f32,
	/// The maximum additional overestimation the client can specify in the pipeline state
	pub maxExtraPrimitiveOverestimationSize          : f32,
	/// The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
	pub extraPrimitiveOverestimationSizeGranularity  : f32,
	/// true if the implementation supports conservative rasterization underestimation mode
	pub primitiveUnderestimation                     : VkBool32,
	/// true if conservative rasterization also applies to points and lines
	pub conservativePointAndLineRasterization        : VkBool32,
	/// true if degenerate triangles (those with zero area after snap) are rasterized
	pub degenerateTrianglesRasterized                : VkBool32,
	/// true if degenerate lines (those with zero length after snap) are rasterized
	pub degenerateLinesRasterized                    : VkBool32,
	/// true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
	pub fullyCoveredFragmentShaderInputVariable      : VkBool32,
	/// true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
	pub conservativeRasterizationPostDepthCoverage   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceConservativeRasterizationPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceConservativeRasterizationPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceConservativeRasterizationPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCalibratedTimestampInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub timeDomain                                   : VkTimeDomainEXT,
}

unsafe impl Send for VkCalibratedTimestampInfoEXT<'_> {}
unsafe impl Sync for VkCalibratedTimestampInfoEXT<'_> {}

impl Default for VkCalibratedTimestampInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderCorePropertiesAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// number of shader engines
	pub shaderEngineCount                            : u32,
	/// number of shader arrays
	pub shaderArraysPerEngineCount                   : u32,
	/// number of physical CUs per shader array
	pub computeUnitsPerShaderArray                   : u32,
	/// number of SIMDs per compute unit
	pub simdPerComputeUnit                           : u32,
	/// number of wavefront slots in each SIMD
	pub wavefrontsPerSimd                            : u32,
	/// maximum number of threads per wavefront
	pub wavefrontSize                                : u32,
	/// number of physical SGPRs per SIMD
	pub sgprsPerSimd                                 : u32,
	/// minimum number of SGPRs that can be allocated by a wave
	pub minSgprAllocation                            : u32,
	/// number of available SGPRs
	pub maxSgprAllocation                            : u32,
	/// SGPRs are allocated in groups of this size
	pub sgprAllocationGranularity                    : u32,
	/// number of physical VGPRs per SIMD
	pub vgprsPerSimd                                 : u32,
	/// minimum number of VGPRs that can be allocated by a wave
	pub minVgprAllocation                            : u32,
	/// number of available VGPRs
	pub maxVgprAllocation                            : u32,
	/// VGPRs are allocated in groups of this size
	pub vgprAllocationGranularity                    : u32,
}

unsafe impl Send for VkPhysicalDeviceShaderCorePropertiesAMD<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderCorePropertiesAMD<'_> {}

impl Default for VkPhysicalDeviceShaderCorePropertiesAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderCoreProperties2AMD<'a> {
	pub sType                                        : VkStructureType,
	/// Pointer to next structure
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// features supported by the shader core
	pub shaderCoreFeatures                           : VkShaderCorePropertiesFlagsAMD,
	/// number of active compute units across all shader engines/arrays
	pub activeComputeUnitCount                       : u32,
}

unsafe impl Send for VkPhysicalDeviceShaderCoreProperties2AMD<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderCoreProperties2AMD<'_> {}

impl Default for VkPhysicalDeviceShaderCoreProperties2AMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationConservativeStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Reserved
	pub flags                                        : VkPipelineRasterizationConservativeStateCreateFlagsEXT,
	/// Conservative rasterization mode
	pub conservativeRasterizationMode                : VkConservativeRasterizationModeEXT,
	/// Extra overestimation to add to the primitive
	pub extraPrimitiveOverestimationSize             : f32,
}

unsafe impl Send for VkPipelineRasterizationConservativeStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineRasterizationConservativeStateCreateInfoEXT<'_> {}

impl Default for VkPipelineRasterizationConservativeStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDescriptorIndexingFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderInputAttachmentArrayDynamicIndexing    : VkBool32,
	pub shaderUniformTexelBufferArrayDynamicIndexing : VkBool32,
	pub shaderStorageTexelBufferArrayDynamicIndexing : VkBool32,
	pub shaderUniformBufferArrayNonUniformIndexing   : VkBool32,
	pub shaderSampledImageArrayNonUniformIndexing    : VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexing   : VkBool32,
	pub shaderStorageImageArrayNonUniformIndexing    : VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexing : VkBool32,
	pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingSampledImageUpdateAfterBind : VkBool32,
	pub descriptorBindingStorageImageUpdateAfterBind : VkBool32,
	pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUpdateUnusedWhilePending    : VkBool32,
	pub descriptorBindingPartiallyBound              : VkBool32,
	pub descriptorBindingVariableDescriptorCount     : VkBool32,
	pub runtimeDescriptorArray                       : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDescriptorIndexingFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceDescriptorIndexingFeatures<'_> {}

impl Default for VkPhysicalDeviceDescriptorIndexingFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceDescriptorIndexingFeaturesEXT<'a> = VkPhysicalDeviceDescriptorIndexingFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDescriptorIndexingProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxUpdateAfterBindDescriptorsInAllPools      : u32,
	pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
	pub robustBufferAccessUpdateAfterBind            : VkBool32,
	pub quadDivergentImplicitLod                     : VkBool32,
	pub maxPerStageDescriptorUpdateAfterBindSamplers : u32,
	pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
	pub maxPerStageUpdateAfterBindResources          : u32,
	pub maxDescriptorSetUpdateAfterBindSamplers      : u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindSampledImages : u32,
	pub maxDescriptorSetUpdateAfterBindStorageImages : u32,
	pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}

unsafe impl Send for VkPhysicalDeviceDescriptorIndexingProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceDescriptorIndexingProperties<'_> {}

impl Default for VkPhysicalDeviceDescriptorIndexingProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceDescriptorIndexingPropertiesEXT<'a> = VkPhysicalDeviceDescriptorIndexingProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub bindingCount                                 : u32,
	pub pBindingFlags                                : *const VkDescriptorBindingFlags,
}

unsafe impl Send for VkDescriptorSetLayoutBindingFlagsCreateInfo<'_> {}
unsafe impl Sync for VkDescriptorSetLayoutBindingFlagsCreateInfo<'_> {}

impl Default for VkDescriptorSetLayoutBindingFlagsCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDescriptorSetLayoutBindingFlagsCreateInfoEXT<'a> = VkDescriptorSetLayoutBindingFlagsCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub descriptorSetCount                           : u32,
	pub pDescriptorCounts                            : *const u32,
}

unsafe impl Send for VkDescriptorSetVariableDescriptorCountAllocateInfo<'_> {}
unsafe impl Sync for VkDescriptorSetVariableDescriptorCountAllocateInfo<'_> {}

impl Default for VkDescriptorSetVariableDescriptorCountAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDescriptorSetVariableDescriptorCountAllocateInfoEXT<'a> = VkDescriptorSetVariableDescriptorCountAllocateInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupport<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxVariableDescriptorCount                   : u32,
}

unsafe impl Send for VkDescriptorSetVariableDescriptorCountLayoutSupport<'_> {}
unsafe impl Sync for VkDescriptorSetVariableDescriptorCountLayoutSupport<'_> {}

impl Default for VkDescriptorSetVariableDescriptorCountLayoutSupport<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDescriptorSetVariableDescriptorCountLayoutSupportEXT<'a> = VkDescriptorSetVariableDescriptorCountLayoutSupport<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAttachmentDescription2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkAttachmentDescriptionFlags,
	pub format                                       : VkFormat,
	pub samples                                      : VkSampleCountFlagBits,
	/// Load operation for color or depth data
	pub loadOp                                       : VkAttachmentLoadOp,
	/// Store operation for color or depth data
	pub storeOp                                      : VkAttachmentStoreOp,
	/// Load operation for stencil data
	pub stencilLoadOp                                : VkAttachmentLoadOp,
	/// Store operation for stencil data
	pub stencilStoreOp                               : VkAttachmentStoreOp,
	pub initialLayout                                : VkImageLayout,
	pub finalLayout                                  : VkImageLayout,
}

unsafe impl Send for VkAttachmentDescription2<'_> {}
unsafe impl Sync for VkAttachmentDescription2<'_> {}

impl Default for VkAttachmentDescription2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkAttachmentDescription2KHR                  <'a> = VkAttachmentDescription2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAttachmentReference2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub attachment                                   : u32,
	pub layout                                       : VkImageLayout,
	pub aspectMask                                   : VkImageAspectFlags,
}

unsafe impl Send for VkAttachmentReference2<'_> {}
unsafe impl Sync for VkAttachmentReference2<'_> {}

impl Default for VkAttachmentReference2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkAttachmentReference2KHR                    <'a> = VkAttachmentReference2<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescription2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkSubpassDescriptionFlags,
	pub pipelineBindPoint                            : VkPipelineBindPoint,
	pub viewMask                                     : u32,
	pub inputAttachmentCount                         : u32,
	pub pInputAttachments                            : *const VkAttachmentReference2<'a>,
	pub colorAttachmentCount                         : u32,
	pub pColorAttachments                            : *const VkAttachmentReference2<'a>,
	pub pResolveAttachments                          : *const VkAttachmentReference2<'a>,
	pub pDepthStencilAttachment                      : Option<&'a VkAttachmentReference2<'a>>,
	pub preserveAttachmentCount                      : u32,
	pub pPreserveAttachments                         : *const u32,
}

unsafe impl Send for VkSubpassDescription2<'_> {}
unsafe impl Sync for VkSubpassDescription2<'_> {}

impl fmt::Debug for VkSubpassDescription2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDescription2").finish()
	}
}

impl Default for VkSubpassDescription2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSubpassDescription2KHR                     <'a> = VkSubpassDescription2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubpassDependency2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcSubpass                                   : u32,
	pub dstSubpass                                   : u32,
	pub srcStageMask                                 : VkPipelineStageFlags,
	pub dstStageMask                                 : VkPipelineStageFlags,
	pub srcAccessMask                                : VkAccessFlags,
	pub dstAccessMask                                : VkAccessFlags,
	pub dependencyFlags                              : VkDependencyFlags,
	pub viewOffset                                   : i32,
}

unsafe impl Send for VkSubpassDependency2<'_> {}
unsafe impl Sync for VkSubpassDependency2<'_> {}

impl Default for VkSubpassDependency2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSubpassDependency2KHR                      <'a> = VkSubpassDependency2<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassCreateInfo2<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkRenderPassCreateFlags,
	pub attachmentCount                              : u32,
	pub pAttachments                                 : *const VkAttachmentDescription2<'a>,
	pub subpassCount                                 : u32,
	pub pSubpasses                                   : *const VkSubpassDescription2<'a>,
	pub dependencyCount                              : u32,
	pub pDependencies                                : *const VkSubpassDependency2<'a>,
	pub correlatedViewMaskCount                      : u32,
	pub pCorrelatedViewMasks                         : *const u32,
}

unsafe impl Send for VkRenderPassCreateInfo2<'_> {}
unsafe impl Sync for VkRenderPassCreateInfo2<'_> {}

impl fmt::Debug for VkRenderPassCreateInfo2<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreateInfo2").finish()
	}
}

impl Default for VkRenderPassCreateInfo2<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkRenderPassCreateInfo2KHR                   <'a> = VkRenderPassCreateInfo2<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubpassBeginInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub contents                                     : VkSubpassContents,
}

unsafe impl Send for VkSubpassBeginInfo<'_> {}
unsafe impl Sync for VkSubpassBeginInfo<'_> {}

impl Default for VkSubpassBeginInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSubpassBeginInfoKHR                        <'a> = VkSubpassBeginInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubpassEndInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
}

unsafe impl Send for VkSubpassEndInfo<'_> {}
unsafe impl Sync for VkSubpassEndInfo<'_> {}

impl Default for VkSubpassEndInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSubpassEndInfoKHR                          <'a> = VkSubpassEndInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub timelineSemaphore                            : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceTimelineSemaphoreFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceTimelineSemaphoreFeatures<'_> {}

impl Default for VkPhysicalDeviceTimelineSemaphoreFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceTimelineSemaphoreFeaturesKHR <'a> = VkPhysicalDeviceTimelineSemaphoreFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTimelineSemaphoreProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxTimelineSemaphoreValueDifference          : u64,
}

unsafe impl Send for VkPhysicalDeviceTimelineSemaphoreProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceTimelineSemaphoreProperties<'_> {}

impl Default for VkPhysicalDeviceTimelineSemaphoreProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceTimelineSemaphorePropertiesKHR<'a> = VkPhysicalDeviceTimelineSemaphoreProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreTypeCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphoreType                                : VkSemaphoreType,
	pub initialValue                                 : u64,
}

unsafe impl Send for VkSemaphoreTypeCreateInfo<'_> {}
unsafe impl Sync for VkSemaphoreTypeCreateInfo<'_> {}

impl Default for VkSemaphoreTypeCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSemaphoreTypeCreateInfoKHR                 <'a> = VkSemaphoreTypeCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkTimelineSemaphoreSubmitInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub waitSemaphoreValueCount                      : u32,
	pub pWaitSemaphoreValues                         : *const u64,
	pub signalSemaphoreValueCount                    : u32,
	pub pSignalSemaphoreValues                       : *const u64,
}

unsafe impl Send for VkTimelineSemaphoreSubmitInfo<'_> {}
unsafe impl Sync for VkTimelineSemaphoreSubmitInfo<'_> {}

impl Default for VkTimelineSemaphoreSubmitInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkTimelineSemaphoreSubmitInfoKHR             <'a> = VkTimelineSemaphoreSubmitInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreWaitInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkSemaphoreWaitFlags,
	pub semaphoreCount                               : u32,
	pub pSemaphores                                  : *const VkSemaphore,
	pub pValues                                      : *const u64,
}

unsafe impl Send for VkSemaphoreWaitInfo<'_> {}
unsafe impl Sync for VkSemaphoreWaitInfo<'_> {}

impl Default for VkSemaphoreWaitInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSemaphoreWaitInfoKHR                       <'a> = VkSemaphoreWaitInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreSignalInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub semaphore                                    : VkSemaphore,
	pub value                                        : u64,
}

unsafe impl Send for VkSemaphoreSignalInfo<'_> {}
unsafe impl Sync for VkSemaphoreSignalInfo<'_> {}

impl Default for VkSemaphoreSignalInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSemaphoreSignalInfoKHR                     <'a> = VkSemaphoreSignalInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkVertexInputBindingDivisorDescriptionEXT {
	pub binding                                      : u32,
	pub divisor                                      : u32,
}

unsafe impl Send for VkVertexInputBindingDivisorDescriptionEXT {}
unsafe impl Sync for VkVertexInputBindingDivisorDescriptionEXT {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineVertexInputDivisorStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub vertexBindingDivisorCount                    : u32,
	pub pVertexBindingDivisors                       : *const VkVertexInputBindingDivisorDescriptionEXT,
}

unsafe impl Send for VkPipelineVertexInputDivisorStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineVertexInputDivisorStateCreateInfoEXT<'_> {}

impl fmt::Debug for VkPipelineVertexInputDivisorStateCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineVertexInputDivisorStateCreateInfoEXT").finish()
	}
}

impl Default for VkPipelineVertexInputDivisorStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// max value of vertex attribute divisor
	pub maxVertexAttribDivisor                       : u32,
}

unsafe impl Send for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePCIBusInfoPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub pciDomain                                    : u32,
	pub pciBus                                       : u32,
	pub pciDevice                                    : u32,
	pub pciFunction                                  : u32,
}

unsafe impl Send for VkPhysicalDevicePCIBusInfoPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDevicePCIBusInfoPropertiesEXT<'_> {}

impl Default for VkPhysicalDevicePCIBusInfoPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkImportAndroidHardwareBufferInfoANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub buffer                                       : &'a mut AHardwareBuffer,
}

unsafe impl Send for VkImportAndroidHardwareBufferInfoANDROID<'_> {}
unsafe impl Sync for VkImportAndroidHardwareBufferInfoANDROID<'_> {}

impl fmt::Debug for VkImportAndroidHardwareBufferInfoANDROID<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImportAndroidHardwareBufferInfoANDROID").finish()
	}
}

impl Default for VkImportAndroidHardwareBufferInfoANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkAndroidHardwareBufferUsageANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub androidHardwareBufferUsage                   : u64,
}

unsafe impl Send for VkAndroidHardwareBufferUsageANDROID<'_> {}
unsafe impl Sync for VkAndroidHardwareBufferUsageANDROID<'_> {}

impl Default for VkAndroidHardwareBufferUsageANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkAndroidHardwareBufferPropertiesANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub allocationSize                               : VkDeviceSize,
	pub memoryTypeBits                               : u32,
}

unsafe impl Send for VkAndroidHardwareBufferPropertiesANDROID<'_> {}
unsafe impl Sync for VkAndroidHardwareBufferPropertiesANDROID<'_> {}

impl Default for VkAndroidHardwareBufferPropertiesANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryGetAndroidHardwareBufferInfoANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub memory                                       : VkDeviceMemory,
}

unsafe impl Send for VkMemoryGetAndroidHardwareBufferInfoANDROID<'_> {}
unsafe impl Sync for VkMemoryGetAndroidHardwareBufferInfoANDROID<'_> {}

impl Default for VkMemoryGetAndroidHardwareBufferInfoANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkAndroidHardwareBufferFormatPropertiesANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub format                                       : VkFormat,
	pub externalFormat                               : u64,
	pub formatFeatures                               : VkFormatFeatureFlags,
	pub samplerYcbcrConversionComponents             : VkComponentMapping,
	pub suggestedYcbcrModel                          : VkSamplerYcbcrModelConversion,
	pub suggestedYcbcrRange                          : VkSamplerYcbcrRange,
	pub suggestedXChromaOffset                       : VkChromaLocation,
	pub suggestedYChromaOffset                       : VkChromaLocation,
}

unsafe impl Send for VkAndroidHardwareBufferFormatPropertiesANDROID<'_> {}
unsafe impl Sync for VkAndroidHardwareBufferFormatPropertiesANDROID<'_> {}

impl fmt::Debug for VkAndroidHardwareBufferFormatPropertiesANDROID<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAndroidHardwareBufferFormatPropertiesANDROID").finish()
	}
}

impl Default for VkAndroidHardwareBufferFormatPropertiesANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Whether this secondary command buffer may be executed during an active conditional rendering
	pub conditionalRenderingEnable                   : VkBool32,
}

unsafe impl Send for VkCommandBufferInheritanceConditionalRenderingInfoEXT<'_> {}
unsafe impl Sync for VkCommandBufferInheritanceConditionalRenderingInfoEXT<'_> {}

impl Default for VkCommandBufferInheritanceConditionalRenderingInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkExternalFormatANDROID<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub externalFormat                               : u64,
}

unsafe impl Send for VkExternalFormatANDROID<'_> {}
unsafe impl Sync for VkExternalFormatANDROID<'_> {}

impl Default for VkExternalFormatANDROID<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevice8BitStorageFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// 8-bit integer variables supported in StorageBuffer
	pub storageBuffer8BitAccess                      : VkBool32,
	/// 8-bit integer variables supported in StorageBuffer and Uniform
	pub uniformAndStorageBuffer8BitAccess            : VkBool32,
	/// 8-bit integer variables supported in PushConstant
	pub storagePushConstant8                         : VkBool32,
}

unsafe impl Send for VkPhysicalDevice8BitStorageFeatures<'_> {}
unsafe impl Sync for VkPhysicalDevice8BitStorageFeatures<'_> {}

impl Default for VkPhysicalDevice8BitStorageFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDevice8BitStorageFeaturesKHR       <'a> = VkPhysicalDevice8BitStorageFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub conditionalRendering                         : VkBool32,
	pub inheritedConditionalRendering                : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceConditionalRenderingFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceConditionalRenderingFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceConditionalRenderingFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub vulkanMemoryModel                            : VkBool32,
	pub vulkanMemoryModelDeviceScope                 : VkBool32,
	pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
}

unsafe impl Send for VkPhysicalDeviceVulkanMemoryModelFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceVulkanMemoryModelFeatures<'_> {}

impl Default for VkPhysicalDeviceVulkanMemoryModelFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceVulkanMemoryModelFeaturesKHR <'a> = VkPhysicalDeviceVulkanMemoryModelFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderAtomicInt64Features<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderBufferInt64Atomics                     : VkBool32,
	pub shaderSharedInt64Atomics                     : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderAtomicInt64Features<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderAtomicInt64Features<'_> {}

impl Default for VkPhysicalDeviceShaderAtomicInt64Features<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceShaderAtomicInt64FeaturesKHR <'a> = VkPhysicalDeviceShaderAtomicInt64Features<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderBufferFloat32Atomics                   : VkBool32,
	pub shaderBufferFloat32AtomicAdd                 : VkBool32,
	pub shaderBufferFloat64Atomics                   : VkBool32,
	pub shaderBufferFloat64AtomicAdd                 : VkBool32,
	pub shaderSharedFloat32Atomics                   : VkBool32,
	pub shaderSharedFloat32AtomicAdd                 : VkBool32,
	pub shaderSharedFloat64Atomics                   : VkBool32,
	pub shaderSharedFloat64AtomicAdd                 : VkBool32,
	pub shaderImageFloat32Atomics                    : VkBool32,
	pub shaderImageFloat32AtomicAdd                  : VkBool32,
	pub sparseImageFloat32Atomics                    : VkBool32,
	pub sparseImageFloat32AtomicAdd                  : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub vertexAttributeInstanceRateDivisor           : VkBool32,
	pub vertexAttributeInstanceRateZeroDivisor       : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkQueueFamilyCheckpointPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub checkpointExecutionStageMask                 : VkPipelineStageFlags,
}

unsafe impl Send for VkQueueFamilyCheckpointPropertiesNV<'_> {}
unsafe impl Sync for VkQueueFamilyCheckpointPropertiesNV<'_> {}

impl Default for VkQueueFamilyCheckpointPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkCheckpointDataNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub stage                                        : VkPipelineStageFlagBits,
	pub pCheckpointMarker                            : VkAnyMut<'a>,
}

unsafe impl Send for VkCheckpointDataNV<'_> {}
unsafe impl Sync for VkCheckpointDataNV<'_> {}

impl Default for VkCheckpointDataNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDepthStencilResolveProperties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// supported depth resolve modes
	pub supportedDepthResolveModes                   : VkResolveModeFlags,
	/// supported stencil resolve modes
	pub supportedStencilResolveModes                 : VkResolveModeFlags,
	/// depth and stencil resolve modes can be set independently if one of them is none
	pub independentResolveNone                       : VkBool32,
	/// depth and stencil resolve modes can be set independently
	pub independentResolve                           : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDepthStencilResolveProperties<'_> {}
unsafe impl Sync for VkPhysicalDeviceDepthStencilResolveProperties<'_> {}

impl Default for VkPhysicalDeviceDepthStencilResolveProperties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceDepthStencilResolvePropertiesKHR<'a> = VkPhysicalDeviceDepthStencilResolveProperties<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubpassDescriptionDepthStencilResolve<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// depth resolve mode
	pub depthResolveMode                             : VkResolveModeFlagBits,
	/// stencil resolve mode
	pub stencilResolveMode                           : VkResolveModeFlagBits,
	/// depth/stencil resolve attachment
	pub pDepthStencilResolveAttachment               : Option<&'a VkAttachmentReference2<'a>>,
}

unsafe impl Send for VkSubpassDescriptionDepthStencilResolve<'_> {}
unsafe impl Sync for VkSubpassDescriptionDepthStencilResolve<'_> {}

impl fmt::Debug for VkSubpassDescriptionDepthStencilResolve<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDescriptionDepthStencilResolve").finish()
	}
}

impl Default for VkSubpassDescriptionDepthStencilResolve<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkSubpassDescriptionDepthStencilResolveKHR   <'a> = VkSubpassDescriptionDepthStencilResolve<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageViewASTCDecodeModeEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub decodeMode                                   : VkFormat,
}

unsafe impl Send for VkImageViewASTCDecodeModeEXT<'_> {}
unsafe impl Sync for VkImageViewASTCDecodeModeEXT<'_> {}

impl Default for VkImageViewASTCDecodeModeEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceASTCDecodeFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub decodeModeSharedExponent                     : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceASTCDecodeFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceASTCDecodeFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceASTCDecodeFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub transformFeedback                            : VkBool32,
	pub geometryStreams                              : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceTransformFeedbackFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceTransformFeedbackFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceTransformFeedbackFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxTransformFeedbackStreams                  : u32,
	pub maxTransformFeedbackBuffers                  : u32,
	pub maxTransformFeedbackBufferSize               : VkDeviceSize,
	pub maxTransformFeedbackStreamDataSize           : u32,
	pub maxTransformFeedbackBufferDataSize           : u32,
	pub maxTransformFeedbackBufferDataStride         : u32,
	pub transformFeedbackQueries                     : VkBool32,
	pub transformFeedbackStreamsLinesTriangles       : VkBool32,
	pub transformFeedbackRasterizationStreamSelect   : VkBool32,
	pub transformFeedbackDraw                        : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceTransformFeedbackPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceTransformFeedbackPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceTransformFeedbackPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationStateStreamCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineRasterizationStateStreamCreateFlagsEXT,
	pub rasterizationStream                          : u32,
}

unsafe impl Send for VkPipelineRasterizationStateStreamCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineRasterizationStateStreamCreateInfoEXT<'_> {}

impl Default for VkPipelineRasterizationStateStreamCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub representativeFragmentTest                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub representativeFragmentTestEnable             : VkBool32,
}

unsafe impl Send for VkPipelineRepresentativeFragmentTestStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineRepresentativeFragmentTestStateCreateInfoNV<'_> {}

impl Default for VkPipelineRepresentativeFragmentTestStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceExclusiveScissorFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub exclusiveScissor                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceExclusiveScissorFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceExclusiveScissorFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceExclusiveScissorFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub exclusiveScissorCount                        : u32,
	pub pExclusiveScissors                           : *const VkRect2D,
}

unsafe impl Send for VkPipelineViewportExclusiveScissorStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineViewportExclusiveScissorStateCreateInfoNV<'_> {}

impl fmt::Debug for VkPipelineViewportExclusiveScissorStateCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportExclusiveScissorStateCreateInfoNV").finish()
	}
}

impl Default for VkPipelineViewportExclusiveScissorStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCornerSampledImageFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub cornerSampledImage                           : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceCornerSampledImageFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceCornerSampledImageFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceCornerSampledImageFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub computeDerivativeGroupQuads                  : VkBool32,
	pub computeDerivativeGroupLinear                 : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceComputeShaderDerivativesFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceComputeShaderDerivativesFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceComputeShaderDerivativesFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fragmentShaderBarycentric                    : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub imageFootprint                               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderImageFootprintFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderImageFootprintFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceShaderImageFootprintFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub dedicatedAllocationImageAliasing             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkShadingRatePaletteNV {
	pub shadingRatePaletteEntryCount                 : u32,
	pub pShadingRatePaletteEntries                   : *const VkShadingRatePaletteEntryNV,
}

unsafe impl Send for VkShadingRatePaletteNV {}
unsafe impl Sync for VkShadingRatePaletteNV {}

impl Default for VkShadingRatePaletteNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportShadingRateImageStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub shadingRateImageEnable                       : VkBool32,
	pub viewportCount                                : u32,
	pub pShadingRatePalettes                         : *const VkShadingRatePaletteNV,
}

unsafe impl Send for VkPipelineViewportShadingRateImageStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineViewportShadingRateImageStateCreateInfoNV<'_> {}

impl fmt::Debug for VkPipelineViewportShadingRateImageStateCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportShadingRateImageStateCreateInfoNV").finish()
	}
}

impl Default for VkPipelineViewportShadingRateImageStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShadingRateImageFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shadingRateImage                             : VkBool32,
	pub shadingRateCoarseSampleOrder                 : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShadingRateImageFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceShadingRateImageFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceShadingRateImageFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceShadingRateImagePropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shadingRateTexelSize                         : VkExtent2D,
	pub shadingRatePaletteSize                       : u32,
	pub shadingRateMaxCoarseSamples                  : u32,
}

unsafe impl Send for VkPhysicalDeviceShadingRateImagePropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceShadingRateImagePropertiesNV<'_> {}

impl fmt::Debug for VkPhysicalDeviceShadingRateImagePropertiesNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShadingRateImagePropertiesNV").finish()
	}
}

impl Default for VkPhysicalDeviceShadingRateImagePropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkCoarseSampleLocationNV {
	pub pixelX                                       : u32,
	pub pixelY                                       : u32,
	pub sample                                       : u32,
}

unsafe impl Send for VkCoarseSampleLocationNV {}
unsafe impl Sync for VkCoarseSampleLocationNV {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCoarseSampleOrderCustomNV {
	pub shadingRate                                  : VkShadingRatePaletteEntryNV,
	pub sampleCount                                  : u32,
	pub sampleLocationCount                          : u32,
	pub pSampleLocations                             : *const VkCoarseSampleLocationNV,
}

unsafe impl Send for VkCoarseSampleOrderCustomNV {}
unsafe impl Sync for VkCoarseSampleOrderCustomNV {}

impl fmt::Debug for VkCoarseSampleOrderCustomNV {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCoarseSampleOrderCustomNV").finish()
	}
}

impl Default for VkCoarseSampleOrderCustomNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub sampleOrderType                              : VkCoarseSampleOrderTypeNV,
	pub customSampleOrderCount                       : u32,
	pub pCustomSampleOrders                          : *const VkCoarseSampleOrderCustomNV,
}

unsafe impl Send for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV<'_> {}

impl fmt::Debug for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV").finish()
	}
}

impl Default for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMeshShaderFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub taskShader                                   : VkBool32,
	pub meshShader                                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceMeshShaderFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceMeshShaderFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceMeshShaderFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceMeshShaderPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxDrawMeshTasksCount                        : u32,
	pub maxTaskWorkGroupInvocations                  : u32,
	pub maxTaskWorkGroupSize                         : [u32;  3 as usize],
	pub maxTaskTotalMemorySize                       : u32,
	pub maxTaskOutputCount                           : u32,
	pub maxMeshWorkGroupInvocations                  : u32,
	pub maxMeshWorkGroupSize                         : [u32;  3 as usize],
	pub maxMeshTotalMemorySize                       : u32,
	pub maxMeshOutputVertices                        : u32,
	pub maxMeshOutputPrimitives                      : u32,
	pub maxMeshMultiviewViewCount                    : u32,
	pub meshOutputPerVertexGranularity               : u32,
	pub meshOutputPerPrimitiveGranularity            : u32,
}

unsafe impl Send for VkPhysicalDeviceMeshShaderPropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceMeshShaderPropertiesNV<'_> {}

impl fmt::Debug for VkPhysicalDeviceMeshShaderPropertiesNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMeshShaderPropertiesNV").finish()
	}
}

impl Default for VkPhysicalDeviceMeshShaderPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDrawMeshTasksIndirectCommandNV {
	pub taskCount                                    : u32,
	pub firstTask                                    : u32,
}

unsafe impl Send for VkDrawMeshTasksIndirectCommandNV {}
unsafe impl Sync for VkDrawMeshTasksIndirectCommandNV {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRayTracingShaderGroupCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkRayTracingShaderGroupTypeKHR,
	pub generalShader                                : u32,
	pub closestHitShader                             : u32,
	pub anyHitShader                                 : u32,
	pub intersectionShader                           : u32,
}

unsafe impl Send for VkRayTracingShaderGroupCreateInfoNV<'_> {}
unsafe impl Sync for VkRayTracingShaderGroupCreateInfoNV<'_> {}

impl Default for VkRayTracingShaderGroupCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRayTracingShaderGroupCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkRayTracingShaderGroupTypeKHR,
	pub generalShader                                : u32,
	pub closestHitShader                             : u32,
	pub anyHitShader                                 : u32,
	pub intersectionShader                           : u32,
	pub pShaderGroupCaptureReplayHandle              : Option<VkAnyRef<'a>>,
}

unsafe impl Send for VkRayTracingShaderGroupCreateInfoKHR<'_> {}
unsafe impl Sync for VkRayTracingShaderGroupCreateInfoKHR<'_> {}

impl Default for VkRayTracingShaderGroupCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Pipeline creation flags
	pub flags                                        : VkPipelineCreateFlags,
	pub stageCount                                   : u32,
	/// One entry for each active shader stage
	pub pStages                                      : *const VkPipelineShaderStageCreateInfo<'a>,
	pub groupCount                                   : u32,
	pub pGroups                                      : *const VkRayTracingShaderGroupCreateInfoNV<'a>,
	pub maxRecursionDepth                            : u32,
	/// Interface layout of the pipeline
	pub layout                                       : VkPipelineLayout,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	pub basePipelineHandle                           : VkPipeline,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
	pub basePipelineIndex                            : i32,
}

unsafe impl Send for VkRayTracingPipelineCreateInfoNV<'_> {}
unsafe impl Sync for VkRayTracingPipelineCreateInfoNV<'_> {}

impl fmt::Debug for VkRayTracingPipelineCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingPipelineCreateInfoNV").finish()
	}
}

impl Default for VkRayTracingPipelineCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Pipeline creation flags
	pub flags                                        : VkPipelineCreateFlags,
	pub stageCount                                   : u32,
	/// One entry for each active shader stage
	pub pStages                                      : *const VkPipelineShaderStageCreateInfo<'a>,
	pub groupCount                                   : u32,
	pub pGroups                                      : *const VkRayTracingShaderGroupCreateInfoKHR<'a>,
	pub maxPipelineRayRecursionDepth                 : u32,
	pub pLibraryInfo                                 : Option<&'a VkPipelineLibraryCreateInfoKHR<'a>>,
	pub pLibraryInterface                            : Option<&'a VkRayTracingPipelineInterfaceCreateInfoKHR<'a>>,
	pub pDynamicState                                : Option<&'a VkPipelineDynamicStateCreateInfo<'a>>,
	/// Interface layout of the pipeline
	pub layout                                       : VkPipelineLayout,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	pub basePipelineHandle                           : VkPipeline,
	/// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
	pub basePipelineIndex                            : i32,
}

unsafe impl Send for VkRayTracingPipelineCreateInfoKHR<'_> {}
unsafe impl Sync for VkRayTracingPipelineCreateInfoKHR<'_> {}

impl fmt::Debug for VkRayTracingPipelineCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingPipelineCreateInfoKHR").finish()
	}
}

impl Default for VkRayTracingPipelineCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkGeometryTrianglesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub vertexData                                   : VkBuffer,
	pub vertexOffset                                 : VkDeviceSize,
	pub vertexCount                                  : u32,
	pub vertexStride                                 : VkDeviceSize,
	pub vertexFormat                                 : VkFormat,
	pub indexData                                    : VkBuffer,
	pub indexOffset                                  : VkDeviceSize,
	pub indexCount                                   : u32,
	pub indexType                                    : VkIndexType,
	/// Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
	pub transformData                                : VkBuffer,
	pub transformOffset                              : VkDeviceSize,
}

unsafe impl Send for VkGeometryTrianglesNV<'_> {}
unsafe impl Sync for VkGeometryTrianglesNV<'_> {}

impl Default for VkGeometryTrianglesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkGeometryAABBNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub aabbData                                     : VkBuffer,
	pub numAABBs                                     : u32,
	/// Stride in bytes between AABBs
	pub stride                                       : u32,
	/// Offset in bytes of the first AABB in aabbData
	pub offset                                       : VkDeviceSize,
}

unsafe impl Send for VkGeometryAABBNV<'_> {}
unsafe impl Sync for VkGeometryAABBNV<'_> {}

impl Default for VkGeometryAABBNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeometryDataNV<'a> {
	pub triangles                                    : VkGeometryTrianglesNV<'a>,
	pub aabbs                                        : VkGeometryAABBNV<'a>,
}

unsafe impl Send for VkGeometryDataNV<'_> {}
unsafe impl Sync for VkGeometryDataNV<'_> {}

impl fmt::Debug for VkGeometryDataNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkGeometryDataNV").finish()
	}
}

impl Default for VkGeometryDataNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkGeometryNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub geometryType                                 : VkGeometryTypeKHR,
	pub geometry                                     : VkGeometryDataNV<'a>,
	pub flags                                        : VkGeometryFlagsKHR,
}

unsafe impl Send for VkGeometryNV<'_> {}
unsafe impl Sync for VkGeometryNV<'_> {}

impl fmt::Debug for VkGeometryNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkGeometryNV").finish()
	}
}

impl Default for VkGeometryNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkAccelerationStructureTypeNV,
	pub flags                                        : VkBuildAccelerationStructureFlagsNV,
	pub instanceCount                                : u32,
	pub geometryCount                                : u32,
	pub pGeometries                                  : *const VkGeometryNV<'a>,
}

unsafe impl Send for VkAccelerationStructureInfoNV<'_> {}
unsafe impl Sync for VkAccelerationStructureInfoNV<'_> {}

impl fmt::Debug for VkAccelerationStructureInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureInfoNV").finish()
	}
}

impl Default for VkAccelerationStructureInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub compactedSize                                : VkDeviceSize,
	pub info                                         : VkAccelerationStructureInfoNV<'a>,
}

unsafe impl Send for VkAccelerationStructureCreateInfoNV<'_> {}
unsafe impl Sync for VkAccelerationStructureCreateInfoNV<'_> {}

impl fmt::Debug for VkAccelerationStructureCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureCreateInfoNV").finish()
	}
}

impl Default for VkAccelerationStructureCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindAccelerationStructureMemoryInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub accelerationStructure                        : VkAccelerationStructureNV,
	pub memory                                       : VkDeviceMemory,
	pub memoryOffset                                 : VkDeviceSize,
	pub deviceIndexCount                             : u32,
	pub pDeviceIndices                               : *const u32,
}

unsafe impl Send for VkBindAccelerationStructureMemoryInfoNV<'_> {}
unsafe impl Sync for VkBindAccelerationStructureMemoryInfoNV<'_> {}

impl Default for VkBindAccelerationStructureMemoryInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWriteDescriptorSetAccelerationStructureKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub accelerationStructureCount                   : u32,
	pub pAccelerationStructures                      : *const VkAccelerationStructureKHR,
}

unsafe impl Send for VkWriteDescriptorSetAccelerationStructureKHR<'_> {}
unsafe impl Sync for VkWriteDescriptorSetAccelerationStructureKHR<'_> {}

impl Default for VkWriteDescriptorSetAccelerationStructureKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWriteDescriptorSetAccelerationStructureNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub accelerationStructureCount                   : u32,
	pub pAccelerationStructures                      : *const VkAccelerationStructureNV,
}

unsafe impl Send for VkWriteDescriptorSetAccelerationStructureNV<'_> {}
unsafe impl Sync for VkWriteDescriptorSetAccelerationStructureNV<'_> {}

impl Default for VkWriteDescriptorSetAccelerationStructureNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAccelerationStructureMemoryRequirementsInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkAccelerationStructureMemoryRequirementsTypeNV,
	pub accelerationStructure                        : VkAccelerationStructureNV,
}

unsafe impl Send for VkAccelerationStructureMemoryRequirementsInfoNV<'_> {}
unsafe impl Sync for VkAccelerationStructureMemoryRequirementsInfoNV<'_> {}

impl Default for VkAccelerationStructureMemoryRequirementsInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub accelerationStructure                        : VkBool32,
	pub accelerationStructureCaptureReplay           : VkBool32,
	pub accelerationStructureIndirectBuild           : VkBool32,
	pub accelerationStructureHostCommands            : VkBool32,
	pub descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32,
}

unsafe impl Send for VkPhysicalDeviceAccelerationStructureFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceAccelerationStructureFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceAccelerationStructureFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub rayTracingPipeline                           : VkBool32,
	pub rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32,
	pub rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32,
	pub rayTracingPipelineTraceRaysIndirect          : VkBool32,
	pub rayTraversalPrimitiveCulling                 : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceRayTracingPipelineFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceRayTracingPipelineFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceRayTracingPipelineFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRayQueryFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub rayQuery                                     : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceRayQueryFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceRayQueryFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceRayQueryFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxGeometryCount                             : u64,
	pub maxInstanceCount                             : u64,
	pub maxPrimitiveCount                            : u64,
	pub maxPerStageDescriptorAccelerationStructures  : u32,
	pub maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32,
	pub maxDescriptorSetAccelerationStructures       : u32,
	pub maxDescriptorSetUpdateAfterBindAccelerationStructures: u32,
	pub minAccelerationStructureScratchOffsetAlignment: u32,
}

unsafe impl Send for VkPhysicalDeviceAccelerationStructurePropertiesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceAccelerationStructurePropertiesKHR<'_> {}

impl Default for VkPhysicalDeviceAccelerationStructurePropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderGroupHandleSize                        : u32,
	pub maxRayRecursionDepth                         : u32,
	pub maxShaderGroupStride                         : u32,
	pub shaderGroupBaseAlignment                     : u32,
	pub shaderGroupHandleCaptureReplaySize           : u32,
	pub maxRayDispatchInvocationCount                : u32,
	pub shaderGroupHandleAlignment                   : u32,
	pub maxRayHitAttributeSize                       : u32,
}

unsafe impl Send for VkPhysicalDeviceRayTracingPipelinePropertiesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceRayTracingPipelinePropertiesKHR<'_> {}

impl Default for VkPhysicalDeviceRayTracingPipelinePropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRayTracingPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderGroupHandleSize                        : u32,
	pub maxRecursionDepth                            : u32,
	pub maxShaderGroupStride                         : u32,
	pub shaderGroupBaseAlignment                     : u32,
	pub maxGeometryCount                             : u64,
	pub maxInstanceCount                             : u64,
	pub maxTriangleCount                             : u64,
	pub maxDescriptorSetAccelerationStructures       : u32,
}

unsafe impl Send for VkPhysicalDeviceRayTracingPropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceRayTracingPropertiesNV<'_> {}

impl Default for VkPhysicalDeviceRayTracingPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkStridedDeviceAddressRegionKHR {
	pub deviceAddress                                : VkDeviceAddress,
	pub stride                                       : VkDeviceSize,
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkStridedDeviceAddressRegionKHR {}
unsafe impl Sync for VkStridedDeviceAddressRegionKHR {}


#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkTraceRaysIndirectCommandKHR {
	pub width                                        : u32,
	pub height                                       : u32,
	pub depth                                        : u32,
}

unsafe impl Send for VkTraceRaysIndirectCommandKHR {}
unsafe impl Sync for VkTraceRaysIndirectCommandKHR {}


#[repr(C)]
#[derive()]
pub struct VkDrmFormatModifierPropertiesListEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub drmFormatModifierCount                       : u32,
	pub pDrmFormatModifierProperties                 : *mut VkDrmFormatModifierPropertiesEXT,
}

unsafe impl Send for VkDrmFormatModifierPropertiesListEXT<'_> {}
unsafe impl Sync for VkDrmFormatModifierPropertiesListEXT<'_> {}

impl fmt::Debug for VkDrmFormatModifierPropertiesListEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDrmFormatModifierPropertiesListEXT").finish()
	}
}

impl Default for VkDrmFormatModifierPropertiesListEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkDrmFormatModifierPropertiesEXT {
	pub drmFormatModifier                            : u64,
	pub drmFormatModifierPlaneCount                  : u32,
	pub drmFormatModifierTilingFeatures              : VkFormatFeatureFlags,
}

unsafe impl Send for VkDrmFormatModifierPropertiesEXT {}
unsafe impl Sync for VkDrmFormatModifierPropertiesEXT {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub drmFormatModifier                            : u64,
	pub sharingMode                                  : VkSharingMode,
	pub queueFamilyIndexCount                        : u32,
	pub pQueueFamilyIndices                          : *const u32,
}

unsafe impl Send for VkPhysicalDeviceImageDrmFormatModifierInfoEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceImageDrmFormatModifierInfoEXT<'_> {}

impl Default for VkPhysicalDeviceImageDrmFormatModifierInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageDrmFormatModifierListCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub drmFormatModifierCount                       : u32,
	pub pDrmFormatModifiers                          : *const u64,
}

unsafe impl Send for VkImageDrmFormatModifierListCreateInfoEXT<'_> {}
unsafe impl Sync for VkImageDrmFormatModifierListCreateInfoEXT<'_> {}

impl Default for VkImageDrmFormatModifierListCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub drmFormatModifier                            : u64,
	pub drmFormatModifierPlaneCount                  : u32,
	pub pPlaneLayouts                                : *const VkSubresourceLayout,
}

unsafe impl Send for VkImageDrmFormatModifierExplicitCreateInfoEXT<'_> {}
unsafe impl Sync for VkImageDrmFormatModifierExplicitCreateInfoEXT<'_> {}

impl fmt::Debug for VkImageDrmFormatModifierExplicitCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageDrmFormatModifierExplicitCreateInfoEXT").finish()
	}
}

impl Default for VkImageDrmFormatModifierExplicitCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkImageDrmFormatModifierPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub drmFormatModifier                            : u64,
}

unsafe impl Send for VkImageDrmFormatModifierPropertiesEXT<'_> {}
unsafe impl Sync for VkImageDrmFormatModifierPropertiesEXT<'_> {}

impl Default for VkImageDrmFormatModifierPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageStencilUsageCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub stencilUsage                                 : VkImageUsageFlags,
}

unsafe impl Send for VkImageStencilUsageCreateInfo<'_> {}
unsafe impl Sync for VkImageStencilUsageCreateInfo<'_> {}

impl Default for VkImageStencilUsageCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkImageStencilUsageCreateInfoEXT             <'a> = VkImageStencilUsageCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceMemoryOverallocationCreateInfoAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub overallocationBehavior                       : VkMemoryOverallocationBehaviorAMD,
}

unsafe impl Send for VkDeviceMemoryOverallocationCreateInfoAMD<'_> {}
unsafe impl Sync for VkDeviceMemoryOverallocationCreateInfoAMD<'_> {}

impl Default for VkDeviceMemoryOverallocationCreateInfoAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fragmentDensityMap                           : VkBool32,
	pub fragmentDensityMapDynamic                    : VkBool32,
	pub fragmentDensityMapNonSubsampledImages        : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentDensityMapFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentDensityMapFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceFragmentDensityMapFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fragmentDensityMapDeferred                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub minFragmentDensityTexelSize                  : VkExtent2D,
	pub maxFragmentDensityTexelSize                  : VkExtent2D,
	pub fragmentDensityInvocations                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentDensityMapPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentDensityMapPropertiesEXT<'_> {}

impl fmt::Debug for VkPhysicalDeviceFragmentDensityMapPropertiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapPropertiesEXT").finish()
	}
}

impl Default for VkPhysicalDeviceFragmentDensityMapPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub subsampledLoads                              : VkBool32,
	pub subsampledCoarseReconstructionEarlyAccess    : VkBool32,
	pub maxSubsampledArrayLayers                     : u32,
	pub maxDescriptorSetSubsampledSamplers           : u32,
}

unsafe impl Send for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderPassFragmentDensityMapCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub fragmentDensityMapAttachment                 : VkAttachmentReference,
}

unsafe impl Send for VkRenderPassFragmentDensityMapCreateInfoEXT<'_> {}
unsafe impl Sync for VkRenderPassFragmentDensityMapCreateInfoEXT<'_> {}

impl fmt::Debug for VkRenderPassFragmentDensityMapCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassFragmentDensityMapCreateInfoEXT").finish()
	}
}

impl Default for VkRenderPassFragmentDensityMapCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub scalarBlockLayout                            : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceScalarBlockLayoutFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceScalarBlockLayoutFeatures<'_> {}

impl Default for VkPhysicalDeviceScalarBlockLayoutFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceScalarBlockLayoutFeaturesEXT <'a> = VkPhysicalDeviceScalarBlockLayoutFeatures<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSurfaceProtectedCapabilitiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Represents if surface can be protected
	pub supportsProtected                            : VkBool32,
}

unsafe impl Send for VkSurfaceProtectedCapabilitiesKHR<'_> {}
unsafe impl Sync for VkSurfaceProtectedCapabilitiesKHR<'_> {}

impl Default for VkSurfaceProtectedCapabilitiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub uniformBufferStandardLayout                  : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceUniformBufferStandardLayoutFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceUniformBufferStandardLayoutFeatures<'_> {}

impl Default for VkPhysicalDeviceUniformBufferStandardLayoutFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR<'a> = VkPhysicalDeviceUniformBufferStandardLayoutFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub depthClipEnable                              : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDepthClipEnableFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceDepthClipEnableFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceDepthClipEnableFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Reserved
	pub flags                                        : VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
	pub depthClipEnable                              : VkBool32,
}

unsafe impl Send for VkPipelineRasterizationDepthClipStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineRasterizationDepthClipStateCreateInfoEXT<'_> {}

impl Default for VkPipelineRasterizationDepthClipStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub heapBudget                                   : [VkDeviceSize;  VK_MAX_MEMORY_HEAPS as usize],
	pub heapUsage                                    : [VkDeviceSize;  VK_MAX_MEMORY_HEAPS as usize],
}

unsafe impl Send for VkPhysicalDeviceMemoryBudgetPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceMemoryBudgetPropertiesEXT<'_> {}

impl fmt::Debug for VkPhysicalDeviceMemoryBudgetPropertiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryBudgetPropertiesEXT").finish()
	}
}

impl Default for VkPhysicalDeviceMemoryBudgetPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub memoryPriority                               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceMemoryPriorityFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceMemoryPriorityFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceMemoryPriorityFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryPriorityAllocateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub priority                                     : f32,
}

unsafe impl Send for VkMemoryPriorityAllocateInfoEXT<'_> {}
unsafe impl Sync for VkMemoryPriorityAllocateInfoEXT<'_> {}

impl Default for VkMemoryPriorityAllocateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub bufferDeviceAddress                          : VkBool32,
	pub bufferDeviceAddressCaptureReplay             : VkBool32,
	pub bufferDeviceAddressMultiDevice               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceBufferDeviceAddressFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceBufferDeviceAddressFeatures<'_> {}

impl Default for VkPhysicalDeviceBufferDeviceAddressFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceBufferDeviceAddressFeaturesKHR<'a> = VkPhysicalDeviceBufferDeviceAddressFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub bufferDeviceAddress                          : VkBool32,
	pub bufferDeviceAddressCaptureReplay             : VkBool32,
	pub bufferDeviceAddressMultiDevice               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceBufferAddressFeaturesEXT     <'a> = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferDeviceAddressInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub buffer                                       : VkBuffer,
}

unsafe impl Send for VkBufferDeviceAddressInfo<'_> {}
unsafe impl Sync for VkBufferDeviceAddressInfo<'_> {}

impl Default for VkBufferDeviceAddressInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBufferDeviceAddressInfoKHR                 <'a> = VkBufferDeviceAddressInfo<'a>;

pub type VkBufferDeviceAddressInfoEXT                 <'a> = VkBufferDeviceAddressInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferOpaqueCaptureAddressCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub opaqueCaptureAddress                         : u64,
}

unsafe impl Send for VkBufferOpaqueCaptureAddressCreateInfo<'_> {}
unsafe impl Sync for VkBufferOpaqueCaptureAddressCreateInfo<'_> {}

impl Default for VkBufferOpaqueCaptureAddressCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkBufferOpaqueCaptureAddressCreateInfoKHR    <'a> = VkBufferOpaqueCaptureAddressCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferDeviceAddressCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub deviceAddress                                : VkDeviceAddress,
}

unsafe impl Send for VkBufferDeviceAddressCreateInfoEXT<'_> {}
unsafe impl Sync for VkBufferDeviceAddressCreateInfoEXT<'_> {}

impl Default for VkBufferDeviceAddressCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceImageViewImageFormatInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub imageViewType                                : VkImageViewType,
}

unsafe impl Send for VkPhysicalDeviceImageViewImageFormatInfoEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceImageViewImageFormatInfoEXT<'_> {}

impl Default for VkPhysicalDeviceImageViewImageFormatInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkFilterCubicImageViewImageFormatPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
	pub filterCubic                                  : VkBool32,
	/// The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
	pub filterCubicMinmax                            : VkBool32,
}

unsafe impl Send for VkFilterCubicImageViewImageFormatPropertiesEXT<'_> {}
unsafe impl Sync for VkFilterCubicImageViewImageFormatPropertiesEXT<'_> {}

impl Default for VkFilterCubicImageViewImageFormatPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceImagelessFramebufferFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub imagelessFramebuffer                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceImagelessFramebufferFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceImagelessFramebufferFeatures<'_> {}

impl Default for VkPhysicalDeviceImagelessFramebufferFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceImagelessFramebufferFeaturesKHR<'a> = VkPhysicalDeviceImagelessFramebufferFeatures<'a>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFramebufferAttachmentsCreateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub attachmentImageInfoCount                     : u32,
	pub pAttachmentImageInfos                        : *const VkFramebufferAttachmentImageInfo<'a>,
}

unsafe impl Send for VkFramebufferAttachmentsCreateInfo<'_> {}
unsafe impl Sync for VkFramebufferAttachmentsCreateInfo<'_> {}

impl fmt::Debug for VkFramebufferAttachmentsCreateInfo<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkFramebufferAttachmentsCreateInfo").finish()
	}
}

impl Default for VkFramebufferAttachmentsCreateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkFramebufferAttachmentsCreateInfoKHR        <'a> = VkFramebufferAttachmentsCreateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFramebufferAttachmentImageInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Image creation flags
	pub flags                                        : VkImageCreateFlags,
	/// Image usage flags
	pub usage                                        : VkImageUsageFlags,
	pub width                                        : u32,
	pub height                                       : u32,
	pub layerCount                                   : u32,
	pub viewFormatCount                              : u32,
	pub pViewFormats                                 : *const VkFormat,
}

unsafe impl Send for VkFramebufferAttachmentImageInfo<'_> {}
unsafe impl Sync for VkFramebufferAttachmentImageInfo<'_> {}

impl Default for VkFramebufferAttachmentImageInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkFramebufferAttachmentImageInfoKHR          <'a> = VkFramebufferAttachmentImageInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRenderPassAttachmentBeginInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub attachmentCount                              : u32,
	pub pAttachments                                 : *const VkImageView,
}

unsafe impl Send for VkRenderPassAttachmentBeginInfo<'_> {}
unsafe impl Sync for VkRenderPassAttachmentBeginInfo<'_> {}

impl Default for VkRenderPassAttachmentBeginInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkRenderPassAttachmentBeginInfoKHR           <'a> = VkRenderPassAttachmentBeginInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub textureCompressionASTC_HDR                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub cooperativeMatrix                            : VkBool32,
	pub cooperativeMatrixRobustBufferAccess          : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceCooperativeMatrixFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceCooperativeMatrixFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceCooperativeMatrixFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub cooperativeMatrixSupportedStages             : VkShaderStageFlags,
}

unsafe impl Send for VkPhysicalDeviceCooperativeMatrixPropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceCooperativeMatrixPropertiesNV<'_> {}

impl Default for VkPhysicalDeviceCooperativeMatrixPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkCooperativeMatrixPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub MSize                                        : u32,
	pub NSize                                        : u32,
	pub KSize                                        : u32,
	pub AType                                        : VkComponentTypeNV,
	pub BType                                        : VkComponentTypeNV,
	pub CType                                        : VkComponentTypeNV,
	pub DType                                        : VkComponentTypeNV,
	pub scope                                        : VkScopeNV,
}

unsafe impl Send for VkCooperativeMatrixPropertiesNV<'_> {}
unsafe impl Sync for VkCooperativeMatrixPropertiesNV<'_> {}

impl Default for VkCooperativeMatrixPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub ycbcrImageArrays                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageViewHandleInfoNVX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub imageView                                    : VkImageView,
	pub descriptorType                               : VkDescriptorType,
	pub sampler                                      : VkSampler,
}

unsafe impl Send for VkImageViewHandleInfoNVX<'_> {}
unsafe impl Sync for VkImageViewHandleInfoNVX<'_> {}

impl Default for VkImageViewHandleInfoNVX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkImageViewAddressPropertiesNVX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub deviceAddress                                : VkDeviceAddress,
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkImageViewAddressPropertiesNVX<'_> {}
unsafe impl Sync for VkImageViewAddressPropertiesNVX<'_> {}

impl Default for VkImageViewAddressPropertiesNVX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPresentFrameTokenGGP<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub frameToken                                   : GgpFrameToken,
}

unsafe impl Send for VkPresentFrameTokenGGP<'_> {}
unsafe impl Sync for VkPresentFrameTokenGGP<'_> {}

impl fmt::Debug for VkPresentFrameTokenGGP<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPresentFrameTokenGGP").finish()
	}
}

impl Default for VkPresentFrameTokenGGP<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkPipelineCreationFeedbackEXT {
	pub flags                                        : VkPipelineCreationFeedbackFlagsEXT,
	pub duration                                     : u64,
}

unsafe impl Send for VkPipelineCreationFeedbackEXT {}
unsafe impl Sync for VkPipelineCreationFeedbackEXT {}


#[repr(C)]
#[derive()]
pub struct VkPipelineCreationFeedbackCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Output pipeline creation feedback.
	pub pPipelineCreationFeedback                    : &'a mut VkPipelineCreationFeedbackEXT,
	pub pipelineStageCreationFeedbackCount           : u32,
	/// One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
	pub pPipelineStageCreationFeedbacks              : *mut VkPipelineCreationFeedbackEXT,
}

unsafe impl Send for VkPipelineCreationFeedbackCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineCreationFeedbackCreateInfoEXT<'_> {}

impl fmt::Debug for VkPipelineCreationFeedbackCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCreationFeedbackCreateInfoEXT").finish()
	}
}

impl Default for VkPipelineCreationFeedbackCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkSurfaceFullScreenExclusiveInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fullScreenExclusive                          : VkFullScreenExclusiveEXT,
}

unsafe impl Send for VkSurfaceFullScreenExclusiveInfoEXT<'_> {}
unsafe impl Sync for VkSurfaceFullScreenExclusiveInfoEXT<'_> {}

impl Default for VkSurfaceFullScreenExclusiveInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkSurfaceFullScreenExclusiveWin32InfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub hmonitor                                     : HMONITOR,
}

unsafe impl Send for VkSurfaceFullScreenExclusiveWin32InfoEXT<'_> {}
unsafe impl Sync for VkSurfaceFullScreenExclusiveWin32InfoEXT<'_> {}

impl fmt::Debug for VkSurfaceFullScreenExclusiveWin32InfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceFullScreenExclusiveWin32InfoEXT").finish()
	}
}

impl Default for VkSurfaceFullScreenExclusiveWin32InfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkSurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fullScreenExclusiveSupported                 : VkBool32,
}

unsafe impl Send for VkSurfaceCapabilitiesFullScreenExclusiveEXT<'_> {}
unsafe impl Sync for VkSurfaceCapabilitiesFullScreenExclusiveEXT<'_> {}

impl Default for VkSurfaceCapabilitiesFullScreenExclusiveEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePerformanceQueryFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// performance counters supported in query pools
	pub performanceCounterQueryPools                 : VkBool32,
	/// performance counters from multiple query pools can be accessed in the same primary command buffer
	pub performanceCounterMultipleQueryPools         : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePerformanceQueryFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDevicePerformanceQueryFeaturesKHR<'_> {}

impl Default for VkPhysicalDevicePerformanceQueryFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePerformanceQueryPropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
	pub allowCommandBufferQueryCopies                : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePerformanceQueryPropertiesKHR<'_> {}
unsafe impl Sync for VkPhysicalDevicePerformanceQueryPropertiesKHR<'_> {}

impl Default for VkPhysicalDevicePerformanceQueryPropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPerformanceCounterKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub unit                                         : VkPerformanceCounterUnitKHR,
	pub scope                                        : VkPerformanceCounterScopeKHR,
	pub storage                                      : VkPerformanceCounterStorageKHR,
	pub uuid                                         : [u8;  VK_UUID_SIZE as usize],
}

unsafe impl Send for VkPerformanceCounterKHR<'_> {}
unsafe impl Sync for VkPerformanceCounterKHR<'_> {}

impl fmt::Debug for VkPerformanceCounterKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterKHR").finish()
	}
}

impl Default for VkPerformanceCounterKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPerformanceCounterDescriptionKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub flags                                        : VkPerformanceCounterDescriptionFlagsKHR,
	pub name                                         : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub category                                     : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub description                                  : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
}

unsafe impl Send for VkPerformanceCounterDescriptionKHR<'_> {}
unsafe impl Sync for VkPerformanceCounterDescriptionKHR<'_> {}

impl fmt::Debug for VkPerformanceCounterDescriptionKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterDescriptionKHR").finish()
	}
}

impl Default for VkPerformanceCounterDescriptionKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkQueryPoolPerformanceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub queueFamilyIndex                             : u32,
	pub counterIndexCount                            : u32,
	pub pCounterIndices                              : *const u32,
}

unsafe impl Send for VkQueryPoolPerformanceCreateInfoKHR<'_> {}
unsafe impl Sync for VkQueryPoolPerformanceCreateInfoKHR<'_> {}

impl Default for VkQueryPoolPerformanceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

/// // Union of all the possible return types a counter result could return
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPerformanceCounterResultKHR {
	pub int32                                        : i32,
	pub int64                                        : i64,
	pub uint32                                       : u32,
	pub uint64                                       : u64,
	pub float32                                      : f32,
	pub float64                                      : f64,
}

unsafe impl Send for VkPerformanceCounterResultKHR {}
unsafe impl Sync for VkPerformanceCounterResultKHR {}

impl fmt::Debug for VkPerformanceCounterResultKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterResultKHR").finish()
	}
}

impl Default for VkPerformanceCounterResultKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAcquireProfilingLockInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Acquire profiling lock flags
	pub flags                                        : VkAcquireProfilingLockFlagsKHR,
	pub timeout                                      : u64,
}

unsafe impl Send for VkAcquireProfilingLockInfoKHR<'_> {}
unsafe impl Sync for VkAcquireProfilingLockInfoKHR<'_> {}

impl Default for VkAcquireProfilingLockInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPerformanceQuerySubmitInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Index for which counter pass to submit
	pub counterPassIndex                             : u32,
}

unsafe impl Send for VkPerformanceQuerySubmitInfoKHR<'_> {}
unsafe impl Sync for VkPerformanceQuerySubmitInfoKHR<'_> {}

impl Default for VkPerformanceQuerySubmitInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkHeadlessSurfaceCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkHeadlessSurfaceCreateFlagsEXT,
}

unsafe impl Send for VkHeadlessSurfaceCreateInfoEXT<'_> {}
unsafe impl Sync for VkHeadlessSurfaceCreateInfoEXT<'_> {}

impl Default for VkHeadlessSurfaceCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub coverageReductionMode                        : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceCoverageReductionModeFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceCoverageReductionModeFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceCoverageReductionModeFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineCoverageReductionStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkPipelineCoverageReductionStateCreateFlagsNV,
	pub coverageReductionMode                        : VkCoverageReductionModeNV,
}

unsafe impl Send for VkPipelineCoverageReductionStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineCoverageReductionStateCreateInfoNV<'_> {}

impl Default for VkPipelineCoverageReductionStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkFramebufferMixedSamplesCombinationNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub coverageReductionMode                        : VkCoverageReductionModeNV,
	pub rasterizationSamples                         : VkSampleCountFlagBits,
	pub depthStencilSamples                          : VkSampleCountFlags,
	pub colorSamples                                 : VkSampleCountFlags,
}

unsafe impl Send for VkFramebufferMixedSamplesCombinationNV<'_> {}
unsafe impl Sync for VkFramebufferMixedSamplesCombinationNV<'_> {}

impl Default for VkFramebufferMixedSamplesCombinationNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderIntegerFunctions2                      : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'_> {}

impl Default for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPerformanceValueDataINTEL {
	pub value32                                      : u32,
	pub value64                                      : u64,
	pub valueFloat                                   : f32,
	pub valueBool                                    : VkBool32,
	pub valueString                                  : *const u8,
}

unsafe impl Send for VkPerformanceValueDataINTEL {}
unsafe impl Sync for VkPerformanceValueDataINTEL {}

impl fmt::Debug for VkPerformanceValueDataINTEL {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceValueDataINTEL").finish()
	}
}

impl Default for VkPerformanceValueDataINTEL {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceValueINTEL {
	pub r#type                                       : VkPerformanceValueTypeINTEL,
	pub data                                         : VkPerformanceValueDataINTEL,
}

unsafe impl Send for VkPerformanceValueINTEL {}
unsafe impl Sync for VkPerformanceValueINTEL {}

impl fmt::Debug for VkPerformanceValueINTEL {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceValueINTEL").finish()
	}
}

impl Default for VkPerformanceValueINTEL {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkInitializePerformanceApiInfoINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pUserData                                    : Option<VkAnyMut<'a>>,
}

unsafe impl Send for VkInitializePerformanceApiInfoINTEL<'_> {}
unsafe impl Sync for VkInitializePerformanceApiInfoINTEL<'_> {}

impl Default for VkInitializePerformanceApiInfoINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkQueryPoolPerformanceQueryCreateInfoINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub performanceCountersSampling                  : VkQueryPoolSamplingModeINTEL,
}

unsafe impl Send for VkQueryPoolPerformanceQueryCreateInfoINTEL<'_> {}
unsafe impl Sync for VkQueryPoolPerformanceQueryCreateInfoINTEL<'_> {}

impl Default for VkQueryPoolPerformanceQueryCreateInfoINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkQueryPoolCreateInfoINTEL                   <'a> = VkQueryPoolPerformanceQueryCreateInfoINTEL<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPerformanceMarkerInfoINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub marker                                       : u64,
}

unsafe impl Send for VkPerformanceMarkerInfoINTEL<'_> {}
unsafe impl Sync for VkPerformanceMarkerInfoINTEL<'_> {}

impl Default for VkPerformanceMarkerInfoINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPerformanceStreamMarkerInfoINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub marker                                       : u32,
}

unsafe impl Send for VkPerformanceStreamMarkerInfoINTEL<'_> {}
unsafe impl Sync for VkPerformanceStreamMarkerInfoINTEL<'_> {}

impl Default for VkPerformanceStreamMarkerInfoINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPerformanceOverrideInfoINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkPerformanceOverrideTypeINTEL,
	pub enable                                       : VkBool32,
	pub parameter                                    : u64,
}

unsafe impl Send for VkPerformanceOverrideInfoINTEL<'_> {}
unsafe impl Sync for VkPerformanceOverrideInfoINTEL<'_> {}

impl Default for VkPerformanceOverrideInfoINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPerformanceConfigurationAcquireInfoINTEL<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkPerformanceConfigurationTypeINTEL,
}

unsafe impl Send for VkPerformanceConfigurationAcquireInfoINTEL<'_> {}
unsafe impl Sync for VkPerformanceConfigurationAcquireInfoINTEL<'_> {}

impl Default for VkPerformanceConfigurationAcquireInfoINTEL<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderClockFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderSubgroupClock                          : VkBool32,
	pub shaderDeviceClock                            : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderClockFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderClockFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceShaderClockFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub indexTypeUint8                               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceIndexTypeUint8FeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceIndexTypeUint8FeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceIndexTypeUint8FeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderSMCount                                : u32,
	pub shaderWarpsPerSM                             : u32,
}

unsafe impl Send for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV<'_> {}

impl Default for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderSMBuiltins                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	/// Pointer to next structure
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fragmentShaderSampleInterlock                : VkBool32,
	pub fragmentShaderPixelInterlock                 : VkBool32,
	pub fragmentShaderShadingRateInterlock           : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub separateDepthStencilLayouts                  : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures<'_> {}
unsafe impl Sync for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures<'_> {}

impl Default for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR<'a> = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkAttachmentReferenceStencilLayout<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub stencilLayout                                : VkImageLayout,
}

unsafe impl Send for VkAttachmentReferenceStencilLayout<'_> {}
unsafe impl Sync for VkAttachmentReferenceStencilLayout<'_> {}

impl Default for VkAttachmentReferenceStencilLayout<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkAttachmentReferenceStencilLayoutKHR        <'a> = VkAttachmentReferenceStencilLayout<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkAttachmentDescriptionStencilLayout<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub stencilInitialLayout                         : VkImageLayout,
	pub stencilFinalLayout                           : VkImageLayout,
}

unsafe impl Send for VkAttachmentDescriptionStencilLayout<'_> {}
unsafe impl Sync for VkAttachmentDescriptionStencilLayout<'_> {}

impl Default for VkAttachmentDescriptionStencilLayout<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkAttachmentDescriptionStencilLayoutKHR      <'a> = VkAttachmentDescriptionStencilLayout<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub pipelineExecutableInfo                       : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'_> {}

impl Default for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pipeline                                     : VkPipeline,
}

unsafe impl Send for VkPipelineInfoKHR<'_> {}
unsafe impl Sync for VkPipelineInfoKHR<'_> {}

impl Default for VkPipelineInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPipelineExecutablePropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub stages                                       : VkShaderStageFlags,
	pub name                                         : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub description                                  : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub subgroupSize                                 : u32,
}

unsafe impl Send for VkPipelineExecutablePropertiesKHR<'_> {}
unsafe impl Sync for VkPipelineExecutablePropertiesKHR<'_> {}

impl fmt::Debug for VkPipelineExecutablePropertiesKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutablePropertiesKHR").finish()
	}
}

impl Default for VkPipelineExecutablePropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineExecutableInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pipeline                                     : VkPipeline,
	pub executableIndex                              : u32,
}

unsafe impl Send for VkPipelineExecutableInfoKHR<'_> {}
unsafe impl Sync for VkPipelineExecutableInfoKHR<'_> {}

impl Default for VkPipelineExecutableInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPipelineExecutableStatisticValueKHR {
	pub b32                                          : VkBool32,
	pub i64                                          : i64,
	pub u64                                          : u64,
	pub f64                                          : f64,
}

unsafe impl Send for VkPipelineExecutableStatisticValueKHR {}
unsafe impl Sync for VkPipelineExecutableStatisticValueKHR {}

impl fmt::Debug for VkPipelineExecutableStatisticValueKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableStatisticValueKHR").finish()
	}
}

impl Default for VkPipelineExecutableStatisticValueKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPipelineExecutableStatisticKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub name                                         : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub description                                  : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub format                                       : VkPipelineExecutableStatisticFormatKHR,
	pub value                                        : VkPipelineExecutableStatisticValueKHR,
}

unsafe impl Send for VkPipelineExecutableStatisticKHR<'_> {}
unsafe impl Sync for VkPipelineExecutableStatisticKHR<'_> {}

impl fmt::Debug for VkPipelineExecutableStatisticKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableStatisticKHR").finish()
	}
}

impl Default for VkPipelineExecutableStatisticKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPipelineExecutableInternalRepresentationKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub name                                         : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub description                                  : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub isText                                       : VkBool32,
	pub dataSize                                     : usize,
	pub pData                                        : *mut (),
}

unsafe impl Send for VkPipelineExecutableInternalRepresentationKHR<'_> {}
unsafe impl Sync for VkPipelineExecutableInternalRepresentationKHR<'_> {}

impl fmt::Debug for VkPipelineExecutableInternalRepresentationKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableInternalRepresentationKHR").finish()
	}
}

impl Default for VkPipelineExecutableInternalRepresentationKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderDemoteToHelperInvocation               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub texelBufferAlignment                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub storageTexelBufferOffsetAlignmentBytes       : VkDeviceSize,
	pub storageTexelBufferOffsetSingleTexelAlignment : VkBool32,
	pub uniformTexelBufferOffsetAlignmentBytes       : VkDeviceSize,
	pub uniformTexelBufferOffsetSingleTexelAlignment : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub subgroupSizeControl                          : VkBool32,
	pub computeFullSubgroups                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSubgroupSizeControlFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceSubgroupSizeControlFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceSubgroupSizeControlFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// The minimum subgroup size supported by this device
	pub minSubgroupSize                              : u32,
	/// The maximum subgroup size supported by this device
	pub maxSubgroupSize                              : u32,
	/// The maximum number of subgroups supported in a workgroup
	pub maxComputeWorkgroupSubgroups                 : u32,
	/// The shader stages that support specifying a subgroup size
	pub requiredSubgroupSizeStages                   : VkShaderStageFlags,
}

unsafe impl Send for VkPhysicalDeviceSubgroupSizeControlPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceSubgroupSizeControlPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceSubgroupSizeControlPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub requiredSubgroupSize                         : u32,
}

unsafe impl Send for VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT<'_> {}

impl Default for VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkSubpassShadingPipelineCreateInfoHUAWEI<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub renderPass                                   : VkRenderPass,
	pub subpass                                      : u32,
}

unsafe impl Send for VkSubpassShadingPipelineCreateInfoHUAWEI<'_> {}
unsafe impl Sync for VkSubpassShadingPipelineCreateInfoHUAWEI<'_> {}

impl Default for VkSubpassShadingPipelineCreateInfoHUAWEI<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxSubpassShadingWorkgroupSizeAspectRatio    : u32,
}

unsafe impl Send for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI<'_> {}
unsafe impl Sync for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI<'_> {}

impl Default for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub opaqueCaptureAddress                         : u64,
}

unsafe impl Send for VkMemoryOpaqueCaptureAddressAllocateInfo<'_> {}
unsafe impl Sync for VkMemoryOpaqueCaptureAddressAllocateInfo<'_> {}

impl Default for VkMemoryOpaqueCaptureAddressAllocateInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkMemoryOpaqueCaptureAddressAllocateInfoKHR  <'a> = VkMemoryOpaqueCaptureAddressAllocateInfo<'a>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub memory                                       : VkDeviceMemory,
}

unsafe impl Send for VkDeviceMemoryOpaqueCaptureAddressInfo<'_> {}
unsafe impl Sync for VkDeviceMemoryOpaqueCaptureAddressInfo<'_> {}

impl Default for VkDeviceMemoryOpaqueCaptureAddressInfo<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkDeviceMemoryOpaqueCaptureAddressInfoKHR    <'a> = VkDeviceMemoryOpaqueCaptureAddressInfo<'a>;

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceLineRasterizationFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub rectangularLines                             : VkBool32,
	pub bresenhamLines                               : VkBool32,
	pub smoothLines                                  : VkBool32,
	pub stippledRectangularLines                     : VkBool32,
	pub stippledBresenhamLines                       : VkBool32,
	pub stippledSmoothLines                          : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceLineRasterizationFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceLineRasterizationFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceLineRasterizationFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceLineRasterizationPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub lineSubPixelPrecisionBits                    : u32,
}

unsafe impl Send for VkPhysicalDeviceLineRasterizationPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceLineRasterizationPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceLineRasterizationPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationLineStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub lineRasterizationMode                        : VkLineRasterizationModeEXT,
	pub stippledLineEnable                           : VkBool32,
	pub lineStippleFactor                            : u32,
	pub lineStipplePattern                           : u16,
}

unsafe impl Send for VkPipelineRasterizationLineStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineRasterizationLineStateCreateInfoEXT<'_> {}

impl Default for VkPipelineRasterizationLineStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub pipelineCreationCacheControl                 : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT<'_> {}

impl Default for VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVulkan11Features<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	/// 16-bit integer/floating-point variables supported in BufferBlock
	pub storageBuffer16BitAccess                     : VkBool32,
	/// 16-bit integer/floating-point variables supported in BufferBlock and Block
	pub uniformAndStorageBuffer16BitAccess           : VkBool32,
	/// 16-bit integer/floating-point variables supported in PushConstant
	pub storagePushConstant16                        : VkBool32,
	/// 16-bit integer/floating-point variables supported in shader inputs and outputs
	pub storageInputOutput16                         : VkBool32,
	/// Multiple views in a renderpass
	pub multiview                                    : VkBool32,
	/// Multiple views in a renderpass w/ geometry shader
	pub multiviewGeometryShader                      : VkBool32,
	/// Multiple views in a renderpass w/ tessellation shader
	pub multiviewTessellationShader                  : VkBool32,
	pub variablePointersStorageBuffer                : VkBool32,
	pub variablePointers                             : VkBool32,
	pub protectedMemory                              : VkBool32,
	/// Sampler color conversion supported
	pub samplerYcbcrConversion                       : VkBool32,
	pub shaderDrawParameters                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceVulkan11Features<'_> {}
unsafe impl Sync for VkPhysicalDeviceVulkan11Features<'_> {}

impl Default for VkPhysicalDeviceVulkan11Features<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceVulkan11Properties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub deviceUUID                                   : [u8;  VK_UUID_SIZE as usize],
	pub driverUUID                                   : [u8;  VK_UUID_SIZE as usize],
	pub deviceLUID                                   : [u8;  VK_LUID_SIZE as usize],
	pub deviceNodeMask                               : u32,
	pub deviceLUIDValid                              : VkBool32,
	/// The size of a subgroup for this queue.
	pub subgroupSize                                 : u32,
	/// Bitfield of what shader stages support subgroup operations
	pub subgroupSupportedStages                      : VkShaderStageFlags,
	/// Bitfield of what subgroup operations are supported.
	pub subgroupSupportedOperations                  : VkSubgroupFeatureFlags,
	/// Flag to specify whether quad operations are available in all stages.
	pub subgroupQuadOperationsInAllStages            : VkBool32,
	pub pointClippingBehavior                        : VkPointClippingBehavior,
	/// max number of views in a subpass
	pub maxMultiviewViewCount                        : u32,
	/// max instance index for a draw in a multiview subpass
	pub maxMultiviewInstanceIndex                    : u32,
	pub protectedNoFault                             : VkBool32,
	pub maxPerSetDescriptors                         : u32,
	pub maxMemoryAllocationSize                      : VkDeviceSize,
}

unsafe impl Send for VkPhysicalDeviceVulkan11Properties<'_> {}
unsafe impl Sync for VkPhysicalDeviceVulkan11Properties<'_> {}

impl fmt::Debug for VkPhysicalDeviceVulkan11Properties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan11Properties").finish()
	}
}

impl Default for VkPhysicalDeviceVulkan11Properties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVulkan12Features<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub samplerMirrorClampToEdge                     : VkBool32,
	pub drawIndirectCount                            : VkBool32,
	/// 8-bit integer variables supported in StorageBuffer
	pub storageBuffer8BitAccess                      : VkBool32,
	/// 8-bit integer variables supported in StorageBuffer and Uniform
	pub uniformAndStorageBuffer8BitAccess            : VkBool32,
	/// 8-bit integer variables supported in PushConstant
	pub storagePushConstant8                         : VkBool32,
	pub shaderBufferInt64Atomics                     : VkBool32,
	pub shaderSharedInt64Atomics                     : VkBool32,
	/// 16-bit floats (halfs) in shaders
	pub shaderFloat16                                : VkBool32,
	/// 8-bit integers in shaders
	pub shaderInt8                                   : VkBool32,
	pub descriptorIndexing                           : VkBool32,
	pub shaderInputAttachmentArrayDynamicIndexing    : VkBool32,
	pub shaderUniformTexelBufferArrayDynamicIndexing : VkBool32,
	pub shaderStorageTexelBufferArrayDynamicIndexing : VkBool32,
	pub shaderUniformBufferArrayNonUniformIndexing   : VkBool32,
	pub shaderSampledImageArrayNonUniformIndexing    : VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexing   : VkBool32,
	pub shaderStorageImageArrayNonUniformIndexing    : VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexing : VkBool32,
	pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingSampledImageUpdateAfterBind : VkBool32,
	pub descriptorBindingStorageImageUpdateAfterBind : VkBool32,
	pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUpdateUnusedWhilePending    : VkBool32,
	pub descriptorBindingPartiallyBound              : VkBool32,
	pub descriptorBindingVariableDescriptorCount     : VkBool32,
	pub runtimeDescriptorArray                       : VkBool32,
	pub samplerFilterMinmax                          : VkBool32,
	pub scalarBlockLayout                            : VkBool32,
	pub imagelessFramebuffer                         : VkBool32,
	pub uniformBufferStandardLayout                  : VkBool32,
	pub shaderSubgroupExtendedTypes                  : VkBool32,
	pub separateDepthStencilLayouts                  : VkBool32,
	pub hostQueryReset                               : VkBool32,
	pub timelineSemaphore                            : VkBool32,
	pub bufferDeviceAddress                          : VkBool32,
	pub bufferDeviceAddressCaptureReplay             : VkBool32,
	pub bufferDeviceAddressMultiDevice               : VkBool32,
	pub vulkanMemoryModel                            : VkBool32,
	pub vulkanMemoryModelDeviceScope                 : VkBool32,
	pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
	pub shaderOutputViewportIndex                    : VkBool32,
	pub shaderOutputLayer                            : VkBool32,
	pub subgroupBroadcastDynamicId                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceVulkan12Features<'_> {}
unsafe impl Sync for VkPhysicalDeviceVulkan12Features<'_> {}

impl Default for VkPhysicalDeviceVulkan12Features<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceVulkan12Properties<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub driverID                                     : VkDriverId,
	pub driverName                                   : [u8;  VK_MAX_DRIVER_NAME_SIZE as usize],
	pub driverInfo                                   : [u8;  VK_MAX_DRIVER_INFO_SIZE as usize],
	pub conformanceVersion                           : VkConformanceVersion,
	pub denormBehaviorIndependence                   : VkShaderFloatControlsIndependence,
	pub roundingModeIndependence                     : VkShaderFloatControlsIndependence,
	/// An implementation can preserve signed zero, nan, inf
	pub shaderSignedZeroInfNanPreserveFloat16        : VkBool32,
	/// An implementation can preserve signed zero, nan, inf
	pub shaderSignedZeroInfNanPreserveFloat32        : VkBool32,
	/// An implementation can preserve signed zero, nan, inf
	pub shaderSignedZeroInfNanPreserveFloat64        : VkBool32,
	/// An implementation can preserve  denormals
	pub shaderDenormPreserveFloat16                  : VkBool32,
	/// An implementation can preserve  denormals
	pub shaderDenormPreserveFloat32                  : VkBool32,
	/// An implementation can preserve  denormals
	pub shaderDenormPreserveFloat64                  : VkBool32,
	/// An implementation can flush to zero  denormals
	pub shaderDenormFlushToZeroFloat16               : VkBool32,
	/// An implementation can flush to zero  denormals
	pub shaderDenormFlushToZeroFloat32               : VkBool32,
	/// An implementation can flush to zero  denormals
	pub shaderDenormFlushToZeroFloat64               : VkBool32,
	/// An implementation can support RTE
	pub shaderRoundingModeRTEFloat16                 : VkBool32,
	/// An implementation can support RTE
	pub shaderRoundingModeRTEFloat32                 : VkBool32,
	/// An implementation can support RTE
	pub shaderRoundingModeRTEFloat64                 : VkBool32,
	/// An implementation can support RTZ
	pub shaderRoundingModeRTZFloat16                 : VkBool32,
	/// An implementation can support RTZ
	pub shaderRoundingModeRTZFloat32                 : VkBool32,
	/// An implementation can support RTZ
	pub shaderRoundingModeRTZFloat64                 : VkBool32,
	pub maxUpdateAfterBindDescriptorsInAllPools      : u32,
	pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
	pub robustBufferAccessUpdateAfterBind            : VkBool32,
	pub quadDivergentImplicitLod                     : VkBool32,
	pub maxPerStageDescriptorUpdateAfterBindSamplers : u32,
	pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
	pub maxPerStageUpdateAfterBindResources          : u32,
	pub maxDescriptorSetUpdateAfterBindSamplers      : u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindSampledImages : u32,
	pub maxDescriptorSetUpdateAfterBindStorageImages : u32,
	pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
	/// supported depth resolve modes
	pub supportedDepthResolveModes                   : VkResolveModeFlags,
	/// supported stencil resolve modes
	pub supportedStencilResolveModes                 : VkResolveModeFlags,
	/// depth and stencil resolve modes can be set independently if one of them is none
	pub independentResolveNone                       : VkBool32,
	/// depth and stencil resolve modes can be set independently
	pub independentResolve                           : VkBool32,
	pub filterMinmaxSingleComponentFormats           : VkBool32,
	pub filterMinmaxImageComponentMapping            : VkBool32,
	pub maxTimelineSemaphoreValueDifference          : u64,
	pub framebufferIntegerColorSampleCounts          : VkSampleCountFlags,
}

unsafe impl Send for VkPhysicalDeviceVulkan12Properties<'_> {}
unsafe impl Sync for VkPhysicalDeviceVulkan12Properties<'_> {}

impl fmt::Debug for VkPhysicalDeviceVulkan12Properties<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan12Properties").finish()
	}
}

impl Default for VkPhysicalDeviceVulkan12Properties<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineCompilerControlCreateInfoAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub compilerControlFlags                         : VkPipelineCompilerControlFlagsAMD,
}

unsafe impl Send for VkPipelineCompilerControlCreateInfoAMD<'_> {}
unsafe impl Sync for VkPipelineCompilerControlCreateInfoAMD<'_> {}

impl Default for VkPipelineCompilerControlCreateInfoAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub deviceCoherentMemory                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceCoherentMemoryFeaturesAMD<'_> {}
unsafe impl Sync for VkPhysicalDeviceCoherentMemoryFeaturesAMD<'_> {}

impl Default for VkPhysicalDeviceCoherentMemoryFeaturesAMD<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceToolPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub name                                         : [u8;  VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub version                                      : [u8;  VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub purposes                                     : VkToolPurposeFlagsEXT,
	pub description                                  : [u8;  VK_MAX_DESCRIPTION_SIZE as usize],
	pub layer                                        : [u8;  VK_MAX_EXTENSION_NAME_SIZE as usize],
}

unsafe impl Send for VkPhysicalDeviceToolPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceToolPropertiesEXT<'_> {}

impl fmt::Debug for VkPhysicalDeviceToolPropertiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceToolPropertiesEXT").finish()
	}
}

impl Default for VkPhysicalDeviceToolPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerCustomBorderColorCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub customBorderColor                            : VkClearColorValue,
	pub format                                       : VkFormat,
}

unsafe impl Send for VkSamplerCustomBorderColorCreateInfoEXT<'_> {}
unsafe impl Sync for VkSamplerCustomBorderColorCreateInfoEXT<'_> {}

impl fmt::Debug for VkSamplerCustomBorderColorCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerCustomBorderColorCreateInfoEXT").finish()
	}
}

impl Default for VkSamplerCustomBorderColorCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxCustomBorderColorSamplers                 : u32,
}

unsafe impl Send for VkPhysicalDeviceCustomBorderColorPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceCustomBorderColorPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceCustomBorderColorPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub customBorderColors                           : VkBool32,
	pub customBorderColorWithoutFormat               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceCustomBorderColorFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceCustomBorderColorFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceCustomBorderColorFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub union VkDeviceOrHostAddressKHR<'a> {
	pub deviceAddress                                : VkDeviceAddress,
	pub hostAddress                                  : std::mem::ManuallyDrop<VkAnyMut<'a>>,
}

unsafe impl Send for VkDeviceOrHostAddressKHR<'_> {}
unsafe impl Sync for VkDeviceOrHostAddressKHR<'_> {}

impl fmt::Debug for VkDeviceOrHostAddressKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceOrHostAddressKHR").finish()
	}
}

impl Default for VkDeviceOrHostAddressKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union VkDeviceOrHostAddressConstKHR<'a> {
	pub deviceAddress                                : VkDeviceAddress,
	pub hostAddress                                  : VkAnyRef<'a>,
}

unsafe impl Send for VkDeviceOrHostAddressConstKHR<'_> {}
unsafe impl Sync for VkDeviceOrHostAddressConstKHR<'_> {}

impl fmt::Debug for VkDeviceOrHostAddressConstKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceOrHostAddressConstKHR").finish()
	}
}

impl Default for VkDeviceOrHostAddressConstKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryTrianglesDataKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub vertexFormat                                 : VkFormat,
	pub vertexData                                   : VkDeviceOrHostAddressConstKHR<'a>,
	pub vertexStride                                 : VkDeviceSize,
	pub maxVertex                                    : u32,
	pub indexType                                    : VkIndexType,
	pub indexData                                    : VkDeviceOrHostAddressConstKHR<'a>,
	pub transformData                                : VkDeviceOrHostAddressConstKHR<'a>,
}

unsafe impl Send for VkAccelerationStructureGeometryTrianglesDataKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureGeometryTrianglesDataKHR<'_> {}

impl fmt::Debug for VkAccelerationStructureGeometryTrianglesDataKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryTrianglesDataKHR").finish()
	}
}

impl Default for VkAccelerationStructureGeometryTrianglesDataKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryAabbsDataKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub data                                         : VkDeviceOrHostAddressConstKHR<'a>,
	pub stride                                       : VkDeviceSize,
}

unsafe impl Send for VkAccelerationStructureGeometryAabbsDataKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureGeometryAabbsDataKHR<'_> {}

impl fmt::Debug for VkAccelerationStructureGeometryAabbsDataKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryAabbsDataKHR").finish()
	}
}

impl Default for VkAccelerationStructureGeometryAabbsDataKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryInstancesDataKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub arrayOfPointers                              : VkBool32,
	pub data                                         : VkDeviceOrHostAddressConstKHR<'a>,
}

unsafe impl Send for VkAccelerationStructureGeometryInstancesDataKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureGeometryInstancesDataKHR<'_> {}

impl fmt::Debug for VkAccelerationStructureGeometryInstancesDataKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryInstancesDataKHR").finish()
	}
}

impl Default for VkAccelerationStructureGeometryInstancesDataKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union VkAccelerationStructureGeometryDataKHR<'a> {
	pub triangles                                    : VkAccelerationStructureGeometryTrianglesDataKHR<'a>,
	pub aabbs                                        : VkAccelerationStructureGeometryAabbsDataKHR<'a>,
	pub instances                                    : VkAccelerationStructureGeometryInstancesDataKHR<'a>,
}

unsafe impl Send for VkAccelerationStructureGeometryDataKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureGeometryDataKHR<'_> {}

impl fmt::Debug for VkAccelerationStructureGeometryDataKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryDataKHR").finish()
	}
}

impl Default for VkAccelerationStructureGeometryDataKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub geometryType                                 : VkGeometryTypeKHR,
	pub geometry                                     : VkAccelerationStructureGeometryDataKHR<'a>,
	pub flags                                        : VkGeometryFlagsKHR,
}

unsafe impl Send for VkAccelerationStructureGeometryKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureGeometryKHR<'_> {}

impl fmt::Debug for VkAccelerationStructureGeometryKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryKHR").finish()
	}
}

impl Default for VkAccelerationStructureGeometryKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkAccelerationStructureBuildGeometryInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub r#type                                       : VkAccelerationStructureTypeKHR,
	pub flags                                        : VkBuildAccelerationStructureFlagsKHR,
	pub mode                                         : VkBuildAccelerationStructureModeKHR,
	pub srcAccelerationStructure                     : VkAccelerationStructureKHR,
	pub dstAccelerationStructure                     : VkAccelerationStructureKHR,
	pub geometryCount                                : u32,
	pub pGeometries                                  : *const VkAccelerationStructureGeometryKHR<'a>,
	pub ppGeometries                                 : *const *const VkAccelerationStructureGeometryKHR<'a>,
	pub scratchData                                  : VkDeviceOrHostAddressKHR<'a>,
}

unsafe impl Send for VkAccelerationStructureBuildGeometryInfoKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureBuildGeometryInfoKHR<'_> {}

impl fmt::Debug for VkAccelerationStructureBuildGeometryInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureBuildGeometryInfoKHR").finish()
	}
}

impl Default for VkAccelerationStructureBuildGeometryInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkAccelerationStructureBuildRangeInfoKHR {
	pub primitiveCount                               : u32,
	pub primitiveOffset                              : u32,
	pub firstVertex                                  : u32,
	pub transformOffset                              : u32,
}

unsafe impl Send for VkAccelerationStructureBuildRangeInfoKHR {}
unsafe impl Sync for VkAccelerationStructureBuildRangeInfoKHR {}


#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAccelerationStructureCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub createFlags                                  : VkAccelerationStructureCreateFlagsKHR,
	pub buffer                                       : VkBuffer,
	/// Specified in bytes
	pub offset                                       : VkDeviceSize,
	pub size                                         : VkDeviceSize,
	pub r#type                                       : VkAccelerationStructureTypeKHR,
	pub deviceAddress                                : VkDeviceAddress,
}

unsafe impl Send for VkAccelerationStructureCreateInfoKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureCreateInfoKHR<'_> {}

impl Default for VkAccelerationStructureCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkAabbPositionsKHR {
	pub minX                                         : f32,
	pub minY                                         : f32,
	pub minZ                                         : f32,
	pub maxX                                         : f32,
	pub maxY                                         : f32,
	pub maxZ                                         : f32,
}

unsafe impl Send for VkAabbPositionsKHR {}
unsafe impl Sync for VkAabbPositionsKHR {}


pub type VkAabbPositionsNV                             = VkAabbPositionsKHR;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkTransformMatrixKHR {
	pub matrix                                       : [[f32;  4 as usize];  3 as usize],
}

unsafe impl Send for VkTransformMatrixKHR {}
unsafe impl Sync for VkTransformMatrixKHR {}

impl fmt::Debug for VkTransformMatrixKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkTransformMatrixKHR").finish()
	}
}

impl Default for VkTransformMatrixKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkTransformMatrixNV                           = VkTransformMatrixKHR;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureInstanceKHR {
	pub transform                                    : VkTransformMatrixKHR,
	pub instanceCustomIndex                          : u32,
	pub mask                                         : u32,
	pub instanceShaderBindingTableRecordOffset       : u32,
	pub flags                                        : VkGeometryInstanceFlagsKHR,
	pub accelerationStructureReference               : u64,
}

unsafe impl Send for VkAccelerationStructureInstanceKHR {}
unsafe impl Sync for VkAccelerationStructureInstanceKHR {}

impl fmt::Debug for VkAccelerationStructureInstanceKHR {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureInstanceKHR").finish()
	}
}

impl Default for VkAccelerationStructureInstanceKHR {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkAccelerationStructureInstanceNV             = VkAccelerationStructureInstanceKHR;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAccelerationStructureDeviceAddressInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub accelerationStructure                        : VkAccelerationStructureKHR,
}

unsafe impl Send for VkAccelerationStructureDeviceAddressInfoKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureDeviceAddressInfoKHR<'_> {}

impl Default for VkAccelerationStructureDeviceAddressInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAccelerationStructureVersionInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pVersionData                                 : *const u8,
}

unsafe impl Send for VkAccelerationStructureVersionInfoKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureVersionInfoKHR<'_> {}

impl Default for VkAccelerationStructureVersionInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCopyAccelerationStructureInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub src                                          : VkAccelerationStructureKHR,
	pub dst                                          : VkAccelerationStructureKHR,
	pub mode                                         : VkCopyAccelerationStructureModeKHR,
}

unsafe impl Send for VkCopyAccelerationStructureInfoKHR<'_> {}
unsafe impl Sync for VkCopyAccelerationStructureInfoKHR<'_> {}

impl Default for VkCopyAccelerationStructureInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkCopyAccelerationStructureToMemoryInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub src                                          : VkAccelerationStructureKHR,
	pub dst                                          : VkDeviceOrHostAddressKHR<'a>,
	pub mode                                         : VkCopyAccelerationStructureModeKHR,
}

unsafe impl Send for VkCopyAccelerationStructureToMemoryInfoKHR<'_> {}
unsafe impl Sync for VkCopyAccelerationStructureToMemoryInfoKHR<'_> {}

impl fmt::Debug for VkCopyAccelerationStructureToMemoryInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCopyAccelerationStructureToMemoryInfoKHR").finish()
	}
}

impl Default for VkCopyAccelerationStructureToMemoryInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyMemoryToAccelerationStructureInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub src                                          : VkDeviceOrHostAddressConstKHR<'a>,
	pub dst                                          : VkAccelerationStructureKHR,
	pub mode                                         : VkCopyAccelerationStructureModeKHR,
}

unsafe impl Send for VkCopyMemoryToAccelerationStructureInfoKHR<'_> {}
unsafe impl Sync for VkCopyMemoryToAccelerationStructureInfoKHR<'_> {}

impl fmt::Debug for VkCopyMemoryToAccelerationStructureInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMemoryToAccelerationStructureInfoKHR").finish()
	}
}

impl Default for VkCopyMemoryToAccelerationStructureInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRayTracingPipelineInterfaceCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub maxPipelineRayPayloadSize                    : u32,
	pub maxPipelineRayHitAttributeSize               : u32,
}

unsafe impl Send for VkRayTracingPipelineInterfaceCreateInfoKHR<'_> {}
unsafe impl Sync for VkRayTracingPipelineInterfaceCreateInfoKHR<'_> {}

impl Default for VkRayTracingPipelineInterfaceCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineLibraryCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub libraryCount                                 : u32,
	pub pLibraries                                   : *const VkPipeline,
}

unsafe impl Send for VkPipelineLibraryCreateInfoKHR<'_> {}
unsafe impl Sync for VkPipelineLibraryCreateInfoKHR<'_> {}

impl Default for VkPipelineLibraryCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub extendedDynamicState                         : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub extendedDynamicState2                        : VkBool32,
	pub extendedDynamicState2LogicOp                 : VkBool32,
	pub extendedDynamicState2PatchControlPoints      : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkRenderPassTransformBeginInfoQCOM<'a> {
	pub sType                                        : VkStructureType,
	/// Pointer to next structure
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub transform                                    : VkSurfaceTransformFlagBitsKHR,
}

unsafe impl Send for VkRenderPassTransformBeginInfoQCOM<'_> {}
unsafe impl Sync for VkRenderPassTransformBeginInfoQCOM<'_> {}

impl Default for VkRenderPassTransformBeginInfoQCOM<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCopyCommandTransformInfoQCOM<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub transform                                    : VkSurfaceTransformFlagBitsKHR,
}

unsafe impl Send for VkCopyCommandTransformInfoQCOM<'_> {}
unsafe impl Sync for VkCopyCommandTransformInfoQCOM<'_> {}

impl Default for VkCopyCommandTransformInfoQCOM<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
	pub sType                                        : VkStructureType,
	/// Pointer to next structure
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub transform                                    : VkSurfaceTransformFlagBitsKHR,
	pub renderArea                                   : VkRect2D,
}

unsafe impl Send for VkCommandBufferInheritanceRenderPassTransformInfoQCOM<'_> {}
unsafe impl Sync for VkCommandBufferInheritanceRenderPassTransformInfoQCOM<'_> {}

impl fmt::Debug for VkCommandBufferInheritanceRenderPassTransformInfoQCOM<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceRenderPassTransformInfoQCOM").finish()
	}
}

impl Default for VkCommandBufferInheritanceRenderPassTransformInfoQCOM<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub diagnosticsConfig                            : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceDiagnosticsConfigFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceDiagnosticsConfigFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceDiagnosticsConfigFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceDiagnosticsConfigCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub flags                                        : VkDeviceDiagnosticsConfigFlagsNV,
}

unsafe impl Send for VkDeviceDiagnosticsConfigCreateInfoNV<'_> {}
unsafe impl Sync for VkDeviceDiagnosticsConfigCreateInfoNV<'_> {}

impl Default for VkDeviceDiagnosticsConfigCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub shaderZeroInitializeWorkgroupMemory          : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub shaderSubgroupUniformControlFlow             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRobustness2FeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub robustBufferAccess2                          : VkBool32,
	pub robustImageAccess2                           : VkBool32,
	pub nullDescriptor                               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceRobustness2FeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceRobustness2FeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceRobustness2FeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRobustness2PropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub robustStorageBufferAccessSizeAlignment       : VkDeviceSize,
	pub robustUniformBufferAccessSizeAlignment       : VkDeviceSize,
}

unsafe impl Send for VkPhysicalDeviceRobustness2PropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceRobustness2PropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceRobustness2PropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceImageRobustnessFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub robustImageAccess                            : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceImageRobustnessFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceImageRobustnessFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceImageRobustnessFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub workgroupMemoryExplicitLayout                : VkBool32,
	pub workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32,
	pub workgroupMemoryExplicitLayout8BitAccess      : VkBool32,
	pub workgroupMemoryExplicitLayout16BitAccess     : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub constantAlphaColorBlendFactors               : VkBool32,
	pub events                                       : VkBool32,
	pub imageViewFormatReinterpretation              : VkBool32,
	pub imageViewFormatSwizzle                       : VkBool32,
	pub imageView2DOn3DImage                         : VkBool32,
	pub multisampleArrayImage                        : VkBool32,
	pub mutableComparisonSamplers                    : VkBool32,
	pub pointPolygons                                : VkBool32,
	pub samplerMipLodBias                            : VkBool32,
	pub separateStencilMaskRef                       : VkBool32,
	pub shaderSampleRateInterpolationFunctions       : VkBool32,
	pub tessellationIsolines                         : VkBool32,
	pub tessellationPointMode                        : VkBool32,
	pub triangleFans                                 : VkBool32,
	pub vertexAttributeAccessBeyondStride            : VkBool32,
}

unsafe impl Send for VkPhysicalDevicePortabilitySubsetFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDevicePortabilitySubsetFeaturesKHR<'_> {}

impl Default for VkPhysicalDevicePortabilitySubsetFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub minVertexInputBindingStrideAlignment         : u32,
}

unsafe impl Send for VkPhysicalDevicePortabilitySubsetPropertiesKHR<'_> {}
unsafe impl Sync for VkPhysicalDevicePortabilitySubsetPropertiesKHR<'_> {}

impl Default for VkPhysicalDevicePortabilitySubsetPropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDevice4444FormatsFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub formatA4R4G4B4                               : VkBool32,
	pub formatA4B4G4R4                               : VkBool32,
}

unsafe impl Send for VkPhysicalDevice4444FormatsFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDevice4444FormatsFeaturesEXT<'_> {}

impl Default for VkPhysicalDevice4444FormatsFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub subpassShading                               : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI<'_> {}
unsafe impl Sync for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI<'_> {}

impl Default for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferCopy2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Specified in bytes
	pub srcOffset                                    : VkDeviceSize,
	/// Specified in bytes
	pub dstOffset                                    : VkDeviceSize,
	/// Specified in bytes
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkBufferCopy2KHR<'_> {}
unsafe impl Sync for VkBufferCopy2KHR<'_> {}

impl Default for VkBufferCopy2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageCopy2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub srcOffset                                    : VkOffset3D,
	pub dstSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub dstOffset                                    : VkOffset3D,
	/// Specified in pixels for both compressed and uncompressed images
	pub extent                                       : VkExtent3D,
}

unsafe impl Send for VkImageCopy2KHR<'_> {}
unsafe impl Sync for VkImageCopy2KHR<'_> {}

impl fmt::Debug for VkImageCopy2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageCopy2KHR").finish()
	}
}

impl Default for VkImageCopy2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageBlit2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub srcOffsets                                   : [VkOffset3D;  2 as usize],
	pub dstSubresource                               : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub dstOffsets                                   : [VkOffset3D;  2 as usize],
}

unsafe impl Send for VkImageBlit2KHR<'_> {}
unsafe impl Sync for VkImageBlit2KHR<'_> {}

impl fmt::Debug for VkImageBlit2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageBlit2KHR").finish()
	}
}

impl Default for VkImageBlit2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBufferImageCopy2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// Specified in bytes
	pub bufferOffset                                 : VkDeviceSize,
	/// Specified in texels
	pub bufferRowLength                              : u32,
	pub bufferImageHeight                            : u32,
	pub imageSubresource                             : VkImageSubresourceLayers,
	/// Specified in pixels for both compressed and uncompressed images
	pub imageOffset                                  : VkOffset3D,
	/// Specified in pixels for both compressed and uncompressed images
	pub imageExtent                                  : VkExtent3D,
}

unsafe impl Send for VkBufferImageCopy2KHR<'_> {}
unsafe impl Sync for VkBufferImageCopy2KHR<'_> {}

impl fmt::Debug for VkBufferImageCopy2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBufferImageCopy2KHR").finish()
	}
}

impl Default for VkBufferImageCopy2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageResolve2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcSubresource                               : VkImageSubresourceLayers,
	pub srcOffset                                    : VkOffset3D,
	pub dstSubresource                               : VkImageSubresourceLayers,
	pub dstOffset                                    : VkOffset3D,
	pub extent                                       : VkExtent3D,
}

unsafe impl Send for VkImageResolve2KHR<'_> {}
unsafe impl Sync for VkImageResolve2KHR<'_> {}

impl fmt::Debug for VkImageResolve2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageResolve2KHR").finish()
	}
}

impl Default for VkImageResolve2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyBufferInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcBuffer                                    : VkBuffer,
	pub dstBuffer                                    : VkBuffer,
	pub regionCount                                  : u32,
	pub pRegions                                     : *const VkBufferCopy2KHR<'a>,
}

unsafe impl Send for VkCopyBufferInfo2KHR<'_> {}
unsafe impl Sync for VkCopyBufferInfo2KHR<'_> {}

impl fmt::Debug for VkCopyBufferInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCopyBufferInfo2KHR").finish()
	}
}

impl Default for VkCopyBufferInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyImageInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcImage                                     : VkImage,
	pub srcImageLayout                               : VkImageLayout,
	pub dstImage                                     : VkImage,
	pub dstImageLayout                               : VkImageLayout,
	pub regionCount                                  : u32,
	pub pRegions                                     : *const VkImageCopy2KHR<'a>,
}

unsafe impl Send for VkCopyImageInfo2KHR<'_> {}
unsafe impl Sync for VkCopyImageInfo2KHR<'_> {}

impl fmt::Debug for VkCopyImageInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCopyImageInfo2KHR").finish()
	}
}

impl Default for VkCopyImageInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkBlitImageInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcImage                                     : VkImage,
	pub srcImageLayout                               : VkImageLayout,
	pub dstImage                                     : VkImage,
	pub dstImageLayout                               : VkImageLayout,
	pub regionCount                                  : u32,
	pub pRegions                                     : *const VkImageBlit2KHR<'a>,
	pub filter                                       : VkFilter,
}

unsafe impl Send for VkBlitImageInfo2KHR<'_> {}
unsafe impl Sync for VkBlitImageInfo2KHR<'_> {}

impl fmt::Debug for VkBlitImageInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkBlitImageInfo2KHR").finish()
	}
}

impl Default for VkBlitImageInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyBufferToImageInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcBuffer                                    : VkBuffer,
	pub dstImage                                     : VkImage,
	pub dstImageLayout                               : VkImageLayout,
	pub regionCount                                  : u32,
	pub pRegions                                     : *const VkBufferImageCopy2KHR<'a>,
}

unsafe impl Send for VkCopyBufferToImageInfo2KHR<'_> {}
unsafe impl Sync for VkCopyBufferToImageInfo2KHR<'_> {}

impl fmt::Debug for VkCopyBufferToImageInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCopyBufferToImageInfo2KHR").finish()
	}
}

impl Default for VkCopyBufferToImageInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyImageToBufferInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcImage                                     : VkImage,
	pub srcImageLayout                               : VkImageLayout,
	pub dstBuffer                                    : VkBuffer,
	pub regionCount                                  : u32,
	pub pRegions                                     : *const VkBufferImageCopy2KHR<'a>,
}

unsafe impl Send for VkCopyImageToBufferInfo2KHR<'_> {}
unsafe impl Sync for VkCopyImageToBufferInfo2KHR<'_> {}

impl fmt::Debug for VkCopyImageToBufferInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCopyImageToBufferInfo2KHR").finish()
	}
}

impl Default for VkCopyImageToBufferInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkResolveImageInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub srcImage                                     : VkImage,
	pub srcImageLayout                               : VkImageLayout,
	pub dstImage                                     : VkImage,
	pub dstImageLayout                               : VkImageLayout,
	pub regionCount                                  : u32,
	pub pRegions                                     : *const VkImageResolve2KHR<'a>,
}

unsafe impl Send for VkResolveImageInfo2KHR<'_> {}
unsafe impl Sync for VkResolveImageInfo2KHR<'_> {}

impl fmt::Debug for VkResolveImageInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkResolveImageInfo2KHR").finish()
	}
}

impl Default for VkResolveImageInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderImageInt64Atomics                      : VkBool32,
	pub sparseImageInt64Atomics                      : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkFragmentShadingRateAttachmentInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub pFragmentShadingRateAttachment               : Option<&'a VkAttachmentReference2<'a>>,
	pub shadingRateAttachmentTexelSize               : VkExtent2D,
}

unsafe impl Send for VkFragmentShadingRateAttachmentInfoKHR<'_> {}
unsafe impl Sync for VkFragmentShadingRateAttachmentInfoKHR<'_> {}

impl fmt::Debug for VkFragmentShadingRateAttachmentInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkFragmentShadingRateAttachmentInfoKHR").finish()
	}
}

impl Default for VkFragmentShadingRateAttachmentInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineFragmentShadingRateStateCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub fragmentSize                                 : VkExtent2D,
	pub combinerOps                                  : [VkFragmentShadingRateCombinerOpKHR;  2 as usize],
}

unsafe impl Send for VkPipelineFragmentShadingRateStateCreateInfoKHR<'_> {}
unsafe impl Sync for VkPipelineFragmentShadingRateStateCreateInfoKHR<'_> {}

impl fmt::Debug for VkPipelineFragmentShadingRateStateCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineFragmentShadingRateStateCreateInfoKHR").finish()
	}
}

impl Default for VkPipelineFragmentShadingRateStateCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub pipelineFragmentShadingRate                  : VkBool32,
	pub primitiveFragmentShadingRate                 : VkBool32,
	pub attachmentFragmentShadingRate                : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentShadingRateFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShadingRateFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceFragmentShadingRateFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub minFragmentShadingRateAttachmentTexelSize    : VkExtent2D,
	pub maxFragmentShadingRateAttachmentTexelSize    : VkExtent2D,
	pub maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32,
	pub primitiveFragmentShadingRateWithMultipleViewports: VkBool32,
	pub layeredShadingRateAttachments                : VkBool32,
	pub fragmentShadingRateNonTrivialCombinerOps     : VkBool32,
	pub maxFragmentSize                              : VkExtent2D,
	pub maxFragmentSizeAspectRatio                   : u32,
	pub maxFragmentShadingRateCoverageSamples        : u32,
	pub maxFragmentShadingRateRasterizationSamples   : VkSampleCountFlagBits,
	pub fragmentShadingRateWithShaderDepthStencilWrites: VkBool32,
	pub fragmentShadingRateWithSampleMask            : VkBool32,
	pub fragmentShadingRateWithShaderSampleMask      : VkBool32,
	pub fragmentShadingRateWithConservativeRasterization: VkBool32,
	pub fragmentShadingRateWithFragmentShaderInterlock: VkBool32,
	pub fragmentShadingRateWithCustomSampleLocations : VkBool32,
	pub fragmentShadingRateStrictMultiplyCombiner    : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentShadingRatePropertiesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShadingRatePropertiesKHR<'_> {}

impl fmt::Debug for VkPhysicalDeviceFragmentShadingRatePropertiesKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRatePropertiesKHR").finish()
	}
}

impl Default for VkPhysicalDeviceFragmentShadingRatePropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceFragmentShadingRateKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub sampleCounts                                 : VkSampleCountFlags,
	pub fragmentSize                                 : VkExtent2D,
}

unsafe impl Send for VkPhysicalDeviceFragmentShadingRateKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShadingRateKHR<'_> {}

impl fmt::Debug for VkPhysicalDeviceFragmentShadingRateKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRateKHR").finish()
	}
}

impl Default for VkPhysicalDeviceFragmentShadingRateKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub shaderTerminateInvocation                    : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub fragmentShadingRateEnums                     : VkBool32,
	pub supersampleFragmentShadingRates              : VkBool32,
	pub noInvocationFragmentShadingRates             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub maxFragmentShadingRateInvocationCount        : VkSampleCountFlagBits,
}

unsafe impl Send for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'_> {}

impl Default for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub shadingRateType                              : VkFragmentShadingRateTypeNV,
	pub shadingRate                                  : VkFragmentShadingRateNV,
	pub combinerOps                                  : [VkFragmentShadingRateCombinerOpKHR;  2 as usize],
}

unsafe impl Send for VkPipelineFragmentShadingRateEnumStateCreateInfoNV<'_> {}
unsafe impl Sync for VkPipelineFragmentShadingRateEnumStateCreateInfoNV<'_> {}

impl fmt::Debug for VkPipelineFragmentShadingRateEnumStateCreateInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineFragmentShadingRateEnumStateCreateInfoNV").finish()
	}
}

impl Default for VkPipelineFragmentShadingRateEnumStateCreateInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAccelerationStructureBuildSizesInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub accelerationStructureSize                    : VkDeviceSize,
	pub updateScratchSize                            : VkDeviceSize,
	pub buildScratchSize                             : VkDeviceSize,
}

unsafe impl Send for VkAccelerationStructureBuildSizesInfoKHR<'_> {}
unsafe impl Sync for VkAccelerationStructureBuildSizesInfoKHR<'_> {}

impl Default for VkAccelerationStructureBuildSizesInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub mutableDescriptorType                        : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'_> {}
unsafe impl Sync for VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'_> {}

impl Default for VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMutableDescriptorTypeListVALVE {
	pub descriptorTypeCount                          : u32,
	pub pDescriptorTypes                             : *const VkDescriptorType,
}

unsafe impl Send for VkMutableDescriptorTypeListVALVE {}
unsafe impl Sync for VkMutableDescriptorTypeListVALVE {}

impl Default for VkMutableDescriptorTypeListVALVE {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMutableDescriptorTypeCreateInfoVALVE<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub mutableDescriptorTypeListCount               : u32,
	pub pMutableDescriptorTypeLists                  : *const VkMutableDescriptorTypeListVALVE,
}

unsafe impl Send for VkMutableDescriptorTypeCreateInfoVALVE<'_> {}
unsafe impl Sync for VkMutableDescriptorTypeCreateInfoVALVE<'_> {}

impl fmt::Debug for VkMutableDescriptorTypeCreateInfoVALVE<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkMutableDescriptorTypeCreateInfoVALVE").finish()
	}
}

impl Default for VkMutableDescriptorTypeCreateInfoVALVE<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub vertexInputDynamicState                      : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub externalMemoryRDMA                           : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkVertexInputBindingDescription2EXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub binding                                      : u32,
	pub stride                                       : u32,
	pub inputRate                                    : VkVertexInputRate,
	pub divisor                                      : u32,
}

unsafe impl Send for VkVertexInputBindingDescription2EXT<'_> {}
unsafe impl Sync for VkVertexInputBindingDescription2EXT<'_> {}

impl Default for VkVertexInputBindingDescription2EXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkVertexInputAttributeDescription2EXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	/// location of the shader vertex attrib
	pub location                                     : u32,
	/// Vertex buffer binding id
	pub binding                                      : u32,
	/// format of source data
	pub format                                       : VkFormat,
	/// Offset of first element in bytes from base of vertex
	pub offset                                       : u32,
}

unsafe impl Send for VkVertexInputAttributeDescription2EXT<'_> {}
unsafe impl Sync for VkVertexInputAttributeDescription2EXT<'_> {}

impl Default for VkVertexInputAttributeDescription2EXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub colorWriteEnable                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceColorWriteEnableFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceColorWriteEnableFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceColorWriteEnableFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineColorWriteCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	/// # of pAttachments
	pub attachmentCount                              : u32,
	pub pColorWriteEnables                           : *const VkBool32,
}

unsafe impl Send for VkPipelineColorWriteCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineColorWriteCreateInfoEXT<'_> {}

impl Default for VkPipelineColorWriteCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryBarrier2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub srcStageMask                                 : VkPipelineStageFlags2KHR,
	pub srcAccessMask                                : VkAccessFlags2KHR,
	pub dstStageMask                                 : VkPipelineStageFlags2KHR,
	pub dstAccessMask                                : VkAccessFlags2KHR,
}

unsafe impl Send for VkMemoryBarrier2KHR<'_> {}
unsafe impl Sync for VkMemoryBarrier2KHR<'_> {}

impl Default for VkMemoryBarrier2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkImageMemoryBarrier2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub srcStageMask                                 : VkPipelineStageFlags2KHR,
	pub srcAccessMask                                : VkAccessFlags2KHR,
	pub dstStageMask                                 : VkPipelineStageFlags2KHR,
	pub dstAccessMask                                : VkAccessFlags2KHR,
	pub oldLayout                                    : VkImageLayout,
	pub newLayout                                    : VkImageLayout,
	pub srcQueueFamilyIndex                          : u32,
	pub dstQueueFamilyIndex                          : u32,
	pub image                                        : VkImage,
	pub subresourceRange                             : VkImageSubresourceRange,
}

unsafe impl Send for VkImageMemoryBarrier2KHR<'_> {}
unsafe impl Sync for VkImageMemoryBarrier2KHR<'_> {}

impl fmt::Debug for VkImageMemoryBarrier2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkImageMemoryBarrier2KHR").finish()
	}
}

impl Default for VkImageMemoryBarrier2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferMemoryBarrier2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub srcStageMask                                 : VkPipelineStageFlags2KHR,
	pub srcAccessMask                                : VkAccessFlags2KHR,
	pub dstStageMask                                 : VkPipelineStageFlags2KHR,
	pub dstAccessMask                                : VkAccessFlags2KHR,
	pub srcQueueFamilyIndex                          : u32,
	pub dstQueueFamilyIndex                          : u32,
	pub buffer                                       : VkBuffer,
	pub offset                                       : VkDeviceSize,
	pub size                                         : VkDeviceSize,
}

unsafe impl Send for VkBufferMemoryBarrier2KHR<'_> {}
unsafe impl Sync for VkBufferMemoryBarrier2KHR<'_> {}

impl Default for VkBufferMemoryBarrier2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDependencyInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub dependencyFlags                              : VkDependencyFlags,
	pub memoryBarrierCount                           : u32,
	pub pMemoryBarriers                              : *const VkMemoryBarrier2KHR<'a>,
	pub bufferMemoryBarrierCount                     : u32,
	pub pBufferMemoryBarriers                        : *const VkBufferMemoryBarrier2KHR<'a>,
	pub imageMemoryBarrierCount                      : u32,
	pub pImageMemoryBarriers                         : *const VkImageMemoryBarrier2KHR<'a>,
}

unsafe impl Send for VkDependencyInfoKHR<'_> {}
unsafe impl Sync for VkDependencyInfoKHR<'_> {}

impl fmt::Debug for VkDependencyInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDependencyInfoKHR").finish()
	}
}

impl Default for VkDependencyInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreSubmitInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub semaphore                                    : VkSemaphore,
	pub value                                        : u64,
	pub stageMask                                    : VkPipelineStageFlags2KHR,
	pub deviceIndex                                  : u32,
}

unsafe impl Send for VkSemaphoreSubmitInfoKHR<'_> {}
unsafe impl Sync for VkSemaphoreSubmitInfoKHR<'_> {}

impl Default for VkSemaphoreSubmitInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferSubmitInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub commandBuffer                                : VkCommandBuffer,
	pub deviceMask                                   : u32,
}

unsafe impl Send for VkCommandBufferSubmitInfoKHR<'_> {}
unsafe impl Sync for VkCommandBufferSubmitInfoKHR<'_> {}

impl Default for VkCommandBufferSubmitInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSubmitInfo2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkSubmitFlagsKHR,
	pub waitSemaphoreInfoCount                       : u32,
	pub pWaitSemaphoreInfos                          : *const VkSemaphoreSubmitInfoKHR<'a>,
	pub commandBufferInfoCount                       : u32,
	pub pCommandBufferInfos                          : *const VkCommandBufferSubmitInfoKHR<'a>,
	pub signalSemaphoreInfoCount                     : u32,
	pub pSignalSemaphoreInfos                        : *const VkSemaphoreSubmitInfoKHR<'a>,
}

unsafe impl Send for VkSubmitInfo2KHR<'_> {}
unsafe impl Sync for VkSubmitInfo2KHR<'_> {}

impl fmt::Debug for VkSubmitInfo2KHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkSubmitInfo2KHR").finish()
	}
}

impl Default for VkSubmitInfo2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkQueueFamilyCheckpointProperties2NV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub checkpointExecutionStageMask                 : VkPipelineStageFlags2KHR,
}

unsafe impl Send for VkQueueFamilyCheckpointProperties2NV<'_> {}
unsafe impl Sync for VkQueueFamilyCheckpointProperties2NV<'_> {}

impl Default for VkQueueFamilyCheckpointProperties2NV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkCheckpointData2NV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub stage                                        : VkPipelineStageFlags2KHR,
	pub pCheckpointMarker                            : VkAnyMut<'a>,
}

unsafe impl Send for VkCheckpointData2NV<'_> {}
unsafe impl Sync for VkCheckpointData2NV<'_> {}

impl Default for VkCheckpointData2NV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSynchronization2FeaturesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub synchronization2                             : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceSynchronization2FeaturesKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceSynchronization2FeaturesKHR<'_> {}

impl Default for VkPhysicalDeviceSynchronization2FeaturesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkVideoQueueFamilyProperties2KHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub videoCodecOperations                         : VkVideoCodecOperationFlagsKHR,
}

unsafe impl Send for VkVideoQueueFamilyProperties2KHR<'_> {}
unsafe impl Sync for VkVideoQueueFamilyProperties2KHR<'_> {}

impl Default for VkVideoQueueFamilyProperties2KHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoProfilesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub profileCount                                 : u32,
	pub pProfiles                                    : &'a VkVideoProfileKHR<'a>,
}

unsafe impl Send for VkVideoProfilesKHR<'_> {}
unsafe impl Sync for VkVideoProfilesKHR<'_> {}

impl fmt::Debug for VkVideoProfilesKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoProfilesKHR").finish()
	}
}

impl Default for VkVideoProfilesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkPhysicalDeviceVideoFormatInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub imageUsage                                   : VkImageUsageFlags,
	pub pVideoProfiles                               : &'a VkVideoProfilesKHR<'a>,
}

unsafe impl Send for VkPhysicalDeviceVideoFormatInfoKHR<'_> {}
unsafe impl Sync for VkPhysicalDeviceVideoFormatInfoKHR<'_> {}

impl fmt::Debug for VkPhysicalDeviceVideoFormatInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoFormatInfoKHR").finish()
	}
}

impl Default for VkPhysicalDeviceVideoFormatInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkVideoFormatPropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub format                                       : VkFormat,
}

unsafe impl Send for VkVideoFormatPropertiesKHR<'_> {}
unsafe impl Sync for VkVideoFormatPropertiesKHR<'_> {}

impl Default for VkVideoFormatPropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkVideoProfileKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub videoCodecOperation                          : VkVideoCodecOperationFlagBitsKHR,
	pub chromaSubsampling                            : VkVideoChromaSubsamplingFlagsKHR,
	pub lumaBitDepth                                 : VkVideoComponentBitDepthFlagsKHR,
	pub chromaBitDepth                               : VkVideoComponentBitDepthFlagsKHR,
}

unsafe impl Send for VkVideoProfileKHR<'_> {}
unsafe impl Sync for VkVideoProfileKHR<'_> {}

impl Default for VkVideoProfileKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoCapabilitiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub capabilityFlags                              : VkVideoCapabilitiesFlagsKHR,
	pub minBitstreamBufferOffsetAlignment            : VkDeviceSize,
	pub minBitstreamBufferSizeAlignment              : VkDeviceSize,
	pub videoPictureExtentGranularity                : VkExtent2D,
	pub minExtent                                    : VkExtent2D,
	pub maxExtent                                    : VkExtent2D,
	pub maxReferencePicturesSlotsCount               : u32,
	pub maxReferencePicturesActiveCount              : u32,
}

unsafe impl Send for VkVideoCapabilitiesKHR<'_> {}
unsafe impl Sync for VkVideoCapabilitiesKHR<'_> {}

impl fmt::Debug for VkVideoCapabilitiesKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoCapabilitiesKHR").finish()
	}
}

impl Default for VkVideoCapabilitiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoGetMemoryPropertiesKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub memoryBindIndex                              : u32,
	pub pMemoryRequirements                          : &'a mut VkMemoryRequirements2<'a>,
}

unsafe impl Send for VkVideoGetMemoryPropertiesKHR<'_> {}
unsafe impl Sync for VkVideoGetMemoryPropertiesKHR<'_> {}

impl fmt::Debug for VkVideoGetMemoryPropertiesKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoGetMemoryPropertiesKHR").finish()
	}
}

impl Default for VkVideoGetMemoryPropertiesKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoBindMemoryKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub memoryBindIndex                              : u32,
	pub memory                                       : VkDeviceMemory,
	pub memoryOffset                                 : VkDeviceSize,
	pub memorySize                                   : VkDeviceSize,
}

unsafe impl Send for VkVideoBindMemoryKHR<'_> {}
unsafe impl Sync for VkVideoBindMemoryKHR<'_> {}

impl Default for VkVideoBindMemoryKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoPictureResourceKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	/// The offset to be used for the picture resource, currently only used in field mode
	pub codedOffset                                  : VkOffset2D,
	/// The extent to be used for the picture resource
	pub codedExtent                                  : VkExtent2D,
	/// TThe first array layer to be accessed for the Decode or Encode Operations
	pub baseArrayLayer                               : u32,
	/// The ImageView binding of the resource
	pub imageViewBinding                             : VkImageView,
}

unsafe impl Send for VkVideoPictureResourceKHR<'_> {}
unsafe impl Sync for VkVideoPictureResourceKHR<'_> {}

impl fmt::Debug for VkVideoPictureResourceKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoPictureResourceKHR").finish()
	}
}

impl Default for VkVideoPictureResourceKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoReferenceSlotKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	/// The reference slot index
	pub slotIndex                                    : i8,
	/// The reference picture resource
	pub pPictureResource                             : &'a VkVideoPictureResourceKHR<'a>,
}

unsafe impl Send for VkVideoReferenceSlotKHR<'_> {}
unsafe impl Sync for VkVideoReferenceSlotKHR<'_> {}

impl fmt::Debug for VkVideoReferenceSlotKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoReferenceSlotKHR").finish()
	}
}

impl Default for VkVideoReferenceSlotKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoDecodeFlagsKHR,
	pub codedOffset                                  : VkOffset2D,
	pub codedExtent                                  : VkExtent2D,
	pub srcBuffer                                    : VkBuffer,
	pub srcBufferOffset                              : VkDeviceSize,
	pub srcBufferRange                               : VkDeviceSize,
	pub dstPictureResource                           : VkVideoPictureResourceKHR<'a>,
	pub pSetupReferenceSlot                          : &'a VkVideoReferenceSlotKHR<'a>,
	pub referenceSlotCount                           : u32,
	pub pReferenceSlots                              : *const VkVideoReferenceSlotKHR<'a>,
}

unsafe impl Send for VkVideoDecodeInfoKHR<'_> {}
unsafe impl Sync for VkVideoDecodeInfoKHR<'_> {}

impl fmt::Debug for VkVideoDecodeInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeInfoKHR").finish()
	}
}

impl Default for VkVideoDecodeInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}
// Video Decode Codec Standard specific structures

#[repr(C)]
#[derive()]
pub struct VkVideoDecodeH264ProfileEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub stdProfileIdc                                : StdVideoH264ProfileIdc,
	pub fieldLayout                                  : VkVideoDecodeH264FieldLayoutFlagsEXT,
}

unsafe impl Send for VkVideoDecodeH264ProfileEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264ProfileEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264ProfileEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264ProfileEXT").finish()
	}
}

impl Default for VkVideoDecodeH264ProfileEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoDecodeH264CapabilitiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub maxLevel                                     : u32,
	pub fieldOffsetGranularity                       : VkOffset2D,
	pub stdExtensionVersion                          : VkExtensionProperties,
}

unsafe impl Send for VkVideoDecodeH264CapabilitiesEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264CapabilitiesEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264CapabilitiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264CapabilitiesEXT").finish()
	}
}

impl Default for VkVideoDecodeH264CapabilitiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH264SessionCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoDecodeH264CreateFlagsEXT,
	pub pStdExtensionVersion                         : &'a VkExtensionProperties,
}

unsafe impl Send for VkVideoDecodeH264SessionCreateInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264SessionCreateInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264SessionCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264SessionCreateInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH264SessionCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH264SessionParametersAddInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub spsStdCount                                  : u32,
	pub pSpsStd                                      : *const StdVideoH264SequenceParameterSet,
	pub ppsStdCount                                  : u32,
	/// List of Picture Parameters associated with the spsStd, above
	pub pPpsStd                                      : *const StdVideoH264PictureParameterSet,
}

unsafe impl Send for VkVideoDecodeH264SessionParametersAddInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264SessionParametersAddInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264SessionParametersAddInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264SessionParametersAddInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH264SessionParametersAddInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH264SessionParametersCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub maxSpsStdCount                               : u32,
	pub maxPpsStdCount                               : u32,
	pub pParametersAddInfo                           : Option<&'a VkVideoDecodeH264SessionParametersAddInfoEXT<'a>>,
}

unsafe impl Send for VkVideoDecodeH264SessionParametersCreateInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264SessionParametersCreateInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264SessionParametersCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264SessionParametersCreateInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH264SessionParametersCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH264PictureInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub pStdPictureInfo                              : &'a StdVideoDecodeH264PictureInfo,
	pub slicesCount                                  : u32,
	pub pSlicesDataOffsets                           : *const u32,
}

unsafe impl Send for VkVideoDecodeH264PictureInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264PictureInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264PictureInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264PictureInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH264PictureInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH264DpbSlotInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub pStdReferenceInfo                            : &'a StdVideoDecodeH264ReferenceInfo,
}

unsafe impl Send for VkVideoDecodeH264DpbSlotInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264DpbSlotInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264DpbSlotInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264DpbSlotInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH264DpbSlotInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH264MvcEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub pStdMvc                                      : &'a StdVideoDecodeH264Mvc,
}

unsafe impl Send for VkVideoDecodeH264MvcEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH264MvcEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH264MvcEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264MvcEXT").finish()
	}
}

impl Default for VkVideoDecodeH264MvcEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoDecodeH265ProfileEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub stdProfileIdc                                : StdVideoH265ProfileIdc,
}

unsafe impl Send for VkVideoDecodeH265ProfileEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265ProfileEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265ProfileEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265ProfileEXT").finish()
	}
}

impl Default for VkVideoDecodeH265ProfileEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoDecodeH265CapabilitiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub maxLevel                                     : u32,
	pub stdExtensionVersion                          : VkExtensionProperties,
}

unsafe impl Send for VkVideoDecodeH265CapabilitiesEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265CapabilitiesEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265CapabilitiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265CapabilitiesEXT").finish()
	}
}

impl Default for VkVideoDecodeH265CapabilitiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH265SessionCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoDecodeH265CreateFlagsEXT,
	pub pStdExtensionVersion                         : &'a VkExtensionProperties,
}

unsafe impl Send for VkVideoDecodeH265SessionCreateInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265SessionCreateInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265SessionCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265SessionCreateInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH265SessionCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH265SessionParametersAddInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub spsStdCount                                  : u32,
	pub pSpsStd                                      : *const StdVideoH265SequenceParameterSet,
	pub ppsStdCount                                  : u32,
	/// List of Picture Parameters associated with the spsStd, above
	pub pPpsStd                                      : *const StdVideoH265PictureParameterSet,
}

unsafe impl Send for VkVideoDecodeH265SessionParametersAddInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265SessionParametersAddInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265SessionParametersAddInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265SessionParametersAddInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH265SessionParametersAddInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH265SessionParametersCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub maxSpsStdCount                               : u32,
	pub maxPpsStdCount                               : u32,
	pub pParametersAddInfo                           : Option<&'a VkVideoDecodeH265SessionParametersAddInfoEXT<'a>>,
}

unsafe impl Send for VkVideoDecodeH265SessionParametersCreateInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265SessionParametersCreateInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265SessionParametersCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265SessionParametersCreateInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH265SessionParametersCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoDecodeH265PictureInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub pStdPictureInfo                              : &'a mut StdVideoDecodeH265PictureInfo,
	pub slicesCount                                  : u32,
	pub pSlicesDataOffsets                           : *const u32,
}

unsafe impl Send for VkVideoDecodeH265PictureInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265PictureInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265PictureInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265PictureInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH265PictureInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoDecodeH265DpbSlotInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub pStdReferenceInfo                            : &'a StdVideoDecodeH265ReferenceInfo,
}

unsafe impl Send for VkVideoDecodeH265DpbSlotInfoEXT<'_> {}
unsafe impl Sync for VkVideoDecodeH265DpbSlotInfoEXT<'_> {}

impl fmt::Debug for VkVideoDecodeH265DpbSlotInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265DpbSlotInfoEXT").finish()
	}
}

impl Default for VkVideoDecodeH265DpbSlotInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoSessionCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub queueFamilyIndex                             : u32,
	pub flags                                        : VkVideoSessionCreateFlagsKHR,
	pub pVideoProfile                                : &'a VkVideoProfileKHR<'a>,
	pub pictureFormat                                : VkFormat,
	pub maxCodedExtent                               : VkExtent2D,
	pub referencePicturesFormat                      : VkFormat,
	pub maxReferencePicturesSlotsCount               : u32,
	pub maxReferencePicturesActiveCount              : u32,
}

unsafe impl Send for VkVideoSessionCreateInfoKHR<'_> {}
unsafe impl Sync for VkVideoSessionCreateInfoKHR<'_> {}

impl fmt::Debug for VkVideoSessionCreateInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoSessionCreateInfoKHR").finish()
	}
}

impl Default for VkVideoSessionCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoSessionParametersCreateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub videoSessionParametersTemplate               : VkVideoSessionParametersKHR,
	pub videoSession                                 : VkVideoSessionKHR,
}

unsafe impl Send for VkVideoSessionParametersCreateInfoKHR<'_> {}
unsafe impl Sync for VkVideoSessionParametersCreateInfoKHR<'_> {}

impl Default for VkVideoSessionParametersCreateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoSessionParametersUpdateInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub updateSequenceCount                          : u32,
}

unsafe impl Send for VkVideoSessionParametersUpdateInfoKHR<'_> {}
unsafe impl Sync for VkVideoSessionParametersUpdateInfoKHR<'_> {}

impl Default for VkVideoSessionParametersUpdateInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoBeginCodingInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoBeginCodingFlagsKHR,
	pub codecQualityPreset                           : VkVideoCodingQualityPresetFlagsKHR,
	pub videoSession                                 : VkVideoSessionKHR,
	pub videoSessionParameters                       : VkVideoSessionParametersKHR,
	pub referenceSlotCount                           : u32,
	pub pReferenceSlots                              : *const VkVideoReferenceSlotKHR<'a>,
}

unsafe impl Send for VkVideoBeginCodingInfoKHR<'_> {}
unsafe impl Sync for VkVideoBeginCodingInfoKHR<'_> {}

impl fmt::Debug for VkVideoBeginCodingInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoBeginCodingInfoKHR").finish()
	}
}

impl Default for VkVideoBeginCodingInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoEndCodingInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoEndCodingFlagsKHR,
}

unsafe impl Send for VkVideoEndCodingInfoKHR<'_> {}
unsafe impl Sync for VkVideoEndCodingInfoKHR<'_> {}

impl Default for VkVideoEndCodingInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoCodingControlInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoCodingControlFlagsKHR,
}

unsafe impl Send for VkVideoCodingControlInfoKHR<'_> {}
unsafe impl Sync for VkVideoCodingControlInfoKHR<'_> {}

impl Default for VkVideoCodingControlInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoEncodeFlagsKHR,
	pub qualityLevel                                 : u32,
	pub codedExtent                                  : VkExtent2D,
	pub dstBitstreamBuffer                           : VkBuffer,
	pub dstBitstreamBufferOffset                     : VkDeviceSize,
	pub dstBitstreamBufferMaxRange                   : VkDeviceSize,
	pub srcPictureResource                           : VkVideoPictureResourceKHR<'a>,
	pub pSetupReferenceSlot                          : &'a VkVideoReferenceSlotKHR<'a>,
	pub referenceSlotCount                           : u32,
	pub pReferenceSlots                              : *const VkVideoReferenceSlotKHR<'a>,
}

unsafe impl Send for VkVideoEncodeInfoKHR<'_> {}
unsafe impl Sync for VkVideoEncodeInfoKHR<'_> {}

impl fmt::Debug for VkVideoEncodeInfoKHR<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeInfoKHR").finish()
	}
}

impl Default for VkVideoEncodeInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoEncodeRateControlInfoKHR<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoEncodeRateControlFlagsKHR,
	pub rateControlMode                              : VkVideoEncodeRateControlModeFlagBitsKHR,
	pub averageBitrate                               : u32,
	pub peakToAverageBitrateRatio                    : u16,
	pub frameRateNumerator                           : u16,
	pub frameRateDenominator                         : u16,
	pub virtualBufferSizeInMs                        : u32,
}

unsafe impl Send for VkVideoEncodeRateControlInfoKHR<'_> {}
unsafe impl Sync for VkVideoEncodeRateControlInfoKHR<'_> {}

impl Default for VkVideoEncodeRateControlInfoKHR<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264CapabilitiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoEncodeH264CapabilitiesFlagsEXT,
	pub inputModeFlags                               : VkVideoEncodeH264InputModeFlagsEXT,
	pub outputModeFlags                              : VkVideoEncodeH264OutputModeFlagsEXT,
	pub minPictureSizeInMbs                          : VkExtent2D,
	pub maxPictureSizeInMbs                          : VkExtent2D,
	pub inputImageDataAlignment                      : VkExtent2D,
	pub maxNumL0ReferenceForP                        : u8,
	pub maxNumL0ReferenceForB                        : u8,
	pub maxNumL1Reference                            : u8,
	pub qualityLevelCount                            : u8,
	pub stdExtensionVersion                          : VkExtensionProperties,
}

unsafe impl Send for VkVideoEncodeH264CapabilitiesEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264CapabilitiesEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264CapabilitiesEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264CapabilitiesEXT").finish()
	}
}

impl Default for VkVideoEncodeH264CapabilitiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264SessionCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub flags                                        : VkVideoEncodeH264CreateFlagsEXT,
	pub maxPictureSizeInMbs                          : VkExtent2D,
	pub pStdExtensionVersion                         : &'a VkExtensionProperties,
}

unsafe impl Send for VkVideoEncodeH264SessionCreateInfoEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264SessionCreateInfoEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264SessionCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionCreateInfoEXT").finish()
	}
}

impl Default for VkVideoEncodeH264SessionCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264SessionParametersAddInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub spsStdCount                                  : u32,
	pub pSpsStd                                      : *const StdVideoH264SequenceParameterSet,
	pub ppsStdCount                                  : u32,
	/// List of Picture Parameters associated with the spsStd, above
	pub pPpsStd                                      : *const StdVideoH264PictureParameterSet,
}

unsafe impl Send for VkVideoEncodeH264SessionParametersAddInfoEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264SessionParametersAddInfoEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264SessionParametersAddInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionParametersAddInfoEXT").finish()
	}
}

impl Default for VkVideoEncodeH264SessionParametersAddInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264SessionParametersCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub maxSpsStdCount                               : u32,
	pub maxPpsStdCount                               : u32,
	pub pParametersAddInfo                           : Option<&'a VkVideoEncodeH264SessionParametersAddInfoEXT<'a>>,
}

unsafe impl Send for VkVideoEncodeH264SessionParametersCreateInfoEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264SessionParametersCreateInfoEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264SessionParametersCreateInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionParametersCreateInfoEXT").finish()
	}
}

impl Default for VkVideoEncodeH264SessionParametersCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264DpbSlotInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub slotIndex                                    : i8,
	pub pStdPictureInfo                              : &'a StdVideoEncodeH264PictureInfo,
}

unsafe impl Send for VkVideoEncodeH264DpbSlotInfoEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264DpbSlotInfoEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264DpbSlotInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264DpbSlotInfoEXT").finish()
	}
}

impl Default for VkVideoEncodeH264DpbSlotInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264VclFrameInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub refDefaultFinalList0EntryCount               : u8,
	pub pRefDefaultFinalList0Entries                 : *const VkVideoEncodeH264DpbSlotInfoEXT<'a>,
	pub refDefaultFinalList1EntryCount               : u8,
	pub pRefDefaultFinalList1Entries                 : *const VkVideoEncodeH264DpbSlotInfoEXT<'a>,
	pub naluSliceEntryCount                          : u32,
	pub pNaluSliceEntries                            : *const VkVideoEncodeH264NaluSliceEXT<'a>,
	pub pCurrentPictureInfo                          : &'a VkVideoEncodeH264DpbSlotInfoEXT<'a>,
}

unsafe impl Send for VkVideoEncodeH264VclFrameInfoEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264VclFrameInfoEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264VclFrameInfoEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264VclFrameInfoEXT").finish()
	}
}

impl Default for VkVideoEncodeH264VclFrameInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVideoEncodeH264EmitPictureParametersEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub spsId                                        : u8,
	pub emitSpsEnable                                : VkBool32,
	pub ppsIdEntryCount                              : u32,
	pub ppsIdEntries                                 : *const u8,
}

unsafe impl Send for VkVideoEncodeH264EmitPictureParametersEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264EmitPictureParametersEXT<'_> {}

impl Default for VkVideoEncodeH264EmitPictureParametersEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive()]
pub struct VkVideoEncodeH264ProfileEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub stdProfileIdc                                : StdVideoH264ProfileIdc,
}

unsafe impl Send for VkVideoEncodeH264ProfileEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264ProfileEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264ProfileEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264ProfileEXT").finish()
	}
}

impl Default for VkVideoEncodeH264ProfileEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkVideoEncodeH264NaluSliceEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub pSliceHeaderStd                              : &'a StdVideoEncodeH264SliceHeader,
	pub mbCount                                      : u32,
	pub refFinalList0EntryCount                      : u8,
	pub pRefFinalList0Entries                        : *const VkVideoEncodeH264DpbSlotInfoEXT<'a>,
	pub refFinalList1EntryCount                      : u8,
	pub pRefFinalList1Entries                        : *const VkVideoEncodeH264DpbSlotInfoEXT<'a>,
	pub precedingNaluBytes                           : u32,
	pub minQp                                        : u8,
	pub maxQp                                        : u8,
}

unsafe impl Send for VkVideoEncodeH264NaluSliceEXT<'_> {}
unsafe impl Sync for VkVideoEncodeH264NaluSliceEXT<'_> {}

impl fmt::Debug for VkVideoEncodeH264NaluSliceEXT<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264NaluSliceEXT").finish()
	}
}

impl Default for VkVideoEncodeH264NaluSliceEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub inheritedViewportScissor2D                   : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceInheritedViewportScissorFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceInheritedViewportScissorFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceInheritedViewportScissorFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCommandBufferInheritanceViewportScissorInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub viewportScissor2D                            : VkBool32,
	pub viewportDepthCount                           : u32,
	pub pViewportDepths                              : &'a VkViewport,
}

unsafe impl Send for VkCommandBufferInheritanceViewportScissorInfoNV<'_> {}
unsafe impl Sync for VkCommandBufferInheritanceViewportScissorInfoNV<'_> {}

impl fmt::Debug for VkCommandBufferInheritanceViewportScissorInfoNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceViewportScissorInfoNV").finish()
	}
}

impl Default for VkCommandBufferInheritanceViewportScissorInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyMut<'a>>,
	pub ycbcr2plane444Formats                        : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceProvokingVertexFeaturesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub provokingVertexLast                          : VkBool32,
	pub transformFeedbackPreservesProvokingVertex    : VkBool32,
}

unsafe impl Send for VkPhysicalDeviceProvokingVertexFeaturesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceProvokingVertexFeaturesEXT<'_> {}

impl Default for VkPhysicalDeviceProvokingVertexFeaturesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceProvokingVertexPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub provokingVertexModePerPipeline               : VkBool32,
	pub transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32,
}

unsafe impl Send for VkPhysicalDeviceProvokingVertexPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceProvokingVertexPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceProvokingVertexPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub provokingVertexMode                          : VkProvokingVertexModeEXT,
}

unsafe impl Send for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT<'_> {}
unsafe impl Sync for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT<'_> {}

impl Default for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCuModuleCreateInfoNVX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub dataSize                                     : usize,
	pub pData                                        : VkAnyRef<'a>,
}

unsafe impl Send for VkCuModuleCreateInfoNVX<'_> {}
unsafe impl Sync for VkCuModuleCreateInfoNVX<'_> {}

impl Default for VkCuModuleCreateInfoNVX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCuFunctionCreateInfoNVX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub module                                       : VkCuModuleNVX,
	pub pName                                        : *const u8,
}

unsafe impl Send for VkCuFunctionCreateInfoNVX<'_> {}
unsafe impl Sync for VkCuFunctionCreateInfoNVX<'_> {}

impl Default for VkCuFunctionCreateInfoNVX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCuLaunchInfoNVX<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyRef<'a>,
	pub function                                     : VkCuFunctionNVX,
	pub gridDimX                                     : u32,
	pub gridDimY                                     : u32,
	pub gridDimZ                                     : u32,
	pub blockDimX                                    : u32,
	pub blockDimY                                    : u32,
	pub blockDimZ                                    : u32,
	pub sharedMemBytes                               : u32,
	pub paramCount                                   : usize,
	pub pParams                                      : (),
	pub extraCount                                   : usize,
	pub pExtras                                      : (),
}

unsafe impl Send for VkCuLaunchInfoNVX<'_> {}
unsafe impl Sync for VkCuLaunchInfoNVX<'_> {}

impl Default for VkCuLaunchInfoNVX<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceDrmPropertiesEXT<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub hasPrimary                                   : VkBool32,
	pub hasRender                                    : VkBool32,
	pub primaryMajor                                 : i64,
	pub primaryMinor                                 : i64,
	pub renderMajor                                  : i64,
	pub renderMinor                                  : i64,
}

unsafe impl Send for VkPhysicalDeviceDrmPropertiesEXT<'_> {}
unsafe impl Sync for VkPhysicalDeviceDrmPropertiesEXT<'_> {}

impl Default for VkPhysicalDeviceDrmPropertiesEXT<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Debug)]
pub struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : VkAnyMut<'a>,
	pub rayTracingMotionBlur                         : VkBool32,
	pub rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32,
}

unsafe impl Send for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV<'_> {}
unsafe impl Sync for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV<'_> {}

impl Default for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryMotionTrianglesDataNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub vertexData                                   : VkDeviceOrHostAddressConstKHR<'a>,
}

unsafe impl Send for VkAccelerationStructureGeometryMotionTrianglesDataNV<'_> {}
unsafe impl Sync for VkAccelerationStructureGeometryMotionTrianglesDataNV<'_> {}

impl fmt::Debug for VkAccelerationStructureGeometryMotionTrianglesDataNV<'_> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryMotionTrianglesDataNV").finish()
	}
}

impl Default for VkAccelerationStructureGeometryMotionTrianglesDataNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAccelerationStructureMotionInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub maxInstances                                 : u32,
	pub flags                                        : VkAccelerationStructureMotionInfoFlagsNV,
}

unsafe impl Send for VkAccelerationStructureMotionInfoNV<'_> {}
unsafe impl Sync for VkAccelerationStructureMotionInfoNV<'_> {}

impl Default for VkAccelerationStructureMotionInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default)]
pub struct VkSRTDataNV {
	pub sx                                           : f32,
	pub a                                            : f32,
	pub b                                            : f32,
	pub pvx                                          : f32,
	pub sy                                           : f32,
	pub c                                            : f32,
	pub pvy                                          : f32,
	pub sz                                           : f32,
	pub pvz                                          : f32,
	pub qx                                           : f32,
	pub qy                                           : f32,
	pub qz                                           : f32,
	pub qw                                           : f32,
	pub tx                                           : f32,
	pub ty                                           : f32,
	pub tz                                           : f32,
}

unsafe impl Send for VkSRTDataNV {}
unsafe impl Sync for VkSRTDataNV {}


#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureSRTMotionInstanceNV {
	pub transformT0                                  : VkSRTDataNV,
	pub transformT1                                  : VkSRTDataNV,
	pub instanceCustomIndex                          : u32,
	pub mask                                         : u32,
	pub instanceShaderBindingTableRecordOffset       : u32,
	pub flags                                        : VkGeometryInstanceFlagsKHR,
	pub accelerationStructureReference               : u64,
}

unsafe impl Send for VkAccelerationStructureSRTMotionInstanceNV {}
unsafe impl Sync for VkAccelerationStructureSRTMotionInstanceNV {}

impl fmt::Debug for VkAccelerationStructureSRTMotionInstanceNV {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureSRTMotionInstanceNV").finish()
	}
}

impl Default for VkAccelerationStructureSRTMotionInstanceNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureMatrixMotionInstanceNV {
	pub transformT0                                  : VkTransformMatrixKHR,
	pub transformT1                                  : VkTransformMatrixKHR,
	pub instanceCustomIndex                          : u32,
	pub mask                                         : u32,
	pub instanceShaderBindingTableRecordOffset       : u32,
	pub flags                                        : VkGeometryInstanceFlagsKHR,
	pub accelerationStructureReference               : u64,
}

unsafe impl Send for VkAccelerationStructureMatrixMotionInstanceNV {}
unsafe impl Sync for VkAccelerationStructureMatrixMotionInstanceNV {}

impl fmt::Debug for VkAccelerationStructureMatrixMotionInstanceNV {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMatrixMotionInstanceNV").finish()
	}
}

impl Default for VkAccelerationStructureMatrixMotionInstanceNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union VkAccelerationStructureMotionInstanceDataNV {
	pub staticInstance                               : VkAccelerationStructureInstanceKHR,
	pub matrixMotionInstance                         : VkAccelerationStructureMatrixMotionInstanceNV,
	pub srtMotionInstance                            : VkAccelerationStructureSRTMotionInstanceNV,
}

unsafe impl Send for VkAccelerationStructureMotionInstanceDataNV {}
unsafe impl Sync for VkAccelerationStructureMotionInstanceDataNV {}

impl fmt::Debug for VkAccelerationStructureMotionInstanceDataNV {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMotionInstanceDataNV").finish()
	}
}

impl Default for VkAccelerationStructureMotionInstanceDataNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureMotionInstanceNV {
	pub r#type                                       : VkAccelerationStructureMotionInstanceTypeNV,
	pub flags                                        : VkAccelerationStructureMotionInstanceFlagsNV,
	pub data                                         : VkAccelerationStructureMotionInstanceDataNV,
}

unsafe impl Send for VkAccelerationStructureMotionInstanceNV {}
unsafe impl Sync for VkAccelerationStructureMotionInstanceNV {}

impl fmt::Debug for VkAccelerationStructureMotionInstanceNV {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMotionInstanceNV").finish()
	}
}

impl Default for VkAccelerationStructureMotionInstanceNV {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}

pub type VkRemoteAddressNV                             = ();

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryGetRemoteAddressInfoNV<'a> {
	pub sType                                        : VkStructureType,
	pub pNext                                        : Option<VkAnyRef<'a>>,
	pub memory                                       : VkDeviceMemory,
	pub handleType                                   : VkExternalMemoryHandleTypeFlagBits,
}

unsafe impl Send for VkMemoryGetRemoteAddressInfoNV<'_> {}
unsafe impl Sync for VkMemoryGetRemoteAddressInfoNV<'_> {}

impl Default for VkMemoryGetRemoteAddressInfoNV<'_> {
	fn default() -> Self {
		unsafe { MaybeUninit::zeroed().assume_init() }
	}
}
// Vulkan enumerant (token) definitions

/// Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate

pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE                  : i32 = 256;
pub const VK_UUID_SIZE                                      : i32 = 16;
pub const VK_LUID_SIZE                                      : i32 = 8;
pub const VK_LUID_SIZE_KHR                                  : i32 = VK_LUID_SIZE;
pub const VK_MAX_EXTENSION_NAME_SIZE                        : i32 = 256;
pub const VK_MAX_DESCRIPTION_SIZE                           : i32 = 256;
pub const VK_MAX_MEMORY_TYPES                               : i32 = 32;
/// The maximum number of unique memory heaps, each of which supporting 1 or more memory types
pub const VK_MAX_MEMORY_HEAPS                               : i32 = 16;
pub const VK_LOD_CLAMP_NONE                                 : f32 = 1000.0f32;
pub const VK_REMAINING_MIP_LEVELS                           : u32 = (!0u32);
pub const VK_REMAINING_ARRAY_LAYERS                         : u32 = (!0u32);
pub const VK_WHOLE_SIZE                                     : u64 = (!0u64);
pub const VK_ATTACHMENT_UNUSED                              : u32 = (!0u32);
pub const VK_TRUE                                           : u32 = 1u32;
pub const VK_FALSE                                          : u32 = 0u32;
pub const VK_QUEUE_FAMILY_IGNORED                           : u32 = (!0u32);
pub const VK_QUEUE_FAMILY_EXTERNAL                          : u32 = (!1u32);
pub const VK_QUEUE_FAMILY_EXTERNAL_KHR                      : u32 = VK_QUEUE_FAMILY_EXTERNAL;
pub const VK_QUEUE_FAMILY_FOREIGN_EXT                       : u32 = (!2u32);
pub const VK_SUBPASS_EXTERNAL                               : u32 = (!0u32);
pub const VK_MAX_DEVICE_GROUP_SIZE                          : i32 = 32;
pub const VK_MAX_DEVICE_GROUP_SIZE_KHR                      : i32 = VK_MAX_DEVICE_GROUP_SIZE;
pub const VK_MAX_DRIVER_NAME_SIZE                           : i32 = 256;
pub const VK_MAX_DRIVER_NAME_SIZE_KHR                       : i32 = VK_MAX_DRIVER_NAME_SIZE;
pub const VK_MAX_DRIVER_INFO_SIZE                           : i32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE_KHR                       : i32 = VK_MAX_DRIVER_INFO_SIZE;
pub const VK_SHADER_UNUSED_KHR                              : u32 = (!0u32);
pub const VK_SHADER_UNUSED_NV                               : u32 = VK_SHADER_UNUSED_KHR;
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT                   : i32 = 16;
// Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
// their own numeric namespaces. The "name" attribute is the C enum
// type name, and is pulled in from a type tag definition above
// (slightly clunky, but retains the type / enum distinction). "type"
// attributes of "enum" or "bitmask" indicate that these values should
// be generated inside an appropriate definition.

pub use self::VkImageLayout::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageLayout {
	/// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
	VK_IMAGE_LAYOUT_UNDEFINED                                                        = 0,
	/// General layout when image can be used for any kind of access
	VK_IMAGE_LAYOUT_GENERAL                                                          = 1,
	/// Optimal layout when image is only used for color attachment read/write
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                                         = 2,
	/// Optimal layout when image is only used for depth/stencil attachment read/write
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL                                 = 3,
	/// Optimal layout when image is used for read only depth/stencil attachment and shader access
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL                                  = 4,
	/// Optimal layout when image is used for read only shader access
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                                         = 5,
	/// Optimal layout when image is used only as source of transfer operations
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                                             = 6,
	/// Optimal layout when image is used only as destination of transfer operations
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                                             = 7,
	/// Initial layout used when the data is populated by the CPU
	VK_IMAGE_LAYOUT_PREINITIALIZED                                                   = 8,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL                       = 1000117000,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL                       = 1000117001,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL                                         = 1000241000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL                                          = 1000241001,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL                                       = 1000241002,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL                                        = 1000241003,
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                                                  = 1000001002,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR                                             = 1000024000,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR                                             = 1000024001,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR                                             = 1000024002,
	VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR                                               = 1000111000,
	VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT                                 = 1000218000,
	VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR                     = 1000164003,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR                                             = 1000299000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR                                             = 1000299001,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR                                             = 1000299002,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR                                            = 1000314000,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR                                           = 1000314001,
}

impl Default for VkImageLayout {
	fn default() -> Self {
		Self::VK_IMAGE_LAYOUT_UNDEFINED
	}
}

pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR                  : VkImageLayout = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR                  : VkImageLayout = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
pub const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV                                         : VkImageLayout = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR                                    : VkImageLayout = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL;
pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR                                     : VkImageLayout = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL;
pub const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR                                  : VkImageLayout = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL;
pub const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR                                   : VkImageLayout = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL;

pub use self::VkAttachmentLoadOp::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAttachmentLoadOp {
	VK_ATTACHMENT_LOAD_OP_LOAD                                                       = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR                                                      = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE                                                  = 2,
}

impl Default for VkAttachmentLoadOp {
	fn default() -> Self {
		Self::VK_ATTACHMENT_LOAD_OP_LOAD
	}
}

pub use self::VkAttachmentStoreOp::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAttachmentStoreOp {
	VK_ATTACHMENT_STORE_OP_STORE                                                     = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE                                                 = 1,
	VK_ATTACHMENT_STORE_OP_NONE_QCOM                                                 = 1000301000,
}

impl Default for VkAttachmentStoreOp {
	fn default() -> Self {
		Self::VK_ATTACHMENT_STORE_OP_STORE
	}
}

pub use self::VkImageType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageType {
	VK_IMAGE_TYPE_1D                                                                 = 0,
	VK_IMAGE_TYPE_2D                                                                 = 1,
	VK_IMAGE_TYPE_3D                                                                 = 2,
}

impl Default for VkImageType {
	fn default() -> Self {
		Self::VK_IMAGE_TYPE_1D
	}
}

pub use self::VkImageTiling::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageTiling {
	VK_IMAGE_TILING_OPTIMAL                                                          = 0,
	VK_IMAGE_TILING_LINEAR                                                           = 1,
	VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT                                          = 1000158000,
}

impl Default for VkImageTiling {
	fn default() -> Self {
		Self::VK_IMAGE_TILING_OPTIMAL
	}
}

pub use self::VkImageViewType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageViewType {
	VK_IMAGE_VIEW_TYPE_1D                                                            = 0,
	VK_IMAGE_VIEW_TYPE_2D                                                            = 1,
	VK_IMAGE_VIEW_TYPE_3D                                                            = 2,
	VK_IMAGE_VIEW_TYPE_CUBE                                                          = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY                                                      = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY                                                      = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY                                                    = 6,
}

impl Default for VkImageViewType {
	fn default() -> Self {
		Self::VK_IMAGE_VIEW_TYPE_1D
	}
}

pub use self::VkCommandBufferLevel::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCommandBufferLevel {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY                                                  = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY                                                = 1,
}

impl Default for VkCommandBufferLevel {
	fn default() -> Self {
		Self::VK_COMMAND_BUFFER_LEVEL_PRIMARY
	}
}

pub use self::VkComponentSwizzle::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkComponentSwizzle {
	VK_COMPONENT_SWIZZLE_IDENTITY                                                    = 0,
	VK_COMPONENT_SWIZZLE_ZERO                                                        = 1,
	VK_COMPONENT_SWIZZLE_ONE                                                         = 2,
	VK_COMPONENT_SWIZZLE_R                                                           = 3,
	VK_COMPONENT_SWIZZLE_G                                                           = 4,
	VK_COMPONENT_SWIZZLE_B                                                           = 5,
	VK_COMPONENT_SWIZZLE_A                                                           = 6,
}

impl Default for VkComponentSwizzle {
	fn default() -> Self {
		Self::VK_COMPONENT_SWIZZLE_IDENTITY
	}
}

pub use self::VkDescriptorType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDescriptorType {
	VK_DESCRIPTOR_TYPE_SAMPLER                                                       = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER                                        = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE                                                 = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE                                                 = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER                                          = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER                                          = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER                                                = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER                                                = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC                                        = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC                                        = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT                                              = 10,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT                                      = 1000138000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR                                    = 1000150000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV                                     = 1000165000,
	VK_DESCRIPTOR_TYPE_MUTABLE_VALVE                                                 = 1000351000,
}

impl Default for VkDescriptorType {
	fn default() -> Self {
		Self::VK_DESCRIPTOR_TYPE_SAMPLER
	}
}

pub use self::VkQueryType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueryType {
	VK_QUERY_TYPE_OCCLUSION                                                          = 0,
	/// Optional
	VK_QUERY_TYPE_PIPELINE_STATISTICS                                                = 1,
	VK_QUERY_TYPE_TIMESTAMP                                                          = 2,
	VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR                                             = 1000023000,
	VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT                                      = 1000028004,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR                                              = 1000116000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR                          = 1000150000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR                      = 1000150001,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV                           = 1000165000,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL                                            = 1000210000,
	VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR                            = 1000299000,
}

impl Default for VkQueryType {
	fn default() -> Self {
		Self::VK_QUERY_TYPE_OCCLUSION
	}
}

pub use self::VkBorderColor::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBorderColor {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK                                          = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK                                            = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK                                               = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK                                                 = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE                                               = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE                                                 = 5,
	VK_BORDER_COLOR_FLOAT_CUSTOM_EXT                                                 = 1000287003,
	VK_BORDER_COLOR_INT_CUSTOM_EXT                                                   = 1000287004,
}

impl Default for VkBorderColor {
	fn default() -> Self {
		Self::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK
	}
}

pub use self::VkPipelineBindPoint::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineBindPoint {
	VK_PIPELINE_BIND_POINT_GRAPHICS                                                  = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE                                                   = 1,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR                                           = 1000165000,
	VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI                                    = 1000369003,
}

impl Default for VkPipelineBindPoint {
	fn default() -> Self {
		Self::VK_PIPELINE_BIND_POINT_GRAPHICS
	}
}

pub const VK_PIPELINE_BIND_POINT_RAY_TRACING_NV                                           : VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR;

pub use self::VkPipelineCacheHeaderVersion::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineCacheHeaderVersion {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE                                             = 1,
}

impl Default for VkPipelineCacheHeaderVersion {
	fn default() -> Self {
		Self::VK_PIPELINE_CACHE_HEADER_VERSION_ONE
	}
}

pub use self::VkPipelineCacheCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineCacheCreateFlagBits {
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT                         = 0x1,
}

impl Default for VkPipelineCacheCreateFlagBits {
	fn default() -> Self {
		Self::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT
	}
}

pub use self::VkPrimitiveTopology::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPrimitiveTopology {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST                                                 = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST                                                  = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                                                 = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                                              = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                                             = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                                               = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY                                   = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY                                  = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY                               = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY                              = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                                                 = 10,
}

impl Default for VkPrimitiveTopology {
	fn default() -> Self {
		Self::VK_PRIMITIVE_TOPOLOGY_POINT_LIST
	}
}

pub use self::VkSharingMode::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSharingMode {
	VK_SHARING_MODE_EXCLUSIVE                                                        = 0,
	VK_SHARING_MODE_CONCURRENT                                                       = 1,
}

impl Default for VkSharingMode {
	fn default() -> Self {
		Self::VK_SHARING_MODE_EXCLUSIVE
	}
}

pub use self::VkIndexType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkIndexType {
	VK_INDEX_TYPE_UINT16                                                             = 0,
	VK_INDEX_TYPE_UINT32                                                             = 1,
	VK_INDEX_TYPE_NONE_KHR                                                           = 1000165000,
	VK_INDEX_TYPE_UINT8_EXT                                                          = 1000265000,
}

impl Default for VkIndexType {
	fn default() -> Self {
		Self::VK_INDEX_TYPE_UINT16
	}
}

pub const VK_INDEX_TYPE_NONE_NV                                                           : VkIndexType = VK_INDEX_TYPE_NONE_KHR;

pub use self::VkFilter::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFilter {
	VK_FILTER_NEAREST                                                                = 0,
	VK_FILTER_LINEAR                                                                 = 1,
	VK_FILTER_CUBIC_IMG                                                              = 1000015000,
}

impl Default for VkFilter {
	fn default() -> Self {
		Self::VK_FILTER_NEAREST
	}
}

pub const VK_FILTER_CUBIC_EXT                                                             : VkFilter = VK_FILTER_CUBIC_IMG;

pub use self::VkSamplerMipmapMode::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSamplerMipmapMode {
	/// Choose nearest mip level
	VK_SAMPLER_MIPMAP_MODE_NEAREST                                                   = 0,
	/// Linear filter between mip levels
	VK_SAMPLER_MIPMAP_MODE_LINEAR                                                    = 1,
}

impl Default for VkSamplerMipmapMode {
	fn default() -> Self {
		Self::VK_SAMPLER_MIPMAP_MODE_NEAREST
	}
}

pub use self::VkSamplerAddressMode::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSamplerAddressMode {
	VK_SAMPLER_ADDRESS_MODE_REPEAT                                                   = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT                                          = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE                                            = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER                                          = 3,
	// value="4" reserved for VK_KHR_sampler_mirror_clamp_to_edge
	// enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; do not
	// alias!
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE                                     = 4,
}

impl Default for VkSamplerAddressMode {
	fn default() -> Self {
		Self::VK_SAMPLER_ADDRESS_MODE_REPEAT
	}
}

pub const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR                                : VkSamplerAddressMode = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;

pub use self::VkCompareOp::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCompareOp {
	VK_COMPARE_OP_NEVER                                                              = 0,
	VK_COMPARE_OP_LESS                                                               = 1,
	VK_COMPARE_OP_EQUAL                                                              = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL                                                      = 3,
	VK_COMPARE_OP_GREATER                                                            = 4,
	VK_COMPARE_OP_NOT_EQUAL                                                          = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL                                                   = 6,
	VK_COMPARE_OP_ALWAYS                                                             = 7,
}

impl Default for VkCompareOp {
	fn default() -> Self {
		Self::VK_COMPARE_OP_NEVER
	}
}

pub use self::VkPolygonMode::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPolygonMode {
	VK_POLYGON_MODE_FILL                                                             = 0,
	VK_POLYGON_MODE_LINE                                                             = 1,
	VK_POLYGON_MODE_POINT                                                            = 2,
	VK_POLYGON_MODE_FILL_RECTANGLE_NV                                                = 1000153000,
}

impl Default for VkPolygonMode {
	fn default() -> Self {
		Self::VK_POLYGON_MODE_FILL
	}
}

pub use self::VkFrontFace::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFrontFace {
	VK_FRONT_FACE_COUNTER_CLOCKWISE                                                  = 0,
	VK_FRONT_FACE_CLOCKWISE                                                          = 1,
}

impl Default for VkFrontFace {
	fn default() -> Self {
		Self::VK_FRONT_FACE_COUNTER_CLOCKWISE
	}
}

pub use self::VkBlendFactor::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBlendFactor {
	VK_BLEND_FACTOR_ZERO                                                             = 0,
	VK_BLEND_FACTOR_ONE                                                              = 1,
	VK_BLEND_FACTOR_SRC_COLOR                                                        = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR                                              = 3,
	VK_BLEND_FACTOR_DST_COLOR                                                        = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR                                              = 5,
	VK_BLEND_FACTOR_SRC_ALPHA                                                        = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA                                              = 7,
	VK_BLEND_FACTOR_DST_ALPHA                                                        = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA                                              = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR                                                   = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR                                         = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA                                                   = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA                                         = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE                                               = 14,
	VK_BLEND_FACTOR_SRC1_COLOR                                                       = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR                                             = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA                                                       = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA                                             = 18,
}

impl Default for VkBlendFactor {
	fn default() -> Self {
		Self::VK_BLEND_FACTOR_ZERO
	}
}

pub use self::VkBlendOp::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBlendOp {
	VK_BLEND_OP_ADD                                                                  = 0,
	VK_BLEND_OP_SUBTRACT                                                             = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT                                                     = 2,
	VK_BLEND_OP_MIN                                                                  = 3,
	VK_BLEND_OP_MAX                                                                  = 4,
	VK_BLEND_OP_ZERO_EXT                                                             = 1000148000,
	VK_BLEND_OP_SRC_EXT                                                              = 1000148001,
	VK_BLEND_OP_DST_EXT                                                              = 1000148002,
	VK_BLEND_OP_SRC_OVER_EXT                                                         = 1000148003,
	VK_BLEND_OP_DST_OVER_EXT                                                         = 1000148004,
	VK_BLEND_OP_SRC_IN_EXT                                                           = 1000148005,
	VK_BLEND_OP_DST_IN_EXT                                                           = 1000148006,
	VK_BLEND_OP_SRC_OUT_EXT                                                          = 1000148007,
	VK_BLEND_OP_DST_OUT_EXT                                                          = 1000148008,
	VK_BLEND_OP_SRC_ATOP_EXT                                                         = 1000148009,
	VK_BLEND_OP_DST_ATOP_EXT                                                         = 1000148010,
	VK_BLEND_OP_XOR_EXT                                                              = 1000148011,
	VK_BLEND_OP_MULTIPLY_EXT                                                         = 1000148012,
	VK_BLEND_OP_SCREEN_EXT                                                           = 1000148013,
	VK_BLEND_OP_OVERLAY_EXT                                                          = 1000148014,
	VK_BLEND_OP_DARKEN_EXT                                                           = 1000148015,
	VK_BLEND_OP_LIGHTEN_EXT                                                          = 1000148016,
	VK_BLEND_OP_COLORDODGE_EXT                                                       = 1000148017,
	VK_BLEND_OP_COLORBURN_EXT                                                        = 1000148018,
	VK_BLEND_OP_HARDLIGHT_EXT                                                        = 1000148019,
	VK_BLEND_OP_SOFTLIGHT_EXT                                                        = 1000148020,
	VK_BLEND_OP_DIFFERENCE_EXT                                                       = 1000148021,
	VK_BLEND_OP_EXCLUSION_EXT                                                        = 1000148022,
	VK_BLEND_OP_INVERT_EXT                                                           = 1000148023,
	VK_BLEND_OP_INVERT_RGB_EXT                                                       = 1000148024,
	VK_BLEND_OP_LINEARDODGE_EXT                                                      = 1000148025,
	VK_BLEND_OP_LINEARBURN_EXT                                                       = 1000148026,
	VK_BLEND_OP_VIVIDLIGHT_EXT                                                       = 1000148027,
	VK_BLEND_OP_LINEARLIGHT_EXT                                                      = 1000148028,
	VK_BLEND_OP_PINLIGHT_EXT                                                         = 1000148029,
	VK_BLEND_OP_HARDMIX_EXT                                                          = 1000148030,
	VK_BLEND_OP_HSL_HUE_EXT                                                          = 1000148031,
	VK_BLEND_OP_HSL_SATURATION_EXT                                                   = 1000148032,
	VK_BLEND_OP_HSL_COLOR_EXT                                                        = 1000148033,
	VK_BLEND_OP_HSL_LUMINOSITY_EXT                                                   = 1000148034,
	VK_BLEND_OP_PLUS_EXT                                                             = 1000148035,
	VK_BLEND_OP_PLUS_CLAMPED_EXT                                                     = 1000148036,
	VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT                                               = 1000148037,
	VK_BLEND_OP_PLUS_DARKER_EXT                                                      = 1000148038,
	VK_BLEND_OP_MINUS_EXT                                                            = 1000148039,
	VK_BLEND_OP_MINUS_CLAMPED_EXT                                                    = 1000148040,
	VK_BLEND_OP_CONTRAST_EXT                                                         = 1000148041,
	VK_BLEND_OP_INVERT_OVG_EXT                                                       = 1000148042,
	VK_BLEND_OP_RED_EXT                                                              = 1000148043,
	VK_BLEND_OP_GREEN_EXT                                                            = 1000148044,
	VK_BLEND_OP_BLUE_EXT                                                             = 1000148045,
}

impl Default for VkBlendOp {
	fn default() -> Self {
		Self::VK_BLEND_OP_ADD
	}
}

pub use self::VkStencilOp::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkStencilOp {
	VK_STENCIL_OP_KEEP                                                               = 0,
	VK_STENCIL_OP_ZERO                                                               = 1,
	VK_STENCIL_OP_REPLACE                                                            = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP                                                = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP                                                = 4,
	VK_STENCIL_OP_INVERT                                                             = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP                                                 = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP                                                 = 7,
}

impl Default for VkStencilOp {
	fn default() -> Self {
		Self::VK_STENCIL_OP_KEEP
	}
}

pub use self::VkLogicOp::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkLogicOp {
	VK_LOGIC_OP_CLEAR                                                                = 0,
	VK_LOGIC_OP_AND                                                                  = 1,
	VK_LOGIC_OP_AND_REVERSE                                                          = 2,
	VK_LOGIC_OP_COPY                                                                 = 3,
	VK_LOGIC_OP_AND_INVERTED                                                         = 4,
	VK_LOGIC_OP_NO_OP                                                                = 5,
	VK_LOGIC_OP_XOR                                                                  = 6,
	VK_LOGIC_OP_OR                                                                   = 7,
	VK_LOGIC_OP_NOR                                                                  = 8,
	VK_LOGIC_OP_EQUIVALENT                                                           = 9,
	VK_LOGIC_OP_INVERT                                                               = 10,
	VK_LOGIC_OP_OR_REVERSE                                                           = 11,
	VK_LOGIC_OP_COPY_INVERTED                                                        = 12,
	VK_LOGIC_OP_OR_INVERTED                                                          = 13,
	VK_LOGIC_OP_NAND                                                                 = 14,
	VK_LOGIC_OP_SET                                                                  = 15,
}

impl Default for VkLogicOp {
	fn default() -> Self {
		Self::VK_LOGIC_OP_CLEAR
	}
}

pub use self::VkInternalAllocationType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkInternalAllocationType {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE                                           = 0,
}

impl Default for VkInternalAllocationType {
	fn default() -> Self {
		Self::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE
	}
}

pub use self::VkSystemAllocationScope::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSystemAllocationScope {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND                                               = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT                                                = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE                                                 = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE                                                = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE                                              = 4,
}

impl Default for VkSystemAllocationScope {
	fn default() -> Self {
		Self::VK_SYSTEM_ALLOCATION_SCOPE_COMMAND
	}
}

pub use self::VkPhysicalDeviceType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPhysicalDeviceType {
	VK_PHYSICAL_DEVICE_TYPE_OTHER                                                    = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU                                           = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU                                             = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU                                              = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU                                                      = 4,
}

impl Default for VkPhysicalDeviceType {
	fn default() -> Self {
		Self::VK_PHYSICAL_DEVICE_TYPE_OTHER
	}
}

pub use self::VkVertexInputRate::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVertexInputRate {
	VK_VERTEX_INPUT_RATE_VERTEX                                                      = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE                                                    = 1,
}

impl Default for VkVertexInputRate {
	fn default() -> Self {
		Self::VK_VERTEX_INPUT_RATE_VERTEX
	}
}

/// Vulkan format definitions
pub use self::VkFormat::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFormat {
	VK_FORMAT_UNDEFINED                                                              = 0,
	VK_FORMAT_R4G4_UNORM_PACK8                                                       = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16                                                  = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16                                                  = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16                                                    = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16                                                    = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16                                                  = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16                                                  = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16                                                  = 8,
	VK_FORMAT_R8_UNORM                                                               = 9,
	VK_FORMAT_R8_SNORM                                                               = 10,
	VK_FORMAT_R8_USCALED                                                             = 11,
	VK_FORMAT_R8_SSCALED                                                             = 12,
	VK_FORMAT_R8_UINT                                                                = 13,
	VK_FORMAT_R8_SINT                                                                = 14,
	VK_FORMAT_R8_SRGB                                                                = 15,
	VK_FORMAT_R8G8_UNORM                                                             = 16,
	VK_FORMAT_R8G8_SNORM                                                             = 17,
	VK_FORMAT_R8G8_USCALED                                                           = 18,
	VK_FORMAT_R8G8_SSCALED                                                           = 19,
	VK_FORMAT_R8G8_UINT                                                              = 20,
	VK_FORMAT_R8G8_SINT                                                              = 21,
	VK_FORMAT_R8G8_SRGB                                                              = 22,
	VK_FORMAT_R8G8B8_UNORM                                                           = 23,
	VK_FORMAT_R8G8B8_SNORM                                                           = 24,
	VK_FORMAT_R8G8B8_USCALED                                                         = 25,
	VK_FORMAT_R8G8B8_SSCALED                                                         = 26,
	VK_FORMAT_R8G8B8_UINT                                                            = 27,
	VK_FORMAT_R8G8B8_SINT                                                            = 28,
	VK_FORMAT_R8G8B8_SRGB                                                            = 29,
	VK_FORMAT_B8G8R8_UNORM                                                           = 30,
	VK_FORMAT_B8G8R8_SNORM                                                           = 31,
	VK_FORMAT_B8G8R8_USCALED                                                         = 32,
	VK_FORMAT_B8G8R8_SSCALED                                                         = 33,
	VK_FORMAT_B8G8R8_UINT                                                            = 34,
	VK_FORMAT_B8G8R8_SINT                                                            = 35,
	VK_FORMAT_B8G8R8_SRGB                                                            = 36,
	VK_FORMAT_R8G8B8A8_UNORM                                                         = 37,
	VK_FORMAT_R8G8B8A8_SNORM                                                         = 38,
	VK_FORMAT_R8G8B8A8_USCALED                                                       = 39,
	VK_FORMAT_R8G8B8A8_SSCALED                                                       = 40,
	VK_FORMAT_R8G8B8A8_UINT                                                          = 41,
	VK_FORMAT_R8G8B8A8_SINT                                                          = 42,
	VK_FORMAT_R8G8B8A8_SRGB                                                          = 43,
	VK_FORMAT_B8G8R8A8_UNORM                                                         = 44,
	VK_FORMAT_B8G8R8A8_SNORM                                                         = 45,
	VK_FORMAT_B8G8R8A8_USCALED                                                       = 46,
	VK_FORMAT_B8G8R8A8_SSCALED                                                       = 47,
	VK_FORMAT_B8G8R8A8_UINT                                                          = 48,
	VK_FORMAT_B8G8R8A8_SINT                                                          = 49,
	VK_FORMAT_B8G8R8A8_SRGB                                                          = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32                                                  = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32                                                  = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32                                                = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32                                                = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32                                                   = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32                                                   = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32                                                   = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32                                               = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32                                               = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32                                             = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32                                             = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32                                                = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32                                                = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32                                               = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32                                               = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32                                             = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32                                             = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32                                                = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32                                                = 69,
	VK_FORMAT_R16_UNORM                                                              = 70,
	VK_FORMAT_R16_SNORM                                                              = 71,
	VK_FORMAT_R16_USCALED                                                            = 72,
	VK_FORMAT_R16_SSCALED                                                            = 73,
	VK_FORMAT_R16_UINT                                                               = 74,
	VK_FORMAT_R16_SINT                                                               = 75,
	VK_FORMAT_R16_SFLOAT                                                             = 76,
	VK_FORMAT_R16G16_UNORM                                                           = 77,
	VK_FORMAT_R16G16_SNORM                                                           = 78,
	VK_FORMAT_R16G16_USCALED                                                         = 79,
	VK_FORMAT_R16G16_SSCALED                                                         = 80,
	VK_FORMAT_R16G16_UINT                                                            = 81,
	VK_FORMAT_R16G16_SINT                                                            = 82,
	VK_FORMAT_R16G16_SFLOAT                                                          = 83,
	VK_FORMAT_R16G16B16_UNORM                                                        = 84,
	VK_FORMAT_R16G16B16_SNORM                                                        = 85,
	VK_FORMAT_R16G16B16_USCALED                                                      = 86,
	VK_FORMAT_R16G16B16_SSCALED                                                      = 87,
	VK_FORMAT_R16G16B16_UINT                                                         = 88,
	VK_FORMAT_R16G16B16_SINT                                                         = 89,
	VK_FORMAT_R16G16B16_SFLOAT                                                       = 90,
	VK_FORMAT_R16G16B16A16_UNORM                                                     = 91,
	VK_FORMAT_R16G16B16A16_SNORM                                                     = 92,
	VK_FORMAT_R16G16B16A16_USCALED                                                   = 93,
	VK_FORMAT_R16G16B16A16_SSCALED                                                   = 94,
	VK_FORMAT_R16G16B16A16_UINT                                                      = 95,
	VK_FORMAT_R16G16B16A16_SINT                                                      = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT                                                    = 97,
	VK_FORMAT_R32_UINT                                                               = 98,
	VK_FORMAT_R32_SINT                                                               = 99,
	VK_FORMAT_R32_SFLOAT                                                             = 100,
	VK_FORMAT_R32G32_UINT                                                            = 101,
	VK_FORMAT_R32G32_SINT                                                            = 102,
	VK_FORMAT_R32G32_SFLOAT                                                          = 103,
	VK_FORMAT_R32G32B32_UINT                                                         = 104,
	VK_FORMAT_R32G32B32_SINT                                                         = 105,
	VK_FORMAT_R32G32B32_SFLOAT                                                       = 106,
	VK_FORMAT_R32G32B32A32_UINT                                                      = 107,
	VK_FORMAT_R32G32B32A32_SINT                                                      = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT                                                    = 109,
	VK_FORMAT_R64_UINT                                                               = 110,
	VK_FORMAT_R64_SINT                                                               = 111,
	VK_FORMAT_R64_SFLOAT                                                             = 112,
	VK_FORMAT_R64G64_UINT                                                            = 113,
	VK_FORMAT_R64G64_SINT                                                            = 114,
	VK_FORMAT_R64G64_SFLOAT                                                          = 115,
	VK_FORMAT_R64G64B64_UINT                                                         = 116,
	VK_FORMAT_R64G64B64_SINT                                                         = 117,
	VK_FORMAT_R64G64B64_SFLOAT                                                       = 118,
	VK_FORMAT_R64G64B64A64_UINT                                                      = 119,
	VK_FORMAT_R64G64B64A64_SINT                                                      = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT                                                    = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32                                                = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32                                                 = 123,
	VK_FORMAT_D16_UNORM                                                              = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32                                                    = 125,
	VK_FORMAT_D32_SFLOAT                                                             = 126,
	VK_FORMAT_S8_UINT                                                                = 127,
	VK_FORMAT_D16_UNORM_S8_UINT                                                      = 128,
	VK_FORMAT_D24_UNORM_S8_UINT                                                      = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT                                                     = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK                                                    = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK                                                     = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK                                                   = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK                                                    = 134,
	VK_FORMAT_BC2_UNORM_BLOCK                                                        = 135,
	VK_FORMAT_BC2_SRGB_BLOCK                                                         = 136,
	VK_FORMAT_BC3_UNORM_BLOCK                                                        = 137,
	VK_FORMAT_BC3_SRGB_BLOCK                                                         = 138,
	VK_FORMAT_BC4_UNORM_BLOCK                                                        = 139,
	VK_FORMAT_BC4_SNORM_BLOCK                                                        = 140,
	VK_FORMAT_BC5_UNORM_BLOCK                                                        = 141,
	VK_FORMAT_BC5_SNORM_BLOCK                                                        = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK                                                      = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK                                                      = 144,
	VK_FORMAT_BC7_UNORM_BLOCK                                                        = 145,
	VK_FORMAT_BC7_SRGB_BLOCK                                                         = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK                                                = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK                                                 = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                                              = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                                               = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                                              = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                                               = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK                                                    = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK                                                    = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK                                                 = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK                                                 = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK                                                   = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK                                                    = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK                                                   = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK                                                    = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK                                                   = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK                                                    = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK                                                   = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK                                                    = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK                                                   = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK                                                    = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK                                                   = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK                                                    = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK                                                   = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK                                                    = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK                                                   = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK                                                    = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK                                                  = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK                                                   = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK                                                  = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK                                                   = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK                                                  = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK                                                   = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK                                                 = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK                                                  = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK                                                 = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK                                                  = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK                                                 = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK                                                  = 184,
	VK_FORMAT_G8B8G8R8_422_UNORM                                                     = 1000156000,
	VK_FORMAT_B8G8R8G8_422_UNORM                                                     = 1000156001,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM                                              = 1000156002,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM                                               = 1000156003,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM                                              = 1000156004,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM                                               = 1000156005,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM                                              = 1000156006,
	VK_FORMAT_R10X6_UNORM_PACK16                                                     = 1000156007,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16                                               = 1000156008,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16                                     = 1000156009,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16                                 = 1000156010,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16                                 = 1000156011,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16                             = 1000156012,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16                              = 1000156013,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16                             = 1000156014,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16                              = 1000156015,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16                             = 1000156016,
	VK_FORMAT_R12X4_UNORM_PACK16                                                     = 1000156017,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16                                               = 1000156018,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16                                     = 1000156019,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16                                 = 1000156020,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16                                 = 1000156021,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16                             = 1000156022,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16                              = 1000156023,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16                             = 1000156024,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16                              = 1000156025,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16                             = 1000156026,
	VK_FORMAT_G16B16G16R16_422_UNORM                                                 = 1000156027,
	VK_FORMAT_B16G16R16G16_422_UNORM                                                 = 1000156028,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM                                           = 1000156029,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM                                            = 1000156030,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM                                           = 1000156031,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM                                            = 1000156032,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM                                           = 1000156033,
	VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG                                            = 1000054000,
	VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG                                            = 1000054001,
	VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG                                            = 1000054002,
	VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG                                            = 1000054003,
	VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG                                             = 1000054004,
	VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG                                             = 1000054005,
	VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG                                             = 1000054006,
	VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG                                             = 1000054007,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT                                              = 1000066000,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT                                              = 1000066001,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT                                              = 1000066002,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT                                              = 1000066003,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT                                              = 1000066004,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT                                              = 1000066005,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT                                              = 1000066006,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT                                              = 1000066007,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT                                             = 1000066008,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT                                             = 1000066009,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT                                             = 1000066010,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT                                            = 1000066011,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT                                            = 1000066012,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT                                            = 1000066013,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT                                           = 1000330000,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT                          = 1000330001,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT                          = 1000330002,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT                                        = 1000330003,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT                                              = 1000340000,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT                                              = 1000340001,
}

impl Default for VkFormat {
	fn default() -> Self {
		Self::VK_FORMAT_UNDEFINED
	}
}

pub const VK_FORMAT_G8B8G8R8_422_UNORM_KHR                                                : VkFormat = VK_FORMAT_G8B8G8R8_422_UNORM;
pub const VK_FORMAT_B8G8R8G8_422_UNORM_KHR                                                : VkFormat = VK_FORMAT_B8G8R8G8_422_UNORM;
pub const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR                                         : VkFormat = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM;
pub const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR                                          : VkFormat = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
pub const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR                                         : VkFormat = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM;
pub const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR                                          : VkFormat = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM;
pub const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR                                         : VkFormat = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM;
pub const VK_FORMAT_R10X6_UNORM_PACK16_KHR                                                : VkFormat = VK_FORMAT_R10X6_UNORM_PACK16;
pub const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR                                          : VkFormat = VK_FORMAT_R10X6G10X6_UNORM_2PACK16;
pub const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR                                : VkFormat = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16;
pub const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR                            : VkFormat = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
pub const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR                            : VkFormat = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR                        : VkFormat = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR                         : VkFormat = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR                        : VkFormat = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR                         : VkFormat = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR                        : VkFormat = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
pub const VK_FORMAT_R12X4_UNORM_PACK16_KHR                                                : VkFormat = VK_FORMAT_R12X4_UNORM_PACK16;
pub const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR                                          : VkFormat = VK_FORMAT_R12X4G12X4_UNORM_2PACK16;
pub const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR                                : VkFormat = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16;
pub const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR                            : VkFormat = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
pub const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR                            : VkFormat = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR                        : VkFormat = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR                         : VkFormat = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR                        : VkFormat = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR                         : VkFormat = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR                        : VkFormat = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
pub const VK_FORMAT_G16B16G16R16_422_UNORM_KHR                                            : VkFormat = VK_FORMAT_G16B16G16R16_422_UNORM;
pub const VK_FORMAT_B16G16R16G16_422_UNORM_KHR                                            : VkFormat = VK_FORMAT_B16G16R16G16_422_UNORM;
pub const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR                                      : VkFormat = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM;
pub const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR                                       : VkFormat = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM;
pub const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR                                      : VkFormat = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM;
pub const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR                                       : VkFormat = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM;
pub const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR                                      : VkFormat = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;

/// Structure type enumerant
pub use self::VkStructureType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkStructureType {
	VK_STRUCTURE_TYPE_APPLICATION_INFO                                               = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                                           = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                                       = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                                             = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO                                                    = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                                           = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                                            = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                                               = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                                              = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                                          = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                                              = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                                         = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                                             = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                                        = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                                              = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                                         = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                                      = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                                     = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO                              = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO                        = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO                      = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO                        = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO                            = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO                       = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO                         = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO                       = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO                         = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO                             = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO                                  = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO                                   = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO                                    = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                                            = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO                              = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO                                    = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO                                   = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                                           = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                                            = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                                        = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                                        = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                                       = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO                                   = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO                                = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                                      = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                                         = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                                          = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                                           = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER                                                 = 46,
	/// Reserved for internal use by the loader, layers, and ICDs
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO                                    = 47,
	/// Reserved for internal use by the loader, layers, and ICDs
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                                      = 48,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES                            = 1000094000,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO                                        = 1000157000,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO                                         = 1000157001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES                         = 1000083000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS                                  = 1000127000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO                                 = 1000127001,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO                                     = 1000060000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO                            = 1000060003,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO                         = 1000060004,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO                                       = 1000060005,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO                                  = 1000060006,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO                           = 1000060013,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO                            = 1000060014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES                               = 1000070000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO                                = 1000070001,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2                              = 1000146000,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2                               = 1000146001,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2                        = 1000146002,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2                                          = 1000146003,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2                             = 1000146004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2                                     = 1000059000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2                                   = 1000059001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2                                            = 1000059002,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2                                      = 1000059003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2                            = 1000059004,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2                                      = 1000059005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2                            = 1000059006,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2                               = 1000059007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2                     = 1000059008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES                      = 1000117000,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO                = 1000117001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO                                   = 1000117002,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO          = 1000117003,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO                              = 1000053000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES                             = 1000053001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES                           = 1000053002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES                     = 1000120000,
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO                                          = 1000145000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES                      = 1000145001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES                    = 1000145002,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2                                            = 1000145003,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO                           = 1000156000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO                                  = 1000156001,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO                                   = 1000156002,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO                           = 1000156003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES              = 1000156004,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES               = 1000156005,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO                         = 1000085000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO                     = 1000071000,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES                               = 1000071001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO                           = 1000071002,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES                                     = 1000071003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES                                  = 1000071004,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO                             = 1000072000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO                              = 1000072001,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO                                    = 1000072002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO                            = 1000112000,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES                                      = 1000112001,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO                                       = 1000113000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO                                   = 1000077000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO                        = 1000076000,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES                                  = 1000076001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES                       = 1000168000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT                                  = 1000168001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES                = 1000063000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES                            = 49,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES                          = 50,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES                            = 51,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES                          = 52,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO                                  = 1000147000,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2                                       = 1000109000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2                                         = 1000109001,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2                                          = 1000109002,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2                                           = 1000109003,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2                                      = 1000109004,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO                                             = 1000109005,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO                                               = 1000109006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES                          = 1000177000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES                              = 1000196000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES                   = 1000180000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES                   = 1000082000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES                      = 1000197000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO                = 1000161000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES                   = 1000161001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES                 = 1000161002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO         = 1000161003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT        = 1000161004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES               = 1000199000,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE                      = 1000199001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES                   = 1000221000,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO                                = 1000246000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES               = 1000130000,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO                             = 1000130001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES                   = 1000211000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES                 = 1000108000,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO                            = 1000108001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO                              = 1000108002,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO                              = 1000108003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES        = 1000253000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES        = 1000175000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES        = 1000241000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT                            = 1000241001,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT                          = 1000241002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES                      = 1000261000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES                    = 1000207000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES                  = 1000207001,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO                                     = 1000207002,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO                                 = 1000207003,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO                                            = 1000207004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO                                          = 1000207005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES                 = 1000257000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO                                     = 1000244001,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO                      = 1000257002,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO                    = 1000257003,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO                      = 1000257004,
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                                      = 1000001000,
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR                                               = 1000001001,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR                          = 1000060007,
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR                                = 1000060008,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR                           = 1000060009,
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR                                    = 1000060010,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR                                  = 1000060011,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR                         = 1000060012,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR                                   = 1000002000,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR                                = 1000002001,
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR                                       = 1000003000,
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR                                   = 1000004000,
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR                                    = 1000005000,
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR                                = 1000006000,
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR                                = 1000008000,
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR                                  = 1000009000,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT                          = 1000011000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD           = 1000018000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT                              = 1000022000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT                               = 1000022001,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT                                   = 1000022002,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR                                              = 1000023000,
	VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR                                         = 1000023001,
	VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR                                     = 1000023002,
	VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR                                = 1000023003,
	VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR                                          = 1000023004,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR                                  = 1000023005,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR                       = 1000023006,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR                       = 1000023007,
	VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR                                    = 1000023008,
	VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR                                      = 1000023009,
	VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR                                  = 1000023010,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR                                       = 1000023011,
	VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR                            = 1000023012,
	VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR                                             = 1000023013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR                          = 1000023014,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR                                    = 1000023015,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR                                          = 1000024000,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV                      = 1000026000,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV                     = 1000026001,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV                   = 1000026002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT                = 1000028000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT              = 1000028001,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT            = 1000028002,
	VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX                                      = 1000029000,
	VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX                                    = 1000029001,
	VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX                                             = 1000029002,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX                                     = 1000030000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX                              = 1000030001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT                             = 1000038000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT                      = 1000038001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT           = 1000038002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT              = 1000038003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT                           = 1000038004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT                            = 1000038005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT                               = 1000038006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT                  = 1000038007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT                                  = 1000038008,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT                             = 1000040000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT                      = 1000040001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT                             = 1000040002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT                                      = 1000040003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT                                  = 1000040004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT           = 1000040005,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT              = 1000040006,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT                            = 1000040007,
	VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD                       = 1000041000,
	VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP                      = 1000049000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV               = 1000050000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV                           = 1000056000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV                                 = 1000056001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV                             = 1000057000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV                             = 1000057001,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV                      = 1000058000,
	VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT                                           = 1000061000,
	VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN                                      = 1000062000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT      = 1000066000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT                                = 1000067000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT                       = 1000067001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR                            = 1000073000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR                            = 1000073001,
	VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR                             = 1000073002,
	VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR                               = 1000073003,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR                                      = 1000074000,
	VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR                                       = 1000074001,
	VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR                                         = 1000074002,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR                     = 1000075000,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                         = 1000078000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                         = 1000078001,
	VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR                                    = 1000078002,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR                            = 1000078003,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR                                   = 1000079000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR                                      = 1000079001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR                 = 1000080000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT      = 1000081000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT             = 1000081001,
	VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT                           = 1000081002,
	VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR                                            = 1000084000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV               = 1000087000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT                                     = 1000090000,
	VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT                                         = 1000091000,
	VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT                                          = 1000091001,
	VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT                                         = 1000091002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT                              = 1000091003,
	VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE                                      = 1000092000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX   = 1000097000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV                 = 1000098000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT               = 1000099000,
	VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT               = 1000099001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT      = 1000101000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT      = 1000101001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT                 = 1000102000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT        = 1000102001,
	VK_STRUCTURE_TYPE_HDR_METADATA_EXT                                               = 1000105000,
	VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR                        = 1000111000,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR                             = 1000114000,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR                             = 1000114001,
	VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR                                = 1000114002,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR                                       = 1000115000,
	VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR                                          = 1000115001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR                 = 1000116000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR               = 1000116001,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR                         = 1000116002,
	VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR                              = 1000116003,
	VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR                                = 1000116004,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR                                        = 1000116005,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR                            = 1000116006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR                             = 1000119000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR                                     = 1000119001,
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR                                           = 1000119002,
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR                                       = 1000121000,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR                                 = 1000121001,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR                                  = 1000121002,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR                                       = 1000121003,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR                               = 1000121004,
	VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK                                    = 1000122000,
	VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK                                  = 1000123000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT                               = 1000128000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT                                = 1000128001,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT                                          = 1000128002,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT                        = 1000128003,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT                          = 1000128004,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID                          = 1000129000,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID                     = 1000129001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID              = 1000129002,
	VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                    = 1000129003,
	VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                = 1000129004,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID                                        = 1000129005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT              = 1000138000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT            = 1000138001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT                  = 1000138002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT           = 1000138003,
	VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT                                      = 1000143000,
	VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT                    = 1000143001,
	VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT                = 1000143002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT                = 1000143003,
	VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT                                     = 1000143004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT          = 1000148000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT        = 1000148001,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT            = 1000148002,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV                = 1000149000,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR                = 1000150007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR                 = 1000150000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR                 = 1000150002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR                 = 1000150003,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR             = 1000150004,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR             = 1000150005,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR                            = 1000150006,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR                        = 1000150009,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR                           = 1000150010,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR                 = 1000150011,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR                 = 1000150012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR            = 1000150013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR          = 1000150014,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR                         = 1000150017,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR                    = 1000150020,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR              = 1000347000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR            = 1000347001,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR                           = 1000150015,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR                       = 1000150016,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR                 = 1000150018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR                         = 1000348013,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV              = 1000152000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV                 = 1000154000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV               = 1000154001,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT                        = 1000158000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT             = 1000158002,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT                 = 1000158003,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT             = 1000158004,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT                       = 1000158005,
	VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT                               = 1000160000,
	VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT                 = 1000160001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR                = 1000163000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR              = 1000163001,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV      = 1000164000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV                 = 1000164001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV               = 1000164002,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV     = 1000164005,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV                            = 1000165000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV                          = 1000165001,
	VK_STRUCTURE_TYPE_GEOMETRY_NV                                                    = 1000165003,
	VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV                                          = 1000165004,
	VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV                                               = 1000165005,
	VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV                     = 1000165006,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV                 = 1000165007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV             = 1000165008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV                      = 1000165009,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV                        = 1000165011,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV                                 = 1000165012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV       = 1000166000,
	VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV     = 1000166001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT               = 1000170000,
	VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT            = 1000170001,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT                   = 1000174000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT                            = 1000178000,
	VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT                             = 1000178001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT            = 1000178002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR                      = 1000181000,
	VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD                      = 1000183000,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT                                  = 1000184000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD                     = 1000185000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT                             = 1000187000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT                      = 1000187001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT           = 1000187002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT              = 1000187003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT                                  = 1000187004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT                             = 1000187005,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT                            = 1000187006,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD                   = 1000189000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT        = 1000190000,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT            = 1000190001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT          = 1000190002,
	VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP                                        = 1000191000,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT                     = 1000192000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV         = 1000201000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV                        = 1000202000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV                      = 1000202001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV        = 1000203000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV             = 1000204000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV       = 1000205000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV                  = 1000205002,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV                                             = 1000206000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV                          = 1000206001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL      = 1000209000,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL                 = 1000210000,
	VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL                          = 1000210001,
	VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL                                  = 1000210002,
	VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL                           = 1000210003,
	VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL                                = 1000210004,
	VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL                   = 1000210005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT                    = 1000212000,
	VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD                    = 1000213000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD                   = 1000213001,
	VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA                          = 1000214000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR       = 1000215000,
	VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT                                  = 1000217000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT              = 1000218000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT            = 1000218001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT               = 1000218002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT           = 1000225000,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT   = 1000225001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT             = 1000225002,
	VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR                      = 1000226000,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR           = 1000226001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR           = 1000226002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR             = 1000226003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR                      = 1000226004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD                   = 1000227000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD                   = 1000229000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT         = 1000234000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT                   = 1000237000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT                   = 1000238000,
	VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT                              = 1000238001,
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR                             = 1000239000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT             = 1000244000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT                          = 1000244002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT                            = 1000245000,
	VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT                                        = 1000247000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV                 = 1000249000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV                               = 1000249001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV               = 1000249002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV            = 1000250000,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV               = 1000250001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV                       = 1000250002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT         = 1000251000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT                = 1000252000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT                  = 1000254000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT  = 1000254001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT                = 1000254002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT                         = 1000255000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT                 = 1000255002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT                   = 1000255001,
	VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT                               = 1000256000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT                = 1000259000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT              = 1000259001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT              = 1000259002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT               = 1000260000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT                  = 1000265000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT            = 1000267000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR    = 1000269000,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR                                              = 1000269001,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR                             = 1000269002,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR                                   = 1000269003,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR                              = 1000269004,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR                = 1000269005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV        = 1000277000,
	VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV                           = 1000277001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV                 = 1000277002,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV                              = 1000277003,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV                        = 1000277004,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV                                     = 1000277005,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV                 = 1000277006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV          = 1000277007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV         = 1000278000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV            = 1000278001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT            = 1000281000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT          = 1000281001,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM     = 1000282000,
	VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM                          = 1000282001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT              = 1000284000,
	VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT                    = 1000284001,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT                         = 1000284002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT                      = 1000286000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT                    = 1000286001,
	VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT                    = 1000287000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT             = 1000287001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT               = 1000287002,
	VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR                               = 1000290000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT                      = 1000295000,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT                            = 1000295001,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT                              = 1000295002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT   = 1000297000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR                                          = 1000299000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR                             = 1000299001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV                 = 1000300000,
	VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV                       = 1000300001,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR                                           = 1000314000,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR                                    = 1000314001,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR                                     = 1000314002,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR                                            = 1000314003,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR                                              = 1000314004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR                                      = 1000314005,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR                                 = 1000314006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR                 = 1000314007,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV                        = 1000314008,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV                                           = 1000314009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR  = 1000325000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV      = 1000326000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV        = 1000326001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV       = 1000326002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV       = 1000327000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV            = 1000327001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV                          = 1000327002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT         = 1000330000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT            = 1000332000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT          = 1000332001,
	VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM                               = 1000333000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT                  = 1000335000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR  = 1000336000,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR                                         = 1000337000,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR                                          = 1000337001,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR                                = 1000337002,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR                                = 1000337003,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR                                          = 1000337004,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR                                       = 1000337005,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR                                              = 1000337006,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR                                               = 1000337007,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR                                               = 1000337008,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR                                        = 1000337009,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR                                            = 1000337010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT                      = 1000340000,
	VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT                               = 1000346000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE         = 1000351000,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE                      = 1000351002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT        = 1000352000,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT                         = 1000352001,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT                       = 1000352002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT                             = 1000353000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA                       = 1000364000,
	VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA                        = 1000364001,
	VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA                          = 1000364002,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA                    = 1000365000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA                       = 1000365001,
	VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI                    = 1000369000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI                = 1000369001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI              = 1000369002,
	VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV                              = 1000371000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV               = 1000371001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT          = 1000377000,
	VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX                                 = 1000378000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT                = 1000381000,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT                           = 1000381001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT             = 1000388000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT                    = 1000388001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT                        = 1000392000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT                      = 1000392001,
}

impl Default for VkStructureType {
	fn default() -> Self {
		Self::VK_STRUCTURE_TYPE_APPLICATION_INFO
	}
}

pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES                     : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES                : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
pub const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT                                  : VkStructureType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR                         : VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR                        : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR                      : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR                                : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR                              : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR                                       : VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR                                 : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR                                 : VkStructureType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR                          : VkStructureType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR                : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
pub const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR                                : VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR                    : VkStructureType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR                                  : VkStructureType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR                      : VkStructureType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR                          : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR                           : VkStructureType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR                : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
pub const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR                          : VkStructureType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR                      : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
pub const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR                                : VkStructureType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR                        : VkStructureType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR                         : VkStructureType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR                               : VkStructureType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR                   : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
pub const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
pub const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR                              : VkStructureType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR              : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR                     : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR                    : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR                    : VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT                                     : VkStructureType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR            : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR                         : VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR                         : VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR                                  : VkStructureType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR                                    : VkStructureType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR                                     : VkStructureType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
pub const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR                                      : VkStructureType = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR                                 : VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
pub const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR                                        : VkStructureType = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
pub const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR                                          : VkStructureType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
pub const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR                                 : VkStructureType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
pub const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR                                  : VkStructureType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR                 : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR           : VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR                              : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR     : VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR                : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR                 : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR                            : VkStructureType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT          : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
pub const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT                        : VkStructureType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR                         : VkStructureType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR                          : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
pub const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR                   : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
pub const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR                                     : VkStructureType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR                        : VkStructureType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR                      : VkStructureType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR                              : VkStructureType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
pub const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR                      : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR         : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR          : VkStructureType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR                                   : VkStructureType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR                                    : VkStructureType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT           : VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT              : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT            : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT    : VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT   : VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR                  : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR                             : VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR   : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR                     : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR              : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR                         : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR                 : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR          : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR                 : VkStructureType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR               : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR             : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR                                : VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR                            : VkStructureType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR                                       : VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR                                     : VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
pub const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL                                  : VkStructureType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR              : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT              : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR   : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR                       : VkStructureType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR                     : VkStructureType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT                   : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT                                : VkStructureType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
pub const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT                           : VkStructureType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR   : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR            : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR                                : VkStructureType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
pub const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR                 : VkStructureType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
pub const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR               : VkStructureType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR                 : VkStructureType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT                 : VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;

pub use self::VkSubpassContents::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSubpassContents {
	VK_SUBPASS_CONTENTS_INLINE                                                       = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS                                    = 1,
}

impl Default for VkSubpassContents {
	fn default() -> Self {
		Self::VK_SUBPASS_CONTENTS_INLINE
	}
}

/// API result codes
pub use self::VkResult::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkResult {
	// Return codes (positive values)
	/// Command completed successfully
	VK_SUCCESS                                                                       = 0,
	/// A fence or query has not yet completed
	VK_NOT_READY                                                                     = 1,
	/// A wait operation has not completed in the specified time
	VK_TIMEOUT                                                                       = 2,
	/// An event is signaled
	VK_EVENT_SET                                                                     = 3,
	/// An event is unsignaled
	VK_EVENT_RESET                                                                   = 4,
	/// A return array was too small for the result
	VK_INCOMPLETE                                                                    = 5,
	// Error codes (negative values)
	/// A host memory allocation has failed
	VK_ERROR_OUT_OF_HOST_MEMORY                                                      = -1,
	/// A device memory allocation has failed
	VK_ERROR_OUT_OF_DEVICE_MEMORY                                                    = -2,
	/// Initialization of a object has failed
	VK_ERROR_INITIALIZATION_FAILED                                                   = -3,
	/// The logical device has been lost. See <<devsandqueues-lost-device>>
	VK_ERROR_DEVICE_LOST                                                             = -4,
	/// Mapping of a memory object has failed
	VK_ERROR_MEMORY_MAP_FAILED                                                       = -5,
	/// Layer specified does not exist
	VK_ERROR_LAYER_NOT_PRESENT                                                       = -6,
	/// Extension specified does not exist
	VK_ERROR_EXTENSION_NOT_PRESENT                                                   = -7,
	/// Requested feature is not available on this device
	VK_ERROR_FEATURE_NOT_PRESENT                                                     = -8,
	/// Unable to find a Vulkan driver
	VK_ERROR_INCOMPATIBLE_DRIVER                                                     = -9,
	/// Too many objects of the type have already been created
	VK_ERROR_TOO_MANY_OBJECTS                                                        = -10,
	/// Requested format is not supported on this device
	VK_ERROR_FORMAT_NOT_SUPPORTED                                                    = -11,
	/// A requested pool allocation has failed due to fragmentation of the pool's memory
	VK_ERROR_FRAGMENTED_POOL                                                         = -12,
	/// An unknown error has occurred, due to an implementation or application bug
	VK_ERROR_UNKNOWN                                                                 = -13,
	VK_ERROR_OUT_OF_POOL_MEMORY                                                      = -1000069000,
	VK_ERROR_INVALID_EXTERNAL_HANDLE                                                 = -1000072003,
	VK_ERROR_FRAGMENTATION                                                           = -1000161000,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS                                          = -1000257000,
	VK_ERROR_SURFACE_LOST_KHR                                                        = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR                                                = -1000000001,
	VK_SUBOPTIMAL_KHR                                                                = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR                                                         = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR                                                = -1000003001,
	VK_ERROR_VALIDATION_FAILED_EXT                                                   = -1000011001,
	VK_ERROR_INVALID_SHADER_NV                                                       = -1000012000,
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT                            = -1000158000,
	VK_ERROR_NOT_PERMITTED_EXT                                                       = -1000174001,
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT                                     = -1000255000,
	VK_THREAD_IDLE_KHR                                                               = 1000268000,
	VK_THREAD_DONE_KHR                                                               = 1000268001,
	VK_OPERATION_DEFERRED_KHR                                                        = 1000268002,
	VK_OPERATION_NOT_DEFERRED_KHR                                                    = 1000268003,
	VK_PIPELINE_COMPILE_REQUIRED_EXT                                                 = 1000297000,
}

impl Default for VkResult {
	fn default() -> Self {
		Self::VK_SUCCESS
	}
}

pub const VK_ERROR_OUT_OF_POOL_MEMORY_KHR                                                 : VkResult = VK_ERROR_OUT_OF_POOL_MEMORY;
pub const VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR                                            : VkResult = VK_ERROR_INVALID_EXTERNAL_HANDLE;
pub const VK_ERROR_FRAGMENTATION_EXT                                                      : VkResult = VK_ERROR_FRAGMENTATION;
pub const VK_ERROR_INVALID_DEVICE_ADDRESS_EXT                                             : VkResult = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
pub const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR                                     : VkResult = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
pub const VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT                                          : VkResult = VK_PIPELINE_COMPILE_REQUIRED_EXT;

pub use self::VkDynamicState::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDynamicState {
	VK_DYNAMIC_STATE_VIEWPORT                                                        = 0,
	VK_DYNAMIC_STATE_SCISSOR                                                         = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH                                                      = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS                                                      = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS                                                 = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS                                                    = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK                                            = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK                                              = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE                                               = 8,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV                                           = 1000087000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT                                           = 1000099000,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT                                            = 1000143000,
	VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR                             = 1000347000,
	VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV                                = 1000164004,
	VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV                                 = 1000164006,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV                                            = 1000205001,
	VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR                                       = 1000226000,
	VK_DYNAMIC_STATE_LINE_STIPPLE_EXT                                                = 1000259000,
	VK_DYNAMIC_STATE_CULL_MODE_EXT                                                   = 1000267000,
	VK_DYNAMIC_STATE_FRONT_FACE_EXT                                                  = 1000267001,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT                                          = 1000267002,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT                                         = 1000267003,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT                                          = 1000267004,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT                                 = 1000267005,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT                                           = 1000267006,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT                                          = 1000267007,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT                                            = 1000267008,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT                                    = 1000267009,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT                                         = 1000267010,
	VK_DYNAMIC_STATE_STENCIL_OP_EXT                                                  = 1000267011,
	VK_DYNAMIC_STATE_VERTEX_INPUT_EXT                                                = 1000352000,
	VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT                                        = 1000377000,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT                                   = 1000377001,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT                                           = 1000377002,
	VK_DYNAMIC_STATE_LOGIC_OP_EXT                                                    = 1000377003,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT                                    = 1000377004,
	VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT                                          = 1000381000,
}

impl Default for VkDynamicState {
	fn default() -> Self {
		Self::VK_DYNAMIC_STATE_VIEWPORT
	}
}

pub use self::VkDescriptorUpdateTemplateType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDescriptorUpdateTemplateType {
	/// Create descriptor update template for descriptor set updates
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET                                = 0,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR                          = 1,
}

impl Default for VkDescriptorUpdateTemplateType {
	fn default() -> Self {
		Self::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
	}
}

pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR                           : VkDescriptorUpdateTemplateType = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;

/// Enums to track objects of various types - also see objtypeenum attributes on type tags
pub use self::VkObjectType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkObjectType {
	VK_OBJECT_TYPE_UNKNOWN                                                           = 0,
	VK_OBJECT_TYPE_INSTANCE                                                          = 1,
	VK_OBJECT_TYPE_PHYSICAL_DEVICE                                                   = 2,
	VK_OBJECT_TYPE_DEVICE                                                            = 3,
	VK_OBJECT_TYPE_QUEUE                                                             = 4,
	VK_OBJECT_TYPE_SEMAPHORE                                                         = 5,
	VK_OBJECT_TYPE_COMMAND_BUFFER                                                    = 6,
	VK_OBJECT_TYPE_FENCE                                                             = 7,
	VK_OBJECT_TYPE_DEVICE_MEMORY                                                     = 8,
	VK_OBJECT_TYPE_BUFFER                                                            = 9,
	VK_OBJECT_TYPE_IMAGE                                                             = 10,
	VK_OBJECT_TYPE_EVENT                                                             = 11,
	VK_OBJECT_TYPE_QUERY_POOL                                                        = 12,
	VK_OBJECT_TYPE_BUFFER_VIEW                                                       = 13,
	VK_OBJECT_TYPE_IMAGE_VIEW                                                        = 14,
	VK_OBJECT_TYPE_SHADER_MODULE                                                     = 15,
	VK_OBJECT_TYPE_PIPELINE_CACHE                                                    = 16,
	VK_OBJECT_TYPE_PIPELINE_LAYOUT                                                   = 17,
	VK_OBJECT_TYPE_RENDER_PASS                                                       = 18,
	VK_OBJECT_TYPE_PIPELINE                                                          = 19,
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT                                             = 20,
	VK_OBJECT_TYPE_SAMPLER                                                           = 21,
	VK_OBJECT_TYPE_DESCRIPTOR_POOL                                                   = 22,
	VK_OBJECT_TYPE_DESCRIPTOR_SET                                                    = 23,
	VK_OBJECT_TYPE_FRAMEBUFFER                                                       = 24,
	VK_OBJECT_TYPE_COMMAND_POOL                                                      = 25,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION                                          = 1000156000,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE                                        = 1000085000,
	VK_OBJECT_TYPE_SURFACE_KHR                                                       = 1000000000,
	VK_OBJECT_TYPE_SWAPCHAIN_KHR                                                     = 1000001000,
	VK_OBJECT_TYPE_DISPLAY_KHR                                                       = 1000002000,
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR                                                  = 1000002001,
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT                                         = 1000011000,
	VK_OBJECT_TYPE_VIDEO_SESSION_KHR                                                 = 1000023000,
	VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR                                      = 1000023001,
	VK_OBJECT_TYPE_CU_MODULE_NVX                                                     = 1000029000,
	VK_OBJECT_TYPE_CU_FUNCTION_NVX                                                   = 1000029001,
	VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT                                         = 1000128000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR                                        = 1000150000,
	VK_OBJECT_TYPE_VALIDATION_CACHE_EXT                                              = 1000160000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV                                         = 1000165000,
	VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL                                   = 1000210000,
	VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR                                            = 1000268000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV                                       = 1000277000,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT                                             = 1000295000,
}

impl Default for VkObjectType {
	fn default() -> Self {
		Self::VK_OBJECT_TYPE_UNKNOWN
	}
}

pub const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR                                   : VkObjectType = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
pub const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR                                     : VkObjectType = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION;
// Flags

pub use self::VkQueueFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueueFlagBits {
	/// Queue supports graphics operations
	VK_QUEUE_GRAPHICS_BIT                                                            = 0x1,
	/// Queue supports compute operations
	VK_QUEUE_COMPUTE_BIT                                                             = 0x2,
	/// Queue supports transfer operations
	VK_QUEUE_TRANSFER_BIT                                                            = 0x4,
	/// Queue supports sparse resource memory management operations
	VK_QUEUE_SPARSE_BINDING_BIT                                                      = 0x8,
	VK_QUEUE_PROTECTED_BIT                                                           = 0x10,
	VK_QUEUE_VIDEO_DECODE_BIT_KHR                                                    = 0x20,
	VK_QUEUE_VIDEO_ENCODE_BIT_KHR                                                    = 0x40,
}

impl Default for VkQueueFlagBits {
	fn default() -> Self {
		Self::VK_QUEUE_GRAPHICS_BIT
	}
}

pub use self::VkCullModeFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCullModeFlagBits {
	VK_CULL_MODE_NONE                                                                = 0,
	VK_CULL_MODE_FRONT_BIT                                                           = 0x1,
	VK_CULL_MODE_BACK_BIT                                                            = 0x2,
	VK_CULL_MODE_FRONT_AND_BACK                                                      = 0x00000003,
}

impl Default for VkCullModeFlagBits {
	fn default() -> Self {
		Self::VK_CULL_MODE_NONE
	}
}

pub use self::VkRenderPassCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkRenderPassCreateFlagBits {
	VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM                                         = 0x2,
}

impl Default for VkRenderPassCreateFlagBits {
	fn default() -> Self {
		Self::VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM
	}
}

pub use self::VkDeviceQueueCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDeviceQueueCreateFlagBits {
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT                                             = 0x1,
}

impl Default for VkDeviceQueueCreateFlagBits {
	fn default() -> Self {
		Self::VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT
	}
}

pub use self::VkMemoryPropertyFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkMemoryPropertyFlagBits {
	/// If otherwise stated, then allocate memory on device
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT                                              = 0x1,
	/// Memory is mappable by host
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT                                              = 0x2,
	/// Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT                                             = 0x4,
	/// Memory will be cached by the host
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT                                               = 0x8,
	/// Memory may be allocated by the driver when it is required
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT                                          = 0x10,
	VK_MEMORY_PROPERTY_PROTECTED_BIT                                                 = 0x20,
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD                                       = 0x40,
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD                                       = 0x80,
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV                                           = 0x100,
}

impl Default for VkMemoryPropertyFlagBits {
	fn default() -> Self {
		Self::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
	}
}

pub use self::VkMemoryHeapFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkMemoryHeapFlagBits {
	/// If set, heap represents device memory
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT                                                  = 0x1,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT                                                = 0x2,
}

impl Default for VkMemoryHeapFlagBits {
	fn default() -> Self {
		Self::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT
	}
}

pub const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR                                           : VkMemoryHeapFlagBits = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT;

pub use self::VkAccessFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccessFlagBits {
	/// Controls coherency of indirect command reads
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT                                              = 0x1,
	/// Controls coherency of index reads
	VK_ACCESS_INDEX_READ_BIT                                                         = 0x2,
	/// Controls coherency of vertex attribute reads
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                                              = 0x4,
	/// Controls coherency of uniform buffer reads
	VK_ACCESS_UNIFORM_READ_BIT                                                       = 0x8,
	/// Controls coherency of input attachment reads
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                                              = 0x10,
	/// Controls coherency of shader reads
	VK_ACCESS_SHADER_READ_BIT                                                        = 0x20,
	/// Controls coherency of shader writes
	VK_ACCESS_SHADER_WRITE_BIT                                                       = 0x40,
	/// Controls coherency of color attachment reads
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                                              = 0x80,
	/// Controls coherency of color attachment writes
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                                             = 0x100,
	/// Controls coherency of depth/stencil attachment reads
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT                                      = 0x200,
	/// Controls coherency of depth/stencil attachment writes
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT                                     = 0x400,
	/// Controls coherency of transfer reads
	VK_ACCESS_TRANSFER_READ_BIT                                                      = 0x800,
	/// Controls coherency of transfer writes
	VK_ACCESS_TRANSFER_WRITE_BIT                                                     = 0x1000,
	/// Controls coherency of host reads
	VK_ACCESS_HOST_READ_BIT                                                          = 0x2000,
	/// Controls coherency of host writes
	VK_ACCESS_HOST_WRITE_BIT                                                         = 0x4000,
	/// Controls coherency of memory reads
	VK_ACCESS_MEMORY_READ_BIT                                                        = 0x8000,
	/// Controls coherency of memory writes
	VK_ACCESS_MEMORY_WRITE_BIT                                                       = 0x10000,
	VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT                                       = 0x2000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT                                = 0x4000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT                               = 0x8000000,
	VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT                                     = 0x100000,
	VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT                              = 0x80000,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR                                    = 0x200000,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR                                   = 0x400000,
	VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT                                      = 0x1000000,
	VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR                          = 0x800000,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV                                         = 0x20000,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV                                        = 0x40000,
	VK_ACCESS_NONE_KHR                                                               = 0,
}

impl Default for VkAccessFlagBits {
	fn default() -> Self {
		Self::VK_ACCESS_INDIRECT_COMMAND_READ_BIT
	}
}

pub const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV                                        : VkAccessFlagBits = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
pub const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV                                    : VkAccessFlagBits = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
pub const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV                                   : VkAccessFlagBits = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;

pub use self::VkBufferUsageFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBufferUsageFlagBits {
	/// Can be used as a source of transfer operations
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT                                                 = 0x1,
	/// Can be used as a destination of transfer operations
	VK_BUFFER_USAGE_TRANSFER_DST_BIT                                                 = 0x2,
	/// Can be used as TBO
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT                                         = 0x4,
	/// Can be used as IBO
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT                                         = 0x8,
	/// Can be used as UBO
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT                                               = 0x10,
	/// Can be used as SSBO
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT                                               = 0x20,
	/// Can be used as source of fixed-function index fetch (index buffer)
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT                                                 = 0x40,
	/// Can be used as source of fixed-function vertex fetch (VBO)
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT                                                = 0x80,
	/// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT                                              = 0x100,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT                                        = 0x20000,
	VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR                                         = 0x2000,
	VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR                                         = 0x4000,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT                                = 0x800,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT                        = 0x1000,
	VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT                                    = 0x200,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR             = 0x80000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR                           = 0x100000,
	VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR                                     = 0x400,
	VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR                                         = 0x8000,
	VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR                                         = 0x10000,
}

impl Default for VkBufferUsageFlagBits {
	fn default() -> Self {
		Self::VK_BUFFER_USAGE_TRANSFER_SRC_BIT
	}
}

pub const VK_BUFFER_USAGE_RAY_TRACING_BIT_NV                                              : VkBufferUsageFlagBits = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT                                   : VkBufferUsageFlagBits = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR                                   : VkBufferUsageFlagBits = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;

pub use self::VkBufferCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBufferCreateFlagBits {
	/// Buffer should support sparse backing
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT                                              = 0x1,
	/// Buffer should support sparse backing with partial residency
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT                                            = 0x2,
	/// Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                                              = 0x4,
	VK_BUFFER_CREATE_PROTECTED_BIT                                                   = 0x8,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT                               = 0x10,
}

impl Default for VkBufferCreateFlagBits {
	fn default() -> Self {
		Self::VK_BUFFER_CREATE_SPARSE_BINDING_BIT
	}
}

pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT                          : VkBufferCreateFlagBits = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR                          : VkBufferCreateFlagBits = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;

pub use self::VkShaderStageFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShaderStageFlagBits {
	VK_SHADER_STAGE_VERTEX_BIT                                                       = 0x1,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT                                         = 0x2,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT                                      = 0x4,
	VK_SHADER_STAGE_GEOMETRY_BIT                                                     = 0x8,
	VK_SHADER_STAGE_FRAGMENT_BIT                                                     = 0x10,
	VK_SHADER_STAGE_COMPUTE_BIT                                                      = 0x20,
	VK_SHADER_STAGE_ALL_GRAPHICS                                                     = 0x0000001f32,
	VK_SHADER_STAGE_ALL                                                              = 0x7f32FFFFFF,
	VK_SHADER_STAGE_RAYGEN_BIT_KHR                                                   = 0x100,
	VK_SHADER_STAGE_ANY_HIT_BIT_KHR                                                  = 0x200,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR                                              = 0x400,
	VK_SHADER_STAGE_MISS_BIT_KHR                                                     = 0x800,
	VK_SHADER_STAGE_INTERSECTION_BIT_KHR                                             = 0x1000,
	VK_SHADER_STAGE_CALLABLE_BIT_KHR                                                 = 0x2000,
	VK_SHADER_STAGE_TASK_BIT_NV                                                      = 0x40,
	VK_SHADER_STAGE_MESH_BIT_NV                                                      = 0x80,
	VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI                                       = 0x4000,
}

impl Default for VkShaderStageFlagBits {
	fn default() -> Self {
		Self::VK_SHADER_STAGE_VERTEX_BIT
	}
}

pub const VK_SHADER_STAGE_RAYGEN_BIT_NV                                                   : VkShaderStageFlagBits = VK_SHADER_STAGE_RAYGEN_BIT_KHR;
pub const VK_SHADER_STAGE_ANY_HIT_BIT_NV                                                  : VkShaderStageFlagBits = VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
pub const VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV                                              : VkShaderStageFlagBits = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
pub const VK_SHADER_STAGE_MISS_BIT_NV                                                     : VkShaderStageFlagBits = VK_SHADER_STAGE_MISS_BIT_KHR;
pub const VK_SHADER_STAGE_INTERSECTION_BIT_NV                                             : VkShaderStageFlagBits = VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
pub const VK_SHADER_STAGE_CALLABLE_BIT_NV                                                 : VkShaderStageFlagBits = VK_SHADER_STAGE_CALLABLE_BIT_KHR;

pub use self::VkImageUsageFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageUsageFlagBits {
	/// Can be used as a source of transfer operations
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT                                                  = 0x1,
	/// Can be used as a destination of transfer operations
	VK_IMAGE_USAGE_TRANSFER_DST_BIT                                                  = 0x2,
	/// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
	VK_IMAGE_USAGE_SAMPLED_BIT                                                       = 0x4,
	/// Can be used as storage image (STORAGE_IMAGE descriptor type)
	VK_IMAGE_USAGE_STORAGE_BIT                                                       = 0x8,
	/// Can be used as framebuffer color attachment
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT                                              = 0x10,
	/// Can be used as framebuffer depth/stencil attachment
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT                                      = 0x20,
	/// Image data not needed outside of rendering
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT                                          = 0x40,
	/// Can be used as framebuffer input attachment
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT                                              = 0x80,
	VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR                                          = 0x400,
	VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR                                          = 0x800,
	VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR                                          = 0x1000,
	VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT                                      = 0x200,
	VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR                          = 0x100,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR                                          = 0x2000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR                                          = 0x4000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR                                          = 0x8000,
}

impl Default for VkImageUsageFlagBits {
	fn default() -> Self {
		Self::VK_IMAGE_USAGE_TRANSFER_SRC_BIT
	}
}

pub const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV                                        : VkImageUsageFlagBits = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;

pub use self::VkImageCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageCreateFlagBits {
	/// Image should support sparse backing
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT                                               = 0x1,
	/// Image should support sparse backing with partial residency
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT                                             = 0x2,
	/// Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT                                               = 0x4,
	/// Allows image views to have different format than the base image
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT                                               = 0x8,
	/// Allows creating image views with cube type from the created image
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT                                              = 0x10,
	VK_IMAGE_CREATE_ALIAS_BIT                                                        = 0x400,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT                                  = 0x40,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT                                          = 0x20,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT                                  = 0x80,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT                                               = 0x100,
	VK_IMAGE_CREATE_PROTECTED_BIT                                                    = 0x800,
	VK_IMAGE_CREATE_DISJOINT_BIT                                                     = 0x200,
	VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV                                            = 0x2000,
	VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT                        = 0x1000,
	VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT                                               = 0x4000,
}

impl Default for VkImageCreateFlagBits {
	fn default() -> Self {
		Self::VK_IMAGE_CREATE_SPARSE_BINDING_BIT
	}
}

pub const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR                             : VkImageCreateFlagBits = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
pub const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR                                     : VkImageCreateFlagBits = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT;
pub const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR                             : VkImageCreateFlagBits = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
pub const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR                                          : VkImageCreateFlagBits = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT;
pub const VK_IMAGE_CREATE_DISJOINT_BIT_KHR                                                : VkImageCreateFlagBits = VK_IMAGE_CREATE_DISJOINT_BIT;
pub const VK_IMAGE_CREATE_ALIAS_BIT_KHR                                                   : VkImageCreateFlagBits = VK_IMAGE_CREATE_ALIAS_BIT;

pub use self::VkImageViewCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageViewCreateFlagBits {
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT                        = 0x1,
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT                       = 0x2,
}

impl Default for VkImageViewCreateFlagBits {
	fn default() -> Self {
		Self::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
	}
}

pub use self::VkSamplerCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSamplerCreateFlagBits {
	VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT                                             = 0x1,
	VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT                       = 0x2,
}

impl Default for VkSamplerCreateFlagBits {
	fn default() -> Self {
		Self::VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT
	}
}

/// Note that the gap at bitpos 10 is unused, and can be reserved
pub use self::VkPipelineCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineCreateFlagBits {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT                                      = 0x1,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                                         = 0x2,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT                                                = 0x4,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT                              = 0x8,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT                                             = 0x10,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR                   = 0x4000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR               = 0x8000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR                      = 0x10000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR              = 0x20000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR                            = 0x1000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR                                = 0x2000,
	VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR        = 0x80000,
	VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV                                          = 0x20,
	VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR                                    = 0x40,
	VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR                      = 0x80,
	VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV                                      = 0x40000,
	VK_PIPELINE_CREATE_LIBRARY_BIT_KHR                                               = 0x800,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT                     = 0x100,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT                               = 0x200,
	VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV                               = 0x100000,
}

impl Default for VkPipelineCreateFlagBits {
	fn default() -> Self {
		Self::VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT
	}
}

pub const VK_PIPELINE_CREATE_DISPATCH_BASE                                                : VkPipelineCreateFlagBits = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
pub const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR                         : VkPipelineCreateFlagBits = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
pub const VK_PIPELINE_CREATE_DISPATCH_BASE_KHR                                            : VkPipelineCreateFlagBits = VK_PIPELINE_CREATE_DISPATCH_BASE;

pub use self::VkPipelineShaderStageCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineShaderStageCreateFlagBits {
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT              = 0x1,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT                   = 0x2,
}

impl Default for VkPipelineShaderStageCreateFlagBits {
	fn default() -> Self {
		Self::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
	}
}

pub use self::VkColorComponentFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkColorComponentFlagBits {
	VK_COLOR_COMPONENT_R_BIT                                                         = 0x1,
	VK_COLOR_COMPONENT_G_BIT                                                         = 0x2,
	VK_COLOR_COMPONENT_B_BIT                                                         = 0x4,
	VK_COLOR_COMPONENT_A_BIT                                                         = 0x8,
}

impl Default for VkColorComponentFlagBits {
	fn default() -> Self {
		Self::VK_COLOR_COMPONENT_R_BIT
	}
}

pub use self::VkFenceCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFenceCreateFlagBits {
	VK_FENCE_CREATE_SIGNALED_BIT                                                     = 0x1,
}

impl Default for VkFenceCreateFlagBits {
	fn default() -> Self {
		Self::VK_FENCE_CREATE_SIGNALED_BIT
	}
}
// When VkSemaphoreCreateFlagBits is first extended, need to add a bitmask enums tag for it here

pub use self::VkFormatFeatureFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFormatFeatureFlagBits {
	/// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                                              = 0x1,
	/// Format can be used for storage images (STORAGE_IMAGE descriptor type)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                                              = 0x2,
	/// Format supports atomic operations in case it is used for storage images
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT                                       = 0x4,
	/// Format can be used for uniform texel buffers (TBOs)
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT                                       = 0x8,
	/// Format can be used for storage texel buffers (IBOs)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT                                       = 0x10,
	/// Format supports atomic operations in case it is used for storage texel buffers
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT                                = 0x20,
	/// Format can be used for vertex buffers (VBOs)
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                                              = 0x40,
	/// Format can be used for color attachment images
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                                           = 0x80,
	/// Format supports blending in case it is used for color attachment images
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT                                     = 0x100,
	/// Format can be used for depth/stencil attachment images
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT                                   = 0x200,
	/// Format can be used as the source image of blits with vkCmdBlitImage
	VK_FORMAT_FEATURE_BLIT_SRC_BIT                                                   = 0x400,
	/// Format can be used as the destination image of blits with vkCmdBlitImage
	VK_FORMAT_FEATURE_BLIT_DST_BIT                                                   = 0x800,
	/// Format can be filtered with VK_FILTER_LINEAR when being sampled
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT                                = 0x1000,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT                                               = 0x4000,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT                                               = 0x8000,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT                                    = 0x20000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT               = 0x40000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x80000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x100000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x200000,
	VK_FORMAT_FEATURE_DISJOINT_BIT                                                   = 0x400000,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT                                     = 0x800000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT                                = 0x10000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG                             = 0x2000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR                                    = 0x2000000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR                                       = 0x4000000,
	VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR                   = 0x20000000,
	VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT                                   = 0x1000000,
	VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR                       = 0x40000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR                                     = 0x8000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR                                       = 0x10000000,
}

impl Default for VkFormatFeatureFlagBits {
	fn default() -> Self {
		Self::VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
	}
}

pub const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR                                          : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT;
pub const VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR                                          : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_TRANSFER_DST_BIT;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT                           : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT;
pub const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR                               : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR          : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
pub const VK_FORMAT_FEATURE_DISJOINT_BIT_KHR                                              : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_DISJOINT_BIT;
pub const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR                                : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT                            : VkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;

pub use self::VkQueryControlFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueryControlFlagBits {
	/// Require precise results to be collected by the query
	VK_QUERY_CONTROL_PRECISE_BIT                                                     = 0x1,
}

impl Default for VkQueryControlFlagBits {
	fn default() -> Self {
		Self::VK_QUERY_CONTROL_PRECISE_BIT
	}
}

pub use self::VkQueryResultFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueryResultFlagBits {
	/// Results of the queries are written to the destination buffer as 64-bit values
	VK_QUERY_RESULT_64_BIT                                                           = 0x1,
	/// Results of the queries are waited on before proceeding with the result copy
	VK_QUERY_RESULT_WAIT_BIT                                                         = 0x2,
	/// Besides the results of the query, the availability of the results is also written
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT                                            = 0x4,
	/// Copy the partial results of the query even if the final results are not available
	VK_QUERY_RESULT_PARTIAL_BIT                                                      = 0x8,
	VK_QUERY_RESULT_WITH_STATUS_BIT_KHR                                              = 0x10,
}

impl Default for VkQueryResultFlagBits {
	fn default() -> Self {
		Self::VK_QUERY_RESULT_64_BIT
	}
}

pub use self::VkCommandBufferUsageFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCommandBufferUsageFlagBits {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT                                      = 0x1,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT                                 = 0x2,
	/// Command buffer may be submitted/executed more than once simultaneously
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT                                     = 0x4,
}

impl Default for VkCommandBufferUsageFlagBits {
	fn default() -> Self {
		Self::VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT
	}
}

pub use self::VkQueryPipelineStatisticFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueryPipelineStatisticFlagBits {
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                          = 0x1,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                        = 0x2,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                        = 0x4,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                      = 0x8,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                       = 0x10,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                             = 0x20,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                              = 0x40,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                      = 0x80,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT              = 0x100,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT       = 0x200,
	/// Optional
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                       = 0x400,
}

impl Default for VkQueryPipelineStatisticFlagBits {
	fn default() -> Self {
		Self::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT
	}
}

pub use self::VkImageAspectFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkImageAspectFlagBits {
	VK_IMAGE_ASPECT_COLOR_BIT                                                        = 0x1,
	VK_IMAGE_ASPECT_DEPTH_BIT                                                        = 0x2,
	VK_IMAGE_ASPECT_STENCIL_BIT                                                      = 0x4,
	VK_IMAGE_ASPECT_METADATA_BIT                                                     = 0x8,
	VK_IMAGE_ASPECT_PLANE_0_BIT                                                      = 0x10,
	VK_IMAGE_ASPECT_PLANE_1_BIT                                                      = 0x20,
	VK_IMAGE_ASPECT_PLANE_2_BIT                                                      = 0x40,
	VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT                                           = 0x80,
	VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT                                           = 0x100,
	VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT                                           = 0x200,
	VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT                                           = 0x400,
}

impl Default for VkImageAspectFlagBits {
	fn default() -> Self {
		Self::VK_IMAGE_ASPECT_COLOR_BIT
	}
}

pub const VK_IMAGE_ASPECT_PLANE_0_BIT_KHR                                                 : VkImageAspectFlagBits = VK_IMAGE_ASPECT_PLANE_0_BIT;
pub const VK_IMAGE_ASPECT_PLANE_1_BIT_KHR                                                 : VkImageAspectFlagBits = VK_IMAGE_ASPECT_PLANE_1_BIT;
pub const VK_IMAGE_ASPECT_PLANE_2_BIT_KHR                                                 : VkImageAspectFlagBits = VK_IMAGE_ASPECT_PLANE_2_BIT;

pub use self::VkSparseImageFormatFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSparseImageFormatFlagBits {
	/// Image uses a single mip tail region for all array layers
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT                                        = 0x1,
	/// Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT                                      = 0x2,
	/// Image uses a non-standard sparse image block dimensions
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT                                = 0x4,
}

impl Default for VkSparseImageFormatFlagBits {
	fn default() -> Self {
		Self::VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT
	}
}

pub use self::VkSparseMemoryBindFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSparseMemoryBindFlagBits {
	/// Operation binds resource metadata to memory
	VK_SPARSE_MEMORY_BIND_METADATA_BIT                                               = 0x1,
}

impl Default for VkSparseMemoryBindFlagBits {
	fn default() -> Self {
		Self::VK_SPARSE_MEMORY_BIND_METADATA_BIT
	}
}

pub use self::VkPipelineStageFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineStageFlagBits {
	/// Before subsequent commands are processed
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                                                = 0x1,
	/// Draw/DispatchIndirect command fetch
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                                              = 0x2,
	/// Vertex/index fetch
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                                               = 0x4,
	/// Vertex shading
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                                              = 0x8,
	/// Tessellation control shading
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT                                = 0x10,
	/// Tessellation evaluation shading
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT                             = 0x20,
	/// Geometry shading
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                                            = 0x40,
	/// Fragment shading
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                                            = 0x80,
	/// Early fragment (depth and stencil) tests
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT                                       = 0x100,
	/// Late fragment (depth and stencil) tests
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT                                        = 0x200,
	/// Color attachment writes
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT                                    = 0x400,
	/// Compute shading
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                                             = 0x800,
	/// Transfer/copy operations
	VK_PIPELINE_STAGE_TRANSFER_BIT                                                   = 0x1000,
	/// After previous commands have completed
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                                             = 0x2000,
	/// Indicates host (CPU) is a source/sink of the dependency
	VK_PIPELINE_STAGE_HOST_BIT                                                       = 0x4000,
	/// All stages of the graphics pipeline
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                                               = 0x8000,
	/// All stages supported on the queue
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                                               = 0x10000,
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT                                     = 0x1000000,
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT                                  = 0x40000,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR                           = 0x2000000,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR                                     = 0x200000,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV                                             = 0x80000,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV                                             = 0x100000,
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT                               = 0x800000,
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR                       = 0x400000,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV                                      = 0x20000,
	VK_PIPELINE_STAGE_NONE_KHR                                                       = 0,
}

impl Default for VkPipelineStageFlagBits {
	fn default() -> Self {
		Self::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
	}
}

pub const VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV                                     : VkPipelineStageFlagBits = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
pub const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV                                     : VkPipelineStageFlagBits = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
pub const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV                           : VkPipelineStageFlagBits = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;

pub use self::VkCommandPoolCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCommandPoolCreateFlagBits {
	/// Command buffers have a short lifetime
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT                                             = 0x1,
	/// Command buffers may release their memory individually
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT                                  = 0x2,
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT                                             = 0x4,
}

impl Default for VkCommandPoolCreateFlagBits {
	fn default() -> Self {
		Self::VK_COMMAND_POOL_CREATE_TRANSIENT_BIT
	}
}

pub use self::VkCommandPoolResetFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCommandPoolResetFlagBits {
	/// Release resources owned by the pool
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT                                      = 0x1,
}

impl Default for VkCommandPoolResetFlagBits {
	fn default() -> Self {
		Self::VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT
	}
}

pub use self::VkCommandBufferResetFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCommandBufferResetFlagBits {
	/// Release resources owned by the buffer
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT                                    = 0x1,
}

impl Default for VkCommandBufferResetFlagBits {
	fn default() -> Self {
		Self::VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT
	}
}

pub use self::VkSampleCountFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSampleCountFlagBits {
	/// Sample count 1 supported
	VK_SAMPLE_COUNT_1_BIT                                                            = 0x1,
	/// Sample count 2 supported
	VK_SAMPLE_COUNT_2_BIT                                                            = 0x2,
	/// Sample count 4 supported
	VK_SAMPLE_COUNT_4_BIT                                                            = 0x4,
	/// Sample count 8 supported
	VK_SAMPLE_COUNT_8_BIT                                                            = 0x8,
	/// Sample count 16 supported
	VK_SAMPLE_COUNT_16_BIT                                                           = 0x10,
	/// Sample count 32 supported
	VK_SAMPLE_COUNT_32_BIT                                                           = 0x20,
	/// Sample count 64 supported
	VK_SAMPLE_COUNT_64_BIT                                                           = 0x40,
}

impl Default for VkSampleCountFlagBits {
	fn default() -> Self {
		Self::VK_SAMPLE_COUNT_1_BIT
	}
}

pub use self::VkAttachmentDescriptionFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAttachmentDescriptionFlagBits {
	/// The attachment may alias physical memory of another attachment in the same render pass
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT                                          = 0x1,
}

impl Default for VkAttachmentDescriptionFlagBits {
	fn default() -> Self {
		Self::VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT
	}
}

pub use self::VkStencilFaceFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkStencilFaceFlagBits {
	/// Front face
	VK_STENCIL_FACE_FRONT_BIT                                                        = 0x1,
	/// Back face
	VK_STENCIL_FACE_BACK_BIT                                                         = 0x2,
	/// Front and back faces
	VK_STENCIL_FACE_FRONT_AND_BACK                                                   = 0x00000003,
}

impl Default for VkStencilFaceFlagBits {
	fn default() -> Self {
		Self::VK_STENCIL_FACE_FRONT_BIT
	}
}

/// Alias for backwards compatibility
pub const VK_STENCIL_FRONT_AND_BACK                                                       : VkStencilFaceFlagBits = VK_STENCIL_FACE_FRONT_AND_BACK;

pub use self::VkDescriptorPoolCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDescriptorPoolCreateFlagBits {
	/// Descriptor sets may be freed individually
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT                                = 0x1,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT                                  = 0x2,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE                                    = 0x4,
}

impl Default for VkDescriptorPoolCreateFlagBits {
	fn default() -> Self {
		Self::VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT
	}
}

pub const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT                             : VkDescriptorPoolCreateFlagBits = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT;

pub use self::VkDependencyFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDependencyFlagBits {
	/// Dependency is per pixel region
	VK_DEPENDENCY_BY_REGION_BIT                                                      = 0x1,
	VK_DEPENDENCY_DEVICE_GROUP_BIT                                                   = 0x4,
	VK_DEPENDENCY_VIEW_LOCAL_BIT                                                     = 0x2,
}

impl Default for VkDependencyFlagBits {
	fn default() -> Self {
		Self::VK_DEPENDENCY_BY_REGION_BIT
	}
}

pub const VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR                                                : VkDependencyFlagBits = VK_DEPENDENCY_VIEW_LOCAL_BIT;
pub const VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR                                              : VkDependencyFlagBits = VK_DEPENDENCY_DEVICE_GROUP_BIT;

pub use self::VkSemaphoreType::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSemaphoreType {
	VK_SEMAPHORE_TYPE_BINARY                                                         = 0,
	VK_SEMAPHORE_TYPE_TIMELINE                                                       = 1,
}

impl Default for VkSemaphoreType {
	fn default() -> Self {
		Self::VK_SEMAPHORE_TYPE_BINARY
	}
}

pub const VK_SEMAPHORE_TYPE_BINARY_KHR                                                    : VkSemaphoreType = VK_SEMAPHORE_TYPE_BINARY;
pub const VK_SEMAPHORE_TYPE_TIMELINE_KHR                                                  : VkSemaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;

pub use self::VkSemaphoreWaitFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSemaphoreWaitFlagBits {
	VK_SEMAPHORE_WAIT_ANY_BIT                                                        = 0x1,
}

impl Default for VkSemaphoreWaitFlagBits {
	fn default() -> Self {
		Self::VK_SEMAPHORE_WAIT_ANY_BIT
	}
}

pub const VK_SEMAPHORE_WAIT_ANY_BIT_KHR                                                   : VkSemaphoreWaitFlagBits = VK_SEMAPHORE_WAIT_ANY_BIT;
// WSI Extensions

pub use self::VkPresentModeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPresentModeKHR {
	VK_PRESENT_MODE_IMMEDIATE_KHR                                                    = 0,
	VK_PRESENT_MODE_MAILBOX_KHR                                                      = 1,
	VK_PRESENT_MODE_FIFO_KHR                                                         = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR                                                 = 3,
	VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR                                        = 1000111000,
	VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR                                    = 1000111001,
}

impl Default for VkPresentModeKHR {
	fn default() -> Self {
		Self::VK_PRESENT_MODE_IMMEDIATE_KHR
	}
}

pub use self::VkColorSpaceKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkColorSpaceKHR {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR                                                = 0,
	VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT                                          = 1000104001,
	VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT                                          = 1000104002,
	VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT                                             = 1000104003,
	VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT                                              = 1000104004,
	VK_COLOR_SPACE_BT709_LINEAR_EXT                                                  = 1000104005,
	VK_COLOR_SPACE_BT709_NONLINEAR_EXT                                               = 1000104006,
	VK_COLOR_SPACE_BT2020_LINEAR_EXT                                                 = 1000104007,
	VK_COLOR_SPACE_HDR10_ST2084_EXT                                                  = 1000104008,
	VK_COLOR_SPACE_DOLBYVISION_EXT                                                   = 1000104009,
	VK_COLOR_SPACE_HDR10_HLG_EXT                                                     = 1000104010,
	VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT                                               = 1000104011,
	VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT                                            = 1000104012,
	VK_COLOR_SPACE_PASS_THROUGH_EXT                                                  = 1000104013,
	VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT                                       = 1000104014,
	VK_COLOR_SPACE_DISPLAY_NATIVE_AMD                                                = 1000213000,
}

impl Default for VkColorSpaceKHR {
	fn default() -> Self {
		Self::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
	}
}

/// Backwards-compatible alias containing a typo
pub const VK_COLORSPACE_SRGB_NONLINEAR_KHR                                                : VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
pub const VK_COLOR_SPACE_DCI_P3_LINEAR_EXT                                                : VkColorSpaceKHR = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;

pub use self::VkDisplayPlaneAlphaFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                                            = 0x1,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                                            = 0x2,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR                                         = 0x4,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR                           = 0x8,
}

impl Default for VkDisplayPlaneAlphaFlagBitsKHR {
	fn default() -> Self {
		Self::VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR
	}
}

pub use self::VkCompositeAlphaFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCompositeAlphaFlagBitsKHR {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR                                                = 0x1,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR                                        = 0x2,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR                                       = 0x4,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR                                               = 0x8,
}

impl Default for VkCompositeAlphaFlagBitsKHR {
	fn default() -> Self {
		Self::VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR
	}
}

pub use self::VkSurfaceTransformFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSurfaceTransformFlagBitsKHR {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                                            = 0x1,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                                           = 0x2,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                                          = 0x4,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                                          = 0x8,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR                                   = 0x10,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR                         = 0x20,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR                        = 0x40,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR                        = 0x80,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                                             = 0x100,
}

impl Default for VkSurfaceTransformFlagBitsKHR {
	fn default() -> Self {
		Self::VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR
	}
}

pub use self::VkSwapchainImageUsageFlagBitsANDROID::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSwapchainImageUsageFlagBitsANDROID {
	VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID                                      = 0x1,
}

impl Default for VkSwapchainImageUsageFlagBitsANDROID {
	fn default() -> Self {
		Self::VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID
	}
}

pub use self::VkTimeDomainEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkTimeDomainEXT {
	VK_TIME_DOMAIN_DEVICE_EXT                                                        = 0,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT                                               = 1,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT                                           = 2,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT                                     = 3,
}

impl Default for VkTimeDomainEXT {
	fn default() -> Self {
		Self::VK_TIME_DOMAIN_DEVICE_EXT
	}
}

pub use self::VkDebugReportFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDebugReportFlagBitsEXT {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT                                              = 0x1,
	VK_DEBUG_REPORT_WARNING_BIT_EXT                                                  = 0x2,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT                                      = 0x4,
	VK_DEBUG_REPORT_ERROR_BIT_EXT                                                    = 0x8,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT                                                    = 0x10,
}

impl Default for VkDebugReportFlagBitsEXT {
	fn default() -> Self {
		Self::VK_DEBUG_REPORT_INFORMATION_BIT_EXT
	}
}

pub use self::VkDebugReportObjectTypeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDebugReportObjectTypeEXT {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT                                          = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT                                         = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT                                  = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                                           = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                                            = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT                                        = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT                                   = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                                            = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT                                    = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                                           = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                                            = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                                            = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT                                       = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT                                      = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT                                       = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT                                    = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT                                   = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT                                  = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT                                      = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT                                         = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT                            = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT                                          = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT                                  = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT                                   = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT                                      = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT                                     = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT                                      = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT                                    = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT                        = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT                                      = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT                                 = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT                             = 33,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT                         = 1000156000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT                       = 1000085000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT                                    = 1000029000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT                                  = 1000029001,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT                       = 1000150000,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT                        = 1000165000,
}

impl Default for VkDebugReportObjectTypeEXT {
	fn default() -> Self {
		Self::VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
	}
}

/// Backwards-compatible alias containing a typo
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT                                    : VkDebugReportObjectTypeEXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
/// Backwards-compatible alias containing a typo
pub const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT                                : VkDebugReportObjectTypeEXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT                  : VkDebugReportObjectTypeEXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT                    : VkDebugReportObjectTypeEXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;

pub use self::VkDeviceMemoryReportEventTypeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDeviceMemoryReportEventTypeEXT {
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT                                  = 0,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT                                      = 1,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT                                    = 2,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT                                  = 3,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT                         = 4,
}

impl Default for VkDeviceMemoryReportEventTypeEXT {
	fn default() -> Self {
		Self::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT
	}
}

pub use self::VkRasterizationOrderAMD::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkRasterizationOrderAMD {
	VK_RASTERIZATION_ORDER_STRICT_AMD                                                = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD                                               = 1,
}

impl Default for VkRasterizationOrderAMD {
	fn default() -> Self {
		Self::VK_RASTERIZATION_ORDER_STRICT_AMD
	}
}

pub use self::VkExternalMemoryHandleTypeFlagBitsNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalMemoryHandleTypeFlagBitsNV {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV                               = 0x1,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV                           = 0x2,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV                                = 0x4,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV                            = 0x8,
}

impl Default for VkExternalMemoryHandleTypeFlagBitsNV {
	fn default() -> Self {
		Self::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV
	}
}

pub use self::VkExternalMemoryFeatureFlagBitsNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalMemoryFeatureFlagBitsNV {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV                                 = 0x1,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV                                     = 0x2,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV                                     = 0x4,
}

impl Default for VkExternalMemoryFeatureFlagBitsNV {
	fn default() -> Self {
		Self::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV
	}
}

pub use self::VkValidationCheckEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkValidationCheckEXT {
	VK_VALIDATION_CHECK_ALL_EXT                                                      = 0,
	VK_VALIDATION_CHECK_SHADERS_EXT                                                  = 1,
}

impl Default for VkValidationCheckEXT {
	fn default() -> Self {
		Self::VK_VALIDATION_CHECK_ALL_EXT
	}
}

pub use self::VkValidationFeatureEnableEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkValidationFeatureEnableEXT {
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT                                    = 0,
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT               = 1,
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT                                  = 2,
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT                                    = 3,
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT                      = 4,
}

impl Default for VkValidationFeatureEnableEXT {
	fn default() -> Self {
		Self::VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT
	}
}

pub use self::VkValidationFeatureDisableEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkValidationFeatureDisableEXT {
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT                                            = 0,
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT                                        = 1,
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT                                  = 2,
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT                                 = 3,
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT                               = 4,
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT                                    = 5,
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT                                 = 6,
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT                        = 7,
}

impl Default for VkValidationFeatureDisableEXT {
	fn default() -> Self {
		Self::VK_VALIDATION_FEATURE_DISABLE_ALL_EXT
	}
}

pub use self::VkSubgroupFeatureFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSubgroupFeatureFlagBits {
	/// Basic subgroup operations
	VK_SUBGROUP_FEATURE_BASIC_BIT                                                    = 0x1,
	/// Vote subgroup operations
	VK_SUBGROUP_FEATURE_VOTE_BIT                                                     = 0x2,
	/// Arithmetic subgroup operations
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT                                               = 0x4,
	/// Ballot subgroup operations
	VK_SUBGROUP_FEATURE_BALLOT_BIT                                                   = 0x8,
	/// Shuffle subgroup operations
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT                                                  = 0x10,
	/// Shuffle relative subgroup operations
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT                                         = 0x20,
	/// Clustered subgroup operations
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT                                                = 0x40,
	/// Quad subgroup operations
	VK_SUBGROUP_FEATURE_QUAD_BIT                                                     = 0x80,
	VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV                                           = 0x100,
}

impl Default for VkSubgroupFeatureFlagBits {
	fn default() -> Self {
		Self::VK_SUBGROUP_FEATURE_BASIC_BIT
	}
}

pub use self::VkIndirectCommandsLayoutUsageFlagBitsNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsNV {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV                     = 0x1,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV                       = 0x2,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV                     = 0x4,
}

impl Default for VkIndirectCommandsLayoutUsageFlagBitsNV {
	fn default() -> Self {
		Self::VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV
	}
}

pub use self::VkIndirectStateFlagBitsNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkIndirectStateFlagBitsNV {
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV                                          = 0x1,
}

impl Default for VkIndirectStateFlagBitsNV {
	fn default() -> Self {
		Self::VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV
	}
}

pub use self::VkIndirectCommandsTokenTypeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkIndirectCommandsTokenTypeNV {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV                                  = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV                                   = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV                                  = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV                                 = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV                                 = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV                                  = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV                                          = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV                                    = 7,
}

impl Default for VkIndirectCommandsTokenTypeNV {
	fn default() -> Self {
		Self::VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV
	}
}

pub use self::VkPrivateDataSlotCreateFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPrivateDataSlotCreateFlagBitsEXT {
	__Default__ = 0,
}

impl Default for VkPrivateDataSlotCreateFlagBitsEXT {
	fn default() -> Self {
		Self::__Default__
	}
}

pub use self::VkDescriptorSetLayoutCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDescriptorSetLayoutCreateFlagBits {
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT                       = 0x2,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR                          = 0x1,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE                         = 0x4,
}

impl Default for VkDescriptorSetLayoutCreateFlagBits {
	fn default() -> Self {
		Self::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT
	}
}

pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT                  : VkDescriptorSetLayoutCreateFlagBits = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT;

pub use self::VkExternalMemoryHandleTypeFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalMemoryHandleTypeFlagBits {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT                                     = 0x1,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT                                  = 0x2,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT                              = 0x4,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT                                 = 0x8,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT                             = 0x10,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT                                    = 0x20,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT                                = 0x40,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT                                   = 0x200,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID               = 0x400,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT                           = 0x80,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT                = 0x100,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA                            = 0x800,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV                               = 0x1000,
}

impl Default for VkExternalMemoryHandleTypeFlagBits {
	fn default() -> Self {
		Self::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
	}
}

pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR                                : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR                             : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR                         : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR                            : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR                        : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR                               : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR                           : VkExternalMemoryHandleTypeFlagBits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;

pub use self::VkExternalMemoryFeatureFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalMemoryFeatureFlagBits {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT                                    = 0x1,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT                                        = 0x2,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT                                        = 0x4,
}

impl Default for VkExternalMemoryFeatureFlagBits {
	fn default() -> Self {
		Self::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
	}
}

pub const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR                               : VkExternalMemoryFeatureFlagBits = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
pub const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR                                   : VkExternalMemoryFeatureFlagBits = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
pub const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR                                   : VkExternalMemoryFeatureFlagBits = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;

pub use self::VkExternalSemaphoreHandleTypeFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalSemaphoreHandleTypeFlagBits {
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT                                  = 0x1,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT                               = 0x2,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT                           = 0x4,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT                                = 0x8,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT                                    = 0x10,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA                       = 0x80,
}

impl Default for VkExternalSemaphoreHandleTypeFlagBits {
	fn default() -> Self {
		Self::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
	}
}

pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT                               : VkExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR                             : VkExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR                          : VkExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR                      : VkExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR                           : VkExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR                               : VkExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;

pub use self::VkExternalSemaphoreFeatureFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalSemaphoreFeatureFlagBits {
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT                                     = 0x1,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT                                     = 0x2,
}

impl Default for VkExternalSemaphoreFeatureFlagBits {
	fn default() -> Self {
		Self::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
	}
}

pub const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR                                : VkExternalSemaphoreFeatureFlagBits = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
pub const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR                                : VkExternalSemaphoreFeatureFlagBits = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;

pub use self::VkSemaphoreImportFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSemaphoreImportFlagBits {
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT                                                = 0x1,
}

impl Default for VkSemaphoreImportFlagBits {
	fn default() -> Self {
		Self::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
	}
}

pub const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR                                           : VkSemaphoreImportFlagBits = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;

pub use self::VkExternalFenceHandleTypeFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalFenceHandleTypeFlagBits {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT                                      = 0x1,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT                                   = 0x2,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT                               = 0x4,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT                                        = 0x8,
}

impl Default for VkExternalFenceHandleTypeFlagBits {
	fn default() -> Self {
		Self::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
	}
}

pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR                                 : VkExternalFenceHandleTypeFlagBits = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR                              : VkExternalFenceHandleTypeFlagBits = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR                          : VkExternalFenceHandleTypeFlagBits = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR                                   : VkExternalFenceHandleTypeFlagBits = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;

pub use self::VkExternalFenceFeatureFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkExternalFenceFeatureFlagBits {
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT                                         = 0x1,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT                                         = 0x2,
}

impl Default for VkExternalFenceFeatureFlagBits {
	fn default() -> Self {
		Self::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
	}
}

pub const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR                                    : VkExternalFenceFeatureFlagBits = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
pub const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR                                    : VkExternalFenceFeatureFlagBits = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;

pub use self::VkFenceImportFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFenceImportFlagBits {
	VK_FENCE_IMPORT_TEMPORARY_BIT                                                    = 0x1,
}

impl Default for VkFenceImportFlagBits {
	fn default() -> Self {
		Self::VK_FENCE_IMPORT_TEMPORARY_BIT
	}
}

pub const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR                                               : VkFenceImportFlagBits = VK_FENCE_IMPORT_TEMPORARY_BIT;

pub use self::VkSurfaceCounterFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSurfaceCounterFlagBitsEXT {
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT                                                = 0x1,
}

impl Default for VkSurfaceCounterFlagBitsEXT {
	fn default() -> Self {
		Self::VK_SURFACE_COUNTER_VBLANK_BIT_EXT
	}
}

/// Backwards-compatible alias containing a typo
pub const VK_SURFACE_COUNTER_VBLANK_EXT                                                   : VkSurfaceCounterFlagBitsEXT = VK_SURFACE_COUNTER_VBLANK_BIT_EXT;

pub use self::VkDisplayPowerStateEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDisplayPowerStateEXT {
	VK_DISPLAY_POWER_STATE_OFF_EXT                                                   = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT                                               = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT                                                    = 2,
}

impl Default for VkDisplayPowerStateEXT {
	fn default() -> Self {
		Self::VK_DISPLAY_POWER_STATE_OFF_EXT
	}
}

pub use self::VkDeviceEventTypeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDeviceEventTypeEXT {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT                                         = 0,
}

impl Default for VkDeviceEventTypeEXT {
	fn default() -> Self {
		Self::VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT
	}
}

pub use self::VkDisplayEventTypeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDisplayEventTypeEXT {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT                                        = 0,
}

impl Default for VkDisplayEventTypeEXT {
	fn default() -> Self {
		Self::VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT
	}
}

pub use self::VkPeerMemoryFeatureFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPeerMemoryFeatureFlagBits {
	/// Can read with vkCmdCopy commands
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT                                              = 0x1,
	/// Can write with vkCmdCopy commands
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT                                              = 0x2,
	/// Can read with any access type/command
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT                                           = 0x4,
	/// Can write with and access type/command
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT                                           = 0x8,
}

impl Default for VkPeerMemoryFeatureFlagBits {
	fn default() -> Self {
		Self::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT
	}
}

pub const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR                                         : VkPeerMemoryFeatureFlagBits = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT;
pub const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR                                         : VkPeerMemoryFeatureFlagBits = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT;
pub const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR                                      : VkPeerMemoryFeatureFlagBits = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
pub const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR                                      : VkPeerMemoryFeatureFlagBits = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;

pub use self::VkMemoryAllocateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkMemoryAllocateFlagBits {
	/// Force allocation on specific devices
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT                                               = 0x1,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT                                            = 0x2,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT                             = 0x4,
}

impl Default for VkMemoryAllocateFlagBits {
	fn default() -> Self {
		Self::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
	}
}

pub const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR                                          : VkMemoryAllocateFlagBits = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR                                       : VkMemoryAllocateFlagBits = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT;
pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR                        : VkMemoryAllocateFlagBits = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;

pub use self::VkDeviceGroupPresentModeFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDeviceGroupPresentModeFlagBitsKHR {
	/// Present from local memory
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR                                       = 0x1,
	/// Present from remote memory
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR                                      = 0x2,
	/// Present sum of local and/or remote memory
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR                                         = 0x4,
	/// Each physical device presents from local memory
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR                          = 0x8,
}

impl Default for VkDeviceGroupPresentModeFlagBitsKHR {
	fn default() -> Self {
		Self::VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR
	}
}

pub use self::VkSwapchainCreateFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSwapchainCreateFlagBitsKHR {
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR                          = 0x1,
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR                                            = 0x2,
	VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR                                       = 0x4,
}

impl Default for VkSwapchainCreateFlagBitsKHR {
	fn default() -> Self {
		Self::VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
	}
}

pub use self::VkViewportCoordinateSwizzleNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkViewportCoordinateSwizzleNV {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV                                     = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV                                     = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV                                     = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV                                     = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV                                     = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV                                     = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV                                     = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV                                     = 7,
}

impl Default for VkViewportCoordinateSwizzleNV {
	fn default() -> Self {
		Self::VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV
	}
}

pub use self::VkDiscardRectangleModeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDiscardRectangleModeEXT {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT                                          = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT                                          = 1,
}

impl Default for VkDiscardRectangleModeEXT {
	fn default() -> Self {
		Self::VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT
	}
}

pub use self::VkSubpassDescriptionFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSubpassDescriptionFlagBits {
	VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX                               = 0x1,
	VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX                          = 0x2,
	VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM                                  = 0x4,
	VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM                                   = 0x8,
}

impl Default for VkSubpassDescriptionFlagBits {
	fn default() -> Self {
		Self::VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX
	}
}

pub use self::VkPointClippingBehavior::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPointClippingBehavior {
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES                                       = 0,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY                                 = 1,
}

impl Default for VkPointClippingBehavior {
	fn default() -> Self {
		Self::VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
	}
}

pub const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR                                  : VkPointClippingBehavior = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
pub const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR                            : VkPointClippingBehavior = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;

pub use self::VkSamplerReductionMode::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSamplerReductionMode {
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE                                       = 0,
	VK_SAMPLER_REDUCTION_MODE_MIN                                                    = 1,
	VK_SAMPLER_REDUCTION_MODE_MAX                                                    = 2,
}

impl Default for VkSamplerReductionMode {
	fn default() -> Self {
		Self::VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE
	}
}

pub const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT                                  : VkSamplerReductionMode = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE;
pub const VK_SAMPLER_REDUCTION_MODE_MIN_EXT                                               : VkSamplerReductionMode = VK_SAMPLER_REDUCTION_MODE_MIN;
pub const VK_SAMPLER_REDUCTION_MODE_MAX_EXT                                               : VkSamplerReductionMode = VK_SAMPLER_REDUCTION_MODE_MAX;

pub use self::VkTessellationDomainOrigin::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkTessellationDomainOrigin {
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT                                         = 0,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT                                         = 1,
}

impl Default for VkTessellationDomainOrigin {
	fn default() -> Self {
		Self::VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
	}
}

pub const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR                                    : VkTessellationDomainOrigin = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
pub const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR                                    : VkTessellationDomainOrigin = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;

pub use self::VkSamplerYcbcrModelConversion::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSamplerYcbcrModelConversion {
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY                                   = 0,
	/// just range expansion
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY                                 = 1,
	/// aka HD YUV
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709                                      = 2,
	/// aka SD YUV
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601                                      = 3,
	/// aka UHD YUV
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020                                     = 4,
}

impl Default for VkSamplerYcbcrModelConversion {
	fn default() -> Self {
		Self::VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
	}
}

pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR                              : VkSamplerYcbcrModelConversion = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR                            : VkSamplerYcbcrModelConversion = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR                                 : VkSamplerYcbcrModelConversion = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR                                 : VkSamplerYcbcrModelConversion = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR                                : VkSamplerYcbcrModelConversion = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;

pub use self::VkSamplerYcbcrRange::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSamplerYcbcrRange {
	/// Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL                                                  = 0,
	/// Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW                                                = 1,
}

impl Default for VkSamplerYcbcrRange {
	fn default() -> Self {
		Self::VK_SAMPLER_YCBCR_RANGE_ITU_FULL
	}
}

pub const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR                                             : VkSamplerYcbcrRange = VK_SAMPLER_YCBCR_RANGE_ITU_FULL;
pub const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR                                           : VkSamplerYcbcrRange = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW;

pub use self::VkChromaLocation::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkChromaLocation {
	VK_CHROMA_LOCATION_COSITED_EVEN                                                  = 0,
	VK_CHROMA_LOCATION_MIDPOINT                                                      = 1,
}

impl Default for VkChromaLocation {
	fn default() -> Self {
		Self::VK_CHROMA_LOCATION_COSITED_EVEN
	}
}

pub const VK_CHROMA_LOCATION_COSITED_EVEN_KHR                                             : VkChromaLocation = VK_CHROMA_LOCATION_COSITED_EVEN;
pub const VK_CHROMA_LOCATION_MIDPOINT_KHR                                                 : VkChromaLocation = VK_CHROMA_LOCATION_MIDPOINT;

pub use self::VkBlendOverlapEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBlendOverlapEXT {
	VK_BLEND_OVERLAP_UNCORRELATED_EXT                                                = 0,
	VK_BLEND_OVERLAP_DISJOINT_EXT                                                    = 1,
	VK_BLEND_OVERLAP_CONJOINT_EXT                                                    = 2,
}

impl Default for VkBlendOverlapEXT {
	fn default() -> Self {
		Self::VK_BLEND_OVERLAP_UNCORRELATED_EXT
	}
}

pub use self::VkCoverageModulationModeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCoverageModulationModeNV {
	VK_COVERAGE_MODULATION_MODE_NONE_NV                                              = 0,
	VK_COVERAGE_MODULATION_MODE_RGB_NV                                               = 1,
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV                                             = 2,
	VK_COVERAGE_MODULATION_MODE_RGBA_NV                                              = 3,
}

impl Default for VkCoverageModulationModeNV {
	fn default() -> Self {
		Self::VK_COVERAGE_MODULATION_MODE_NONE_NV
	}
}

pub use self::VkCoverageReductionModeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCoverageReductionModeNV {
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV                                              = 0,
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV                                           = 1,
}

impl Default for VkCoverageReductionModeNV {
	fn default() -> Self {
		Self::VK_COVERAGE_REDUCTION_MODE_MERGE_NV
	}
}

pub use self::VkValidationCacheHeaderVersionEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkValidationCacheHeaderVersionEXT {
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT                                       = 1,
}

impl Default for VkValidationCacheHeaderVersionEXT {
	fn default() -> Self {
		Self::VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
	}
}

pub use self::VkShaderInfoTypeAMD::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShaderInfoTypeAMD {
	VK_SHADER_INFO_TYPE_STATISTICS_AMD                                               = 0,
	VK_SHADER_INFO_TYPE_BINARY_AMD                                                   = 1,
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD                                              = 2,
}

impl Default for VkShaderInfoTypeAMD {
	fn default() -> Self {
		Self::VK_SHADER_INFO_TYPE_STATISTICS_AMD
	}
}

pub use self::VkQueueGlobalPriorityEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueueGlobalPriorityEXT {
	VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT                                                 = 128,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT                                              = 256,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT                                                = 512,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT                                            = 1024,
}

impl Default for VkQueueGlobalPriorityEXT {
	fn default() -> Self {
		Self::VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT
	}
}

pub use self::VkDebugUtilsMessageSeverityFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDebugUtilsMessageSeverityFlagBitsEXT {
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT                                  = 0x1,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT                                     = 0x10,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT                                  = 0x100,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT                                    = 0x1000,
}

impl Default for VkDebugUtilsMessageSeverityFlagBitsEXT {
	fn default() -> Self {
		Self::VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT
	}
}

pub use self::VkDebugUtilsMessageTypeFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDebugUtilsMessageTypeFlagBitsEXT {
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT                                      = 0x1,
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT                                   = 0x2,
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT                                  = 0x4,
}

impl Default for VkDebugUtilsMessageTypeFlagBitsEXT {
	fn default() -> Self {
		Self::VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT
	}
}

pub use self::VkConservativeRasterizationModeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkConservativeRasterizationModeEXT {
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT                                  = 0,
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT                              = 1,
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT                             = 2,
}

impl Default for VkConservativeRasterizationModeEXT {
	fn default() -> Self {
		Self::VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
	}
}

pub use self::VkDescriptorBindingFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDescriptorBindingFlagBits {
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT                                      = 0x1,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT                            = 0x2,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT                                        = 0x4,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT                              = 0x8,
}

impl Default for VkDescriptorBindingFlagBits {
	fn default() -> Self {
		Self::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT
	}
}

pub const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT                                 : VkDescriptorBindingFlagBits = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT;
pub const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT                       : VkDescriptorBindingFlagBits = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
pub const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT                                   : VkDescriptorBindingFlagBits = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
pub const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT                         : VkDescriptorBindingFlagBits = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;

pub use self::VkVendorId::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVendorId {
	// Vendor IDs are now represented as enums instead of the old
	// <vendorids> tag, allowing them to be included in the
	// API headers.
	/// Vivante vendor ID
	VK_VENDOR_ID_VIV                                                                 = 0x10001,
	/// VeriSilicon vendor ID
	VK_VENDOR_ID_VSI                                                                 = 0x10002,
	/// Kazan Software Renderer
	VK_VENDOR_ID_KAZAN                                                               = 0x10003,
	/// Codeplay Software Ltd. vendor ID
	VK_VENDOR_ID_CODEPLAY                                                            = 0x10004,
	/// Mesa vendor ID
	VK_VENDOR_ID_MESA                                                                = 0x10005,
	/// PoCL vendor ID
	VK_VENDOR_ID_POCL                                                                = 0x10006,
}

impl Default for VkVendorId {
	fn default() -> Self {
		Self::VK_VENDOR_ID_VIV
	}
}

pub use self::VkDriverId::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDriverId {
	// Driver IDs are now represented as enums instead of the old
	// <driverids> tag, allowing them to be included in the
	// API headers.
	/// Advanced Micro Devices, Inc.
	VK_DRIVER_ID_AMD_PROPRIETARY                                                     = 1,
	/// Advanced Micro Devices, Inc.
	VK_DRIVER_ID_AMD_OPEN_SOURCE                                                     = 2,
	/// Mesa open source project
	VK_DRIVER_ID_MESA_RADV                                                           = 3,
	/// NVIDIA Corporation
	VK_DRIVER_ID_NVIDIA_PROPRIETARY                                                  = 4,
	/// Intel Corporation
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS                                           = 5,
	/// Intel Corporation
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA                                              = 6,
	/// Imagination Technologies
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY                                             = 7,
	/// Qualcomm Technologies, Inc.
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY                                                = 8,
	/// Arm Limited
	VK_DRIVER_ID_ARM_PROPRIETARY                                                     = 9,
	/// Google LLC
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER                                                  = 10,
	/// Google LLC
	VK_DRIVER_ID_GGP_PROPRIETARY                                                     = 11,
	/// Broadcom Inc.
	VK_DRIVER_ID_BROADCOM_PROPRIETARY                                                = 12,
	/// Mesa
	VK_DRIVER_ID_MESA_LLVMPIPE                                                       = 13,
	/// MoltenVK
	VK_DRIVER_ID_MOLTENVK                                                            = 14,
	/// Core Avionics & Industrial Inc.
	VK_DRIVER_ID_COREAVI_PROPRIETARY                                                 = 15,
	/// Juice Technologies, Inc.
	VK_DRIVER_ID_JUICE_PROPRIETARY                                                   = 16,
}

impl Default for VkDriverId {
	fn default() -> Self {
		Self::VK_DRIVER_ID_AMD_PROPRIETARY
	}
}

pub const VK_DRIVER_ID_AMD_PROPRIETARY_KHR                                                : VkDriverId = VK_DRIVER_ID_AMD_PROPRIETARY;
pub const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR                                                : VkDriverId = VK_DRIVER_ID_AMD_OPEN_SOURCE;
pub const VK_DRIVER_ID_MESA_RADV_KHR                                                      : VkDriverId = VK_DRIVER_ID_MESA_RADV;
pub const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR                                             : VkDriverId = VK_DRIVER_ID_NVIDIA_PROPRIETARY;
pub const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR                                      : VkDriverId = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS;
pub const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR                                         : VkDriverId = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA;
pub const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR                                        : VkDriverId = VK_DRIVER_ID_IMAGINATION_PROPRIETARY;
pub const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR                                           : VkDriverId = VK_DRIVER_ID_QUALCOMM_PROPRIETARY;
pub const VK_DRIVER_ID_ARM_PROPRIETARY_KHR                                                : VkDriverId = VK_DRIVER_ID_ARM_PROPRIETARY;
pub const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR                                             : VkDriverId = VK_DRIVER_ID_GOOGLE_SWIFTSHADER;
pub const VK_DRIVER_ID_GGP_PROPRIETARY_KHR                                                : VkDriverId = VK_DRIVER_ID_GGP_PROPRIETARY;
pub const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR                                           : VkDriverId = VK_DRIVER_ID_BROADCOM_PROPRIETARY;

pub use self::VkConditionalRenderingFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkConditionalRenderingFlagBitsEXT {
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT                                        = 0x1,
}

impl Default for VkConditionalRenderingFlagBitsEXT {
	fn default() -> Self {
		Self::VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT
	}
}

pub use self::VkResolveModeFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkResolveModeFlagBits {
	VK_RESOLVE_MODE_NONE                                                             = 0,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT                                                  = 0x1,
	VK_RESOLVE_MODE_AVERAGE_BIT                                                      = 0x2,
	VK_RESOLVE_MODE_MIN_BIT                                                          = 0x4,
	VK_RESOLVE_MODE_MAX_BIT                                                          = 0x8,
}

impl Default for VkResolveModeFlagBits {
	fn default() -> Self {
		Self::VK_RESOLVE_MODE_NONE
	}
}

pub const VK_RESOLVE_MODE_NONE_KHR                                                        : VkResolveModeFlagBits = VK_RESOLVE_MODE_NONE;
pub const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR                                             : VkResolveModeFlagBits = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
pub const VK_RESOLVE_MODE_AVERAGE_BIT_KHR                                                 : VkResolveModeFlagBits = VK_RESOLVE_MODE_AVERAGE_BIT;
pub const VK_RESOLVE_MODE_MIN_BIT_KHR                                                     : VkResolveModeFlagBits = VK_RESOLVE_MODE_MIN_BIT;
pub const VK_RESOLVE_MODE_MAX_BIT_KHR                                                     : VkResolveModeFlagBits = VK_RESOLVE_MODE_MAX_BIT;

pub use self::VkShadingRatePaletteEntryNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShadingRatePaletteEntryNV {
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV                                  = 0,
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV                        = 1,
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV                         = 2,
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV                         = 3,
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV                         = 4,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV                          = 5,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV                     = 6,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV                     = 7,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV                     = 8,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV                     = 9,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV                     = 10,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV                     = 11,
}

impl Default for VkShadingRatePaletteEntryNV {
	fn default() -> Self {
		Self::VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV
	}
}

pub use self::VkCoarseSampleOrderTypeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCoarseSampleOrderTypeNV {
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV                                           = 0,
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV                                            = 1,
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV                                       = 2,
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV                                      = 3,
}

impl Default for VkCoarseSampleOrderTypeNV {
	fn default() -> Self {
		Self::VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV
	}
}

pub use self::VkGeometryInstanceFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkGeometryInstanceFlagBitsKHR {
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR                        = 0x1,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR                     = 0x2,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR                                        = 0x4,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR                                     = 0x8,
}

impl Default for VkGeometryInstanceFlagBitsKHR {
	fn default() -> Self {
		Self::VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR
	}
}

pub const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV                               : VkGeometryInstanceFlagBitsKHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV                     : VkGeometryInstanceFlagBitsKHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
pub const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV                                        : VkGeometryInstanceFlagBitsKHR = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR;
pub const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV                                     : VkGeometryInstanceFlagBitsKHR = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR;

pub use self::VkGeometryFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkGeometryFlagBitsKHR {
	VK_GEOMETRY_OPAQUE_BIT_KHR                                                       = 0x1,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR                              = 0x2,
}

impl Default for VkGeometryFlagBitsKHR {
	fn default() -> Self {
		Self::VK_GEOMETRY_OPAQUE_BIT_KHR
	}
}

pub const VK_GEOMETRY_OPAQUE_BIT_NV                                                       : VkGeometryFlagBitsKHR = VK_GEOMETRY_OPAQUE_BIT_KHR;
pub const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV                              : VkGeometryFlagBitsKHR = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;

pub use self::VkBuildAccelerationStructureFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBuildAccelerationStructureFlagBitsKHR {
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR                             = 0x1,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR                         = 0x2,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR                        = 0x4,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR                        = 0x8,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR                               = 0x10,
	VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV                                    = 0x20,
}

impl Default for VkBuildAccelerationStructureFlagBitsKHR {
	fn default() -> Self {
		Self::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR
	}
}

pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV                             : VkBuildAccelerationStructureFlagBitsKHR = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV                         : VkBuildAccelerationStructureFlagBitsKHR = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR;
pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV                        : VkBuildAccelerationStructureFlagBitsKHR = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;
pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV                        : VkBuildAccelerationStructureFlagBitsKHR = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR;
pub const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV                               : VkBuildAccelerationStructureFlagBitsKHR = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;

pub use self::VkAccelerationStructureCreateFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccelerationStructureCreateFlagBitsKHR {
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR           = 0x1,
	VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV                                   = 0x4,
}

impl Default for VkAccelerationStructureCreateFlagBitsKHR {
	fn default() -> Self {
		Self::VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
	}
}

pub use self::VkCopyAccelerationStructureModeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkCopyAccelerationStructureModeKHR {
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR                                    = 0,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR                                  = 1,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR                                = 2,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR                              = 3,
}

impl Default for VkCopyAccelerationStructureModeKHR {
	fn default() -> Self {
		Self::VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR
	}
}

pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV                                    : VkCopyAccelerationStructureModeKHR = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV                                  : VkCopyAccelerationStructureModeKHR = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR;

pub use self::VkBuildAccelerationStructureModeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkBuildAccelerationStructureModeKHR {
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR                                   = 0,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR                                  = 1,
}

impl Default for VkBuildAccelerationStructureModeKHR {
	fn default() -> Self {
		Self::VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR
	}
}

pub use self::VkAccelerationStructureTypeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccelerationStructureTypeKHR {
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR                                     = 0,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR                                  = 1,
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR                                       = 2,
}

impl Default for VkAccelerationStructureTypeKHR {
	fn default() -> Self {
		Self::VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR
	}
}

pub const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV                                     : VkAccelerationStructureTypeKHR = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
pub const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV                                  : VkAccelerationStructureTypeKHR = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;

pub use self::VkGeometryTypeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkGeometryTypeKHR {
	VK_GEOMETRY_TYPE_TRIANGLES_KHR                                                   = 0,
	VK_GEOMETRY_TYPE_AABBS_KHR                                                       = 1,
	VK_GEOMETRY_TYPE_INSTANCES_KHR                                                   = 2,
}

impl Default for VkGeometryTypeKHR {
	fn default() -> Self {
		Self::VK_GEOMETRY_TYPE_TRIANGLES_KHR
	}
}

pub const VK_GEOMETRY_TYPE_TRIANGLES_NV                                                   : VkGeometryTypeKHR = VK_GEOMETRY_TYPE_TRIANGLES_KHR;
pub const VK_GEOMETRY_TYPE_AABBS_NV                                                       : VkGeometryTypeKHR = VK_GEOMETRY_TYPE_AABBS_KHR;

pub use self::VkAccelerationStructureMemoryRequirementsTypeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccelerationStructureMemoryRequirementsTypeNV {
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV                     = 0,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV              = 1,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV             = 2,
}

impl Default for VkAccelerationStructureMemoryRequirementsTypeNV {
	fn default() -> Self {
		Self::VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
	}
}

pub use self::VkAccelerationStructureBuildTypeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccelerationStructureBuildTypeKHR {
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR                                    = 0,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR                                  = 1,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR                          = 2,
}

impl Default for VkAccelerationStructureBuildTypeKHR {
	fn default() -> Self {
		Self::VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR
	}
}

pub use self::VkRayTracingShaderGroupTypeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkRayTracingShaderGroupTypeKHR {
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR                                     = 0,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR                         = 1,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR                        = 2,
}

impl Default for VkRayTracingShaderGroupTypeKHR {
	fn default() -> Self {
		Self::VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR
	}
}

pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV                                     : VkRayTracingShaderGroupTypeKHR = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV                         : VkRayTracingShaderGroupTypeKHR = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV                        : VkRayTracingShaderGroupTypeKHR = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR;

pub use self::VkAccelerationStructureCompatibilityKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccelerationStructureCompatibilityKHR {
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR                           = 0,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR                         = 1,
}

impl Default for VkAccelerationStructureCompatibilityKHR {
	fn default() -> Self {
		Self::VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR
	}
}

pub use self::VkShaderGroupShaderKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShaderGroupShaderKHR {
	VK_SHADER_GROUP_SHADER_GENERAL_KHR                                               = 0,
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR                                           = 1,
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR                                               = 2,
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR                                          = 3,
}

impl Default for VkShaderGroupShaderKHR {
	fn default() -> Self {
		Self::VK_SHADER_GROUP_SHADER_GENERAL_KHR
	}
}

pub use self::VkMemoryOverallocationBehaviorAMD::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkMemoryOverallocationBehaviorAMD {
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD                                    = 0,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD                                    = 1,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD                                 = 2,
}

impl Default for VkMemoryOverallocationBehaviorAMD {
	fn default() -> Self {
		Self::VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD
	}
}

pub use self::VkFramebufferCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFramebufferCreateFlagBits {
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT                                              = 0x1,
}

impl Default for VkFramebufferCreateFlagBits {
	fn default() -> Self {
		Self::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT
	}
}

pub const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR                                         : VkFramebufferCreateFlagBits = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT;

pub use self::VkScopeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkScopeNV {
	VK_SCOPE_DEVICE_NV                                                               = 1,
	VK_SCOPE_WORKGROUP_NV                                                            = 2,
	VK_SCOPE_SUBGROUP_NV                                                             = 3,
	VK_SCOPE_QUEUE_FAMILY_NV                                                         = 5,
}

impl Default for VkScopeNV {
	fn default() -> Self {
		Self::VK_SCOPE_DEVICE_NV
	}
}

pub use self::VkComponentTypeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkComponentTypeNV {
	VK_COMPONENT_TYPE_FLOAT16_NV                                                     = 0,
	VK_COMPONENT_TYPE_FLOAT32_NV                                                     = 1,
	VK_COMPONENT_TYPE_FLOAT64_NV                                                     = 2,
	VK_COMPONENT_TYPE_SINT8_NV                                                       = 3,
	VK_COMPONENT_TYPE_SINT16_NV                                                      = 4,
	VK_COMPONENT_TYPE_SINT32_NV                                                      = 5,
	VK_COMPONENT_TYPE_SINT64_NV                                                      = 6,
	VK_COMPONENT_TYPE_UINT8_NV                                                       = 7,
	VK_COMPONENT_TYPE_UINT16_NV                                                      = 8,
	VK_COMPONENT_TYPE_UINT32_NV                                                      = 9,
	VK_COMPONENT_TYPE_UINT64_NV                                                      = 10,
}

impl Default for VkComponentTypeNV {
	fn default() -> Self {
		Self::VK_COMPONENT_TYPE_FLOAT16_NV
	}
}

pub use self::VkDeviceDiagnosticsConfigFlagBitsNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkDeviceDiagnosticsConfigFlagBitsNV {
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV                     = 0x1,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV                     = 0x2,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV                 = 0x4,
}

impl Default for VkDeviceDiagnosticsConfigFlagBitsNV {
	fn default() -> Self {
		Self::VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV
	}
}

pub use self::VkPipelineCreationFeedbackFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineCreationFeedbackFlagBitsEXT {
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT                                      = 0x1,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT             = 0x2,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT                 = 0x4,
}

impl Default for VkPipelineCreationFeedbackFlagBitsEXT {
	fn default() -> Self {
		Self::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT
	}
}

pub use self::VkFullScreenExclusiveEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFullScreenExclusiveEXT {
	VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT                                             = 0,
	VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT                                             = 1,
	VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT                                          = 2,
	VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT                              = 3,
}

impl Default for VkFullScreenExclusiveEXT {
	fn default() -> Self {
		Self::VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT
	}
}

pub use self::VkPerformanceCounterScopeKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceCounterScopeKHR {
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR                                  = 0,
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR                                     = 1,
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR                                         = 2,
}

impl Default for VkPerformanceCounterScopeKHR {
	fn default() -> Self {
		Self::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR
	}
}

pub const VK_QUERY_SCOPE_COMMAND_BUFFER_KHR                                               : VkPerformanceCounterScopeKHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR;
pub const VK_QUERY_SCOPE_RENDER_PASS_KHR                                                  : VkPerformanceCounterScopeKHR = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR;
pub const VK_QUERY_SCOPE_COMMAND_KHR                                                      : VkPerformanceCounterScopeKHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;

pub use self::VkPerformanceCounterUnitKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceCounterUnitKHR {
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR                                          = 0,
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR                                       = 1,
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR                                      = 2,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR                                            = 3,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR                                 = 4,
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR                                           = 5,
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR                                            = 6,
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR                                            = 7,
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR                                             = 8,
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR                                            = 9,
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR                                           = 10,
}

impl Default for VkPerformanceCounterUnitKHR {
	fn default() -> Self {
		Self::VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR
	}
}

pub use self::VkPerformanceCounterStorageKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceCounterStorageKHR {
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR                                         = 0,
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR                                         = 1,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR                                        = 2,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR                                        = 3,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR                                       = 4,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR                                       = 5,
}

impl Default for VkPerformanceCounterStorageKHR {
	fn default() -> Self {
		Self::VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR
	}
}

pub use self::VkPerformanceCounterDescriptionFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceCounterDescriptionFlagBitsKHR {
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR                 = 0x1,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR                 = 0x2,
}

impl Default for VkPerformanceCounterDescriptionFlagBitsKHR {
	fn default() -> Self {
		Self::VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR
	}
}

/// Backwards-compatible alias containing a typo
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR                    : VkPerformanceCounterDescriptionFlagBitsKHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR;
/// Backwards-compatible alias containing a typo
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR                    : VkPerformanceCounterDescriptionFlagBitsKHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR;

pub use self::VkAcquireProfilingLockFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAcquireProfilingLockFlagBitsKHR {
	__Default__ = 0,
}

impl Default for VkAcquireProfilingLockFlagBitsKHR {
	fn default() -> Self {
		Self::__Default__
	}
}

pub use self::VkShaderCorePropertiesFlagBitsAMD::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShaderCorePropertiesFlagBitsAMD {
	__Default__ = 0,
}

impl Default for VkShaderCorePropertiesFlagBitsAMD {
	fn default() -> Self {
		Self::__Default__
	}
}

pub use self::VkPerformanceConfigurationTypeINTEL::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceConfigurationTypeINTEL {
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
}

impl Default for VkPerformanceConfigurationTypeINTEL {
	fn default() -> Self {
		Self::VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL
	}
}

pub use self::VkQueryPoolSamplingModeINTEL::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueryPoolSamplingModeINTEL {
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL                                         = 0,
}

impl Default for VkQueryPoolSamplingModeINTEL {
	fn default() -> Self {
		Self::VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL
	}
}

pub use self::VkPerformanceOverrideTypeINTEL::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceOverrideTypeINTEL {
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL                                 = 0,
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL                              = 1,
}

impl Default for VkPerformanceOverrideTypeINTEL {
	fn default() -> Self {
		Self::VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL
	}
}

pub use self::VkPerformanceParameterTypeINTEL::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceParameterTypeINTEL {
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL                        = 0,
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL                     = 1,
}

impl Default for VkPerformanceParameterTypeINTEL {
	fn default() -> Self {
		Self::VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL
	}
}

pub use self::VkPerformanceValueTypeINTEL::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPerformanceValueTypeINTEL {
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL                                           = 0,
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL                                           = 1,
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL                                            = 2,
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL                                             = 3,
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL                                           = 4,
}

impl Default for VkPerformanceValueTypeINTEL {
	fn default() -> Self {
		Self::VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL
	}
}

pub use self::VkShaderFloatControlsIndependence::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShaderFloatControlsIndependence {
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY                                = 0,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL                                        = 1,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE                                       = 2,
}

impl Default for VkShaderFloatControlsIndependence {
	fn default() -> Self {
		Self::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY
	}
}

pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR                           : VkShaderFloatControlsIndependence = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR                                   : VkShaderFloatControlsIndependence = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR                                  : VkShaderFloatControlsIndependence = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE;

pub use self::VkPipelineExecutableStatisticFormatKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineExecutableStatisticFormatKHR {
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR                               = 0,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR                                = 1,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR                               = 2,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR                              = 3,
}

impl Default for VkPipelineExecutableStatisticFormatKHR {
	fn default() -> Self {
		Self::VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR
	}
}

pub use self::VkLineRasterizationModeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkLineRasterizationModeEXT {
	VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT                                           = 0,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT                                       = 1,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT                                         = 2,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT                                = 3,
}

impl Default for VkLineRasterizationModeEXT {
	fn default() -> Self {
		Self::VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT
	}
}

pub use self::VkShaderModuleCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkShaderModuleCreateFlagBits {
	__Default__ = 0,
}

impl Default for VkShaderModuleCreateFlagBits {
	fn default() -> Self {
		Self::__Default__
	}
}

pub use self::VkPipelineCompilerControlFlagBitsAMD::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineCompilerControlFlagBitsAMD {
	__Default__ = 0,
}

impl Default for VkPipelineCompilerControlFlagBitsAMD {
	fn default() -> Self {
		Self::__Default__
	}
}

pub use self::VkToolPurposeFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkToolPurposeFlagBitsEXT {
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT                                               = 0x1,
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT                                                = 0x2,
	VK_TOOL_PURPOSE_TRACING_BIT_EXT                                                  = 0x4,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT                                      = 0x8,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT                                       = 0x10,
	VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT                                          = 0x20,
	VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT                                            = 0x40,
}

impl Default for VkToolPurposeFlagBitsEXT {
	fn default() -> Self {
		Self::VK_TOOL_PURPOSE_VALIDATION_BIT_EXT
	}
}

pub use self::VkFragmentShadingRateCombinerOpKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFragmentShadingRateCombinerOpKHR {
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR                                    = 0,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR                                 = 1,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR                                     = 2,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR                                     = 3,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR                                     = 4,
}

impl Default for VkFragmentShadingRateCombinerOpKHR {
	fn default() -> Self {
		Self::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
	}
}

pub use self::VkFragmentShadingRateNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFragmentShadingRateNV {
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV                               = 0,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV                          = 1,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV                          = 4,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV                          = 5,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV                          = 6,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV                          = 9,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV                          = 10,
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV                              = 11,
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV                              = 12,
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV                              = 13,
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV                             = 14,
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV                                       = 15,
}

impl Default for VkFragmentShadingRateNV {
	fn default() -> Self {
		Self::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV
	}
}

pub use self::VkFragmentShadingRateTypeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkFragmentShadingRateTypeNV {
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV                                   = 0,
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV                                           = 1,
}

impl Default for VkFragmentShadingRateTypeNV {
	fn default() -> Self {
		Self::VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV
	}
}

pub use self::VkAccessFlagBits2KHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccessFlagBits2KHR {
	VK_ACCESS_2_NONE_KHR                                                             = 0,
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR                                        = 0x1,
	VK_ACCESS_2_INDEX_READ_BIT_KHR                                                   = 0x2,
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR                                        = 0x4,
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR                                                 = 0x8,
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR                                        = 0x10,
	VK_ACCESS_2_SHADER_READ_BIT_KHR                                                  = 0x20,
	VK_ACCESS_2_SHADER_WRITE_BIT_KHR                                                 = 0x40,
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR                                        = 0x80,
	VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR                                       = 0x100,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR                                = 0x200,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR                               = 0x400,
	VK_ACCESS_2_TRANSFER_READ_BIT_KHR                                                = 0x800,
	VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR                                               = 0x1000,
	VK_ACCESS_2_HOST_READ_BIT_KHR                                                    = 0x2000,
	VK_ACCESS_2_HOST_WRITE_BIT_KHR                                                   = 0x4000,
	VK_ACCESS_2_MEMORY_READ_BIT_KHR                                                  = 0x8000,
	VK_ACCESS_2_MEMORY_WRITE_BIT_KHR                                                 = 0x10000,
	VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR                                          = 0x100000000,
	VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR                                          = 0x200000000,
	VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR                                         = 0x400000000,
	VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR                                            = 0x800000000,
	VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR                                           = 0x1000000000,
	VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR                                            = 0x2000000000,
	VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR                                           = 0x4000000000,
	VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT                                     = 0x2000000,
	VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT                              = 0x4000000,
	VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT                             = 0x8000000,
	VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT                                   = 0x100000,
	VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV                                       = 0x20000,
	VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV                                      = 0x40000,
	VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR                        = 0x800000,
	VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR                                  = 0x200000,
	VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR                                 = 0x400000,
	VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT                                    = 0x1000000,
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT                            = 0x80000,
}

impl Default for VkAccessFlagBits2KHR {
	fn default() -> Self {
		Self::VK_ACCESS_2_NONE_KHR
	}
}

pub const VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV                                      : VkAccessFlagBits2KHR = VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
pub const VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV                                  : VkAccessFlagBits2KHR = VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR;
pub const VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV                                 : VkAccessFlagBits2KHR = VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;

pub use self::VkPipelineStageFlagBits2KHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineStageFlagBits2KHR {
	VK_PIPELINE_STAGE_2_NONE_KHR                                                     = 0,
	VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR                                          = 0x1,
	VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR                                        = 0x2,
	VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR                                         = 0x4,
	VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR                                        = 0x8,
	VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR                          = 0x10,
	VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR                       = 0x20,
	VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR                                      = 0x40,
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR                                      = 0x80,
	VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR                                 = 0x100,
	VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR                                  = 0x200,
	VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR                              = 0x400,
	VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR                                       = 0x800,
	VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR                                         = 0x1000,
	VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR                                       = 0x2000,
	VK_PIPELINE_STAGE_2_HOST_BIT_KHR                                                 = 0x4000,
	VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR                                         = 0x8000,
	VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR                                         = 0x10000,
	VK_PIPELINE_STAGE_2_COPY_BIT_KHR                                                 = 0x100000000,
	VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR                                              = 0x200000000,
	VK_PIPELINE_STAGE_2_BLIT_BIT_KHR                                                 = 0x400000000,
	VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR                                                = 0x800000000,
	VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR                                          = 0x1000000000,
	VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR                               = 0x2000000000,
	VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR                            = 0x4000000000,
	VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR                                         = 0x4000000,
	VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR                                         = 0x8000000,
	VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT                                   = 0x1000000,
	VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT                                = 0x40000,
	VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV                                    = 0x20000,
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR                     = 0x400000,
	VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR                         = 0x2000000,
	VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR                                   = 0x200000,
	VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT                             = 0x800000,
	VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV                                           = 0x80000,
	VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV                                           = 0x100000,
	VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI                                   = 0x8000000000,
}

impl Default for VkPipelineStageFlagBits2KHR {
	fn default() -> Self {
		Self::VK_PIPELINE_STAGE_2_NONE_KHR
	}
}

pub const VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR                                            : VkPipelineStageFlagBits2KHR = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR;
pub const VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV                                   : VkPipelineStageFlagBits2KHR = VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
pub const VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV                                   : VkPipelineStageFlagBits2KHR = VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
pub const VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV                         : VkPipelineStageFlagBits2KHR = VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;

pub use self::VkSubmitFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkSubmitFlagBitsKHR {
	VK_SUBMIT_PROTECTED_BIT_KHR                                                      = 0x1,
}

impl Default for VkSubmitFlagBitsKHR {
	fn default() -> Self {
		Self::VK_SUBMIT_PROTECTED_BIT_KHR
	}
}

pub use self::VkEventCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkEventCreateFlagBits {
	VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR                                              = 0x1,
}

impl Default for VkEventCreateFlagBits {
	fn default() -> Self {
		Self::VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR
	}
}

pub use self::VkPipelineLayoutCreateFlagBits::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkPipelineLayoutCreateFlagBits {
	__Default__ = 0,
}

impl Default for VkPipelineLayoutCreateFlagBits {
	fn default() -> Self {
		Self::__Default__
	}
}

pub use self::VkProvokingVertexModeEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkProvokingVertexModeEXT {
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT                                        = 0,
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT                                         = 1,
}

impl Default for VkProvokingVertexModeEXT {
	fn default() -> Self {
		Self::VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT
	}
}

pub use self::VkAccelerationStructureMotionInstanceTypeNV::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkAccelerationStructureMotionInstanceTypeNV {
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV                         = 0,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV                  = 1,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV                     = 2,
}

impl Default for VkAccelerationStructureMotionInstanceTypeNV {
	fn default() -> Self {
		Self::VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV
	}
}

pub use self::VkVideoCodecOperationFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoCodecOperationFlagBitsKHR {
	VK_VIDEO_CODEC_OPERATION_INVALID_BIT_KHR                                         = 0,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT                                     = 0x10000,
	VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_EXT                                     = 0x1,
	VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_EXT                                     = 0x2,
}

impl Default for VkVideoCodecOperationFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_CODEC_OPERATION_INVALID_BIT_KHR
	}
}

/// Vulkan video chroma subsampling definitions
pub use self::VkVideoChromaSubsamplingFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoChromaSubsamplingFlagBitsKHR {
	VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR                                      = 0,
	VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR                                   = 0x1,
	VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR                                          = 0x2,
	VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR                                          = 0x4,
	VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR                                          = 0x8,
}

impl Default for VkVideoChromaSubsamplingFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR
	}
}

/// Vulkan video component bit depth definitions
pub use self::VkVideoComponentBitDepthFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoComponentBitDepthFlagBitsKHR {
	VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR                                         = 0,
	VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR                                           = 0x1,
	VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR                                          = 0x4,
	VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR                                          = 0x10,
}

impl Default for VkVideoComponentBitDepthFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR
	}
}

pub use self::VkVideoCapabilitiesFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoCapabilitiesFlagBitsKHR {
	VK_VIDEO_CAPABILITIES_PROTECTED_CONTENT_BIT_KHR                                  = 0x1,
	VK_VIDEO_CAPABILITIES_SEPARATE_REFERENCE_IMAGES_BIT_KHR                          = 0x2,
}

impl Default for VkVideoCapabilitiesFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_CAPABILITIES_PROTECTED_CONTENT_BIT_KHR
	}
}

pub use self::VkVideoSessionCreateFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoSessionCreateFlagBitsKHR {
	VK_VIDEO_SESSION_CREATE_DEFAULT_KHR                                              = 0,
	VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR                                = 0x1,
}

impl Default for VkVideoSessionCreateFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_SESSION_CREATE_DEFAULT_KHR
	}
}

pub use self::VkVideoCodingQualityPresetFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoCodingQualityPresetFlagBitsKHR {
	VK_VIDEO_CODING_QUALITY_PRESET_DEFAULT_BIT_KHR                                   = 0,
	VK_VIDEO_CODING_QUALITY_PRESET_NORMAL_BIT_KHR                                    = 0x1,
	VK_VIDEO_CODING_QUALITY_PRESET_POWER_BIT_KHR                                     = 0x2,
	VK_VIDEO_CODING_QUALITY_PRESET_QUALITY_BIT_KHR                                   = 0x4,
}

impl Default for VkVideoCodingQualityPresetFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_CODING_QUALITY_PRESET_DEFAULT_BIT_KHR
	}
}

pub use self::VkVideoDecodeH264FieldLayoutFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoDecodeH264FieldLayoutFlagBitsEXT {
	VK_VIDEO_DECODE_H264_PROGRESSIVE_PICTURES_ONLY_EXT                               = 0,
	VK_VIDEO_DECODE_H264_FIELD_LAYOUT_LINE_INTERLACED_PLANE_BIT_EXT                  = 0x1,
	VK_VIDEO_DECODE_H264_FIELD_LAYOUT_SEPARATE_INTERLACED_PLANE_BIT_EXT              = 0x2,
}

impl Default for VkVideoDecodeH264FieldLayoutFlagBitsEXT {
	fn default() -> Self {
		Self::VK_VIDEO_DECODE_H264_PROGRESSIVE_PICTURES_ONLY_EXT
	}
}

pub use self::VkVideoCodingControlFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoCodingControlFlagBitsKHR {
	VK_VIDEO_CODING_CONTROL_DEFAULT_KHR                                              = 0,
	VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR                                            = 0x1,
}

impl Default for VkVideoCodingControlFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_CODING_CONTROL_DEFAULT_KHR
	}
}

pub use self::VkQueryResultStatusKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkQueryResultStatusKHR {
	VK_QUERY_RESULT_STATUS_ERROR_KHR                                                 = -1,
	VK_QUERY_RESULT_STATUS_NOT_READY_KHR                                             = 0,
	VK_QUERY_RESULT_STATUS_COMPLETE_KHR                                              = 1,
}

impl Default for VkQueryResultStatusKHR {
	fn default() -> Self {
		Self::VK_QUERY_RESULT_STATUS_ERROR_KHR
	}
}

pub use self::VkVideoDecodeFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoDecodeFlagBitsKHR {
	VK_VIDEO_DECODE_DEFAULT_KHR                                                      = 0,
	VK_VIDEO_DECODE_RESERVED_0_BIT_KHR                                               = 0x1,
}

impl Default for VkVideoDecodeFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_DECODE_DEFAULT_KHR
	}
}

pub use self::VkVideoEncodeFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeFlagBitsKHR {
	VK_VIDEO_ENCODE_DEFAULT_KHR                                                      = 0,
	VK_VIDEO_ENCODE_RESERVED_0_BIT_KHR                                               = 0x1,
}

impl Default for VkVideoEncodeFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_DEFAULT_KHR
	}
}

pub use self::VkVideoEncodeRateControlFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeRateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR                                         = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_RESET_BIT_KHR                                       = 0x1,
}

impl Default for VkVideoEncodeRateControlFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR
	}
}

pub use self::VkVideoEncodeRateControlModeFlagBitsKHR::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeRateControlModeFlagBitsKHR {
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR                                   = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR                                    = 1,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR                                    = 2,
}

impl Default for VkVideoEncodeRateControlModeFlagBitsKHR {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR
	}
}

pub use self::VkVideoEncodeH264CapabilitiesFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeH264CapabilitiesFlagBitsEXT {
	VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT                                    = 0x1,
	VK_VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT                                    = 0x2,
	VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BI_PRED_IMPLICIT_BIT_EXT                = 0x4,
	VK_VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT                            = 0x8,
	VK_VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT                         = 0x10,
	VK_VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT                  = 0x20,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT               = 0x40,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT                = 0x80,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT                = 0x100,
	VK_VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT                 = 0x200,
	VK_VIDEO_ENCODE_H264_CAPABILITY_EVENLY_DISTRIBUTED_SLICE_SIZE_BIT_EXT            = 0x400,
}

impl Default for VkVideoEncodeH264CapabilitiesFlagBitsEXT {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT
	}
}

pub use self::VkVideoEncodeH264InputModeFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeH264InputModeFlagBitsEXT {
	VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT                                    = 0x1,
	VK_VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT                                    = 0x2,
	VK_VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT                                  = 0x4,
}

impl Default for VkVideoEncodeH264InputModeFlagBitsEXT {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT
	}
}

pub use self::VkVideoEncodeH264OutputModeFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeH264OutputModeFlagBitsEXT {
	VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT                                   = 0x1,
	VK_VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT                                   = 0x2,
	VK_VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT                                 = 0x4,
}

impl Default for VkVideoEncodeH264OutputModeFlagBitsEXT {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT
	}
}

pub use self::VkVideoEncodeH264CreateFlagBitsEXT::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VkVideoEncodeH264CreateFlagBitsEXT {
	VK_VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT                                          = 0,
	VK_VIDEO_ENCODE_H264_CREATE_RESERVED_0_BIT_EXT                                   = 0x1,
}

impl Default for VkVideoEncodeH264CreateFlagBitsEXT {
	fn default() -> Self {
		Self::VK_VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT
	}
}
// Vulkan command definitions


pub const VK_KHR_SURFACE_SPEC_VERSION                       : i32 = 25;
pub const VK_KHR_SURFACE_EXTENSION_NAME                     : *const u8 = b"VK_KHR_surface\0".as_ptr();
pub const VK_KHR_SWAPCHAIN_SPEC_VERSION                     : i32 = 70;
pub const VK_KHR_SWAPCHAIN_EXTENSION_NAME                   : *const u8 = b"VK_KHR_swapchain\0".as_ptr();
pub const VK_KHR_DISPLAY_SPEC_VERSION                       : i32 = 23;
pub const VK_KHR_DISPLAY_EXTENSION_NAME                     : *const u8 = b"VK_KHR_display\0".as_ptr();
pub const VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION             : i32 = 10;
pub const VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME           : *const u8 = b"VK_KHR_display_swapchain\0".as_ptr();
pub const VK_KHR_XLIB_SURFACE_SPEC_VERSION                  : i32 = 6;
pub const VK_KHR_XLIB_SURFACE_EXTENSION_NAME                : *const u8 = b"VK_KHR_xlib_surface\0".as_ptr();
pub const VK_KHR_XCB_SURFACE_SPEC_VERSION                   : i32 = 6;
pub const VK_KHR_XCB_SURFACE_EXTENSION_NAME                 : *const u8 = b"VK_KHR_xcb_surface\0".as_ptr();
pub const VK_KHR_WAYLAND_SURFACE_SPEC_VERSION               : i32 = 6;
pub const VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME             : *const u8 = b"VK_KHR_wayland_surface\0".as_ptr();
pub const VK_KHR_ANDROID_SURFACE_SPEC_VERSION               : i32 = 6;
pub const VK_KHR_ANDROID_SURFACE_EXTENSION_NAME             : *const u8 = b"VK_KHR_android_surface\0".as_ptr();
pub const VK_KHR_WIN32_SURFACE_SPEC_VERSION                 : i32 = 6;
pub const VK_KHR_WIN32_SURFACE_EXTENSION_NAME               : *const u8 = b"VK_KHR_win32_surface\0".as_ptr();
pub const VK_EXT_DEBUG_REPORT_SPEC_VERSION                  : i32 = 10;
pub const VK_EXT_DEBUG_REPORT_EXTENSION_NAME                : *const u8 = b"VK_EXT_debug_report\0".as_ptr();
pub const VK_NV_GLSL_SHADER_SPEC_VERSION                    : i32 = 1;
pub const VK_NV_GLSL_SHADER_EXTENSION_NAME                  : *const u8 = b"VK_NV_glsl_shader\0".as_ptr();
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION      : i32 = 1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME    : *const u8 = b"VK_EXT_depth_range_unrestricted\0".as_ptr();
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION  : i32 = 3;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME: *const u8 = b"VK_KHR_sampler_mirror_clamp_to_edge\0".as_ptr();
pub const VK_IMG_FILTER_CUBIC_SPEC_VERSION                  : i32 = 1;
pub const VK_IMG_FILTER_CUBIC_EXTENSION_NAME                : *const u8 = b"VK_IMG_filter_cubic\0".as_ptr();
pub const VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION           : i32 = 1;
pub const VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME         : *const u8 = b"VK_AMD_rasterization_order\0".as_ptr();
pub const VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION         : i32 = 1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME       : *const u8 = b"VK_AMD_shader_trinary_minmax\0".as_ptr();
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION: i32 = 1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME: *const u8 = b"VK_AMD_shader_explicit_vertex_parameter\0".as_ptr();
pub const VK_EXT_DEBUG_MARKER_SPEC_VERSION                  : i32 = 4;
pub const VK_EXT_DEBUG_MARKER_EXTENSION_NAME                : *const u8 = b"VK_EXT_debug_marker\0".as_ptr();
pub const VK_KHR_VIDEO_QUEUE_SPEC_VERSION                   : i32 = 1;
pub const VK_KHR_VIDEO_QUEUE_EXTENSION_NAME                 : *const u8 = b"VK_KHR_video_queue\0".as_ptr();
pub const VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION            : i32 = 1;
pub const VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME          : *const u8 = b"VK_KHR_video_decode_queue\0".as_ptr();
pub const VK_AMD_GCN_SHADER_SPEC_VERSION                    : i32 = 1;
pub const VK_AMD_GCN_SHADER_EXTENSION_NAME                  : *const u8 = b"VK_AMD_gcn_shader\0".as_ptr();
pub const VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION           : i32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME         : *const u8 = b"VK_NV_dedicated_allocation\0".as_ptr();
pub const VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION            : i32 = 1;
pub const VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME          : *const u8 = b"VK_EXT_transform_feedback\0".as_ptr();
pub const VK_NVX_BINARY_IMPORT_SPEC_VERSION                 : i32 = 1;
pub const VK_NVX_BINARY_IMPORT_EXTENSION_NAME               : *const u8 = b"VK_NVX_binary_import\0".as_ptr();
pub const VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION             : i32 = 2;
pub const VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME           : *const u8 = b"VK_NVX_image_view_handle\0".as_ptr();
pub const VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION           : i32 = 2;
pub const VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME         : *const u8 = b"VK_AMD_draw_indirect_count\0".as_ptr();
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION      : i32 = 1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME    : *const u8 = b"VK_AMD_negative_viewport_height\0".as_ptr();
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION         : i32 = 2;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME       : *const u8 = b"VK_AMD_gpu_shader_half_float\0".as_ptr();
pub const VK_AMD_SHADER_BALLOT_SPEC_VERSION                 : i32 = 1;
pub const VK_AMD_SHADER_BALLOT_EXTENSION_NAME               : *const u8 = b"VK_AMD_shader_ballot\0".as_ptr();
pub const VK_EXT_VIDEO_ENCODE_H264_SPEC_VERSION             : i32 = 1;
pub const VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME           : *const u8 = b"VK_EXT_video_encode_h264\0".as_ptr();
pub const VK_EXT_VIDEO_DECODE_H264_SPEC_VERSION             : i32 = 1;
pub const VK_EXT_VIDEO_DECODE_H264_EXTENSION_NAME           : *const u8 = b"VK_EXT_video_decode_h264\0".as_ptr();
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION       : i32 = 1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME     : *const u8 = b"VK_AMD_texture_gather_bias_lod\0".as_ptr();
pub const VK_AMD_SHADER_INFO_SPEC_VERSION                   : i32 = 1;
pub const VK_AMD_SHADER_INFO_EXTENSION_NAME                 : *const u8 = b"VK_AMD_shader_info\0".as_ptr();
pub const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION   : i32 = 1;
pub const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME : *const u8 = b"VK_AMD_shader_image_load_store_lod\0".as_ptr();
pub const VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION     : i32 = 1;
pub const VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME   : *const u8 = b"VK_GGP_stream_descriptor_surface\0".as_ptr();
pub const VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION           : i32 = 2;
pub const VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME         : *const u8 = b"VK_NV_corner_sampled_image\0".as_ptr();
pub const VK_KHR_MULTIVIEW_SPEC_VERSION                     : i32 = 1;
pub const VK_KHR_MULTIVIEW_EXTENSION_NAME                   : *const u8 = b"VK_KHR_multiview\0".as_ptr();
pub const VK_IMG_FORMAT_PVRTC_SPEC_VERSION                  : i32 = 1;
pub const VK_IMG_FORMAT_PVRTC_EXTENSION_NAME                : *const u8 = b"VK_IMG_format_pvrtc\0".as_ptr();
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION   : i32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME : *const u8 = b"VK_NV_external_memory_capabilities\0".as_ptr();
pub const VK_NV_EXTERNAL_MEMORY_SPEC_VERSION                : i32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME              : *const u8 = b"VK_NV_external_memory\0".as_ptr();
pub const VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION          : i32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME        : *const u8 = b"VK_NV_external_memory_win32\0".as_ptr();
pub const VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION              : i32 = 2;
pub const VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME            : *const u8 = b"VK_NV_win32_keyed_mutex\0".as_ptr();
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION: i32 = 2;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME: *const u8 = b"VK_KHR_get_physical_device_properties2\0".as_ptr();
pub const VK_KHR_DEVICE_GROUP_SPEC_VERSION                  : i32 = 4;
pub const VK_KHR_DEVICE_GROUP_EXTENSION_NAME                : *const u8 = b"VK_KHR_device_group\0".as_ptr();
pub const VK_EXT_VALIDATION_FLAGS_SPEC_VERSION              : i32 = 2;
pub const VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME            : *const u8 = b"VK_EXT_validation_flags\0".as_ptr();
pub const VK_NN_VI_SURFACE_SPEC_VERSION                     : i32 = 1;
pub const VK_NN_VI_SURFACE_EXTENSION_NAME                   : *const u8 = b"VK_NN_vi_surface\0".as_ptr();
pub const VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION        : i32 = 1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME      : *const u8 = b"VK_KHR_shader_draw_parameters\0".as_ptr();
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION        : i32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME      : *const u8 = b"VK_EXT_shader_subgroup_ballot\0".as_ptr();
pub const VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION          : i32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME        : *const u8 = b"VK_EXT_shader_subgroup_vote\0".as_ptr();
pub const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION  : i32 = 1;
pub const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME: *const u8 = b"VK_EXT_texture_compression_astc_hdr\0".as_ptr();
pub const VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME            : *const u8 = b"VK_EXT_astc_decode_mode\0".as_ptr();
pub const VK_KHR_MAINTENANCE1_SPEC_VERSION                  : i32 = 2;
pub const VK_KHR_MAINTENANCE1_EXTENSION_NAME                : *const u8 = b"VK_KHR_maintenance1\0".as_ptr();
pub const VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME       : *const u8 = b"VK_KHR_device_group_creation\0".as_ptr();
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION  : i32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: *const u8 = b"VK_KHR_external_memory_capabilities\0".as_ptr();
pub const VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION               : i32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME             : *const u8 = b"VK_KHR_external_memory\0".as_ptr();
pub const VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME       : *const u8 = b"VK_KHR_external_memory_win32\0".as_ptr();
pub const VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION            : i32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME          : *const u8 = b"VK_KHR_external_memory_fd\0".as_ptr();
pub const VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME           : *const u8 = b"VK_KHR_win32_keyed_mutex\0".as_ptr();
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION: i32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME: *const u8 = b"VK_KHR_external_semaphore_capabilities\0".as_ptr();
pub const VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION            : i32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME          : *const u8 = b"VK_KHR_external_semaphore\0".as_ptr();
pub const VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION      : i32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME    : *const u8 = b"VK_KHR_external_semaphore_win32\0".as_ptr();
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME       : *const u8 = b"VK_KHR_external_semaphore_fd\0".as_ptr();
pub const VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION               : i32 = 2;
pub const VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME             : *const u8 = b"VK_KHR_push_descriptor\0".as_ptr();
pub const VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION         : i32 = 2;
pub const VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME       : *const u8 = b"VK_EXT_conditional_rendering\0".as_ptr();
pub const VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION           : i32 = 1;
pub const VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME         : *const u8 = b"VK_KHR_shader_float16_int8\0".as_ptr();
pub const VK_KHR_16BIT_STORAGE_SPEC_VERSION                 : i32 = 1;
pub const VK_KHR_16BIT_STORAGE_EXTENSION_NAME               : *const u8 = b"VK_KHR_16bit_storage\0".as_ptr();
pub const VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION           : i32 = 2;
pub const VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME         : *const u8 = b"VK_KHR_incremental_present\0".as_ptr();
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION    : i32 = 1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME  : *const u8 = b"VK_KHR_descriptor_update_template\0".as_ptr();
pub const VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION           : i32 = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME         : *const u8 = b"VK_NV_clip_space_w_scaling\0".as_ptr();
pub const VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION           : i32 = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME         : *const u8 = b"VK_EXT_direct_mode_display\0".as_ptr();
pub const VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION          : i32 = 1;
pub const VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME        : *const u8 = b"VK_EXT_acquire_xlib_display\0".as_ptr();
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION       : i32 = 1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME     : *const u8 = b"VK_EXT_display_surface_counter\0".as_ptr();
pub const VK_EXT_DISPLAY_CONTROL_SPEC_VERSION               : i32 = 1;
pub const VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME             : *const u8 = b"VK_EXT_display_control\0".as_ptr();
pub const VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION             : i32 = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME           : *const u8 = b"VK_GOOGLE_display_timing\0".as_ptr();
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION  : i32 = 1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME: *const u8 = b"VK_NV_sample_mask_override_coverage\0".as_ptr();
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION    : i32 = 1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME  : *const u8 = b"VK_NV_geometry_shader_passthrough\0".as_ptr();
pub const VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION                : i32 = 1;
pub const VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME              : *const u8 = b"VK_NV_viewport_array2\0".as_ptr();
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION : i32 = 1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME: *const u8 = b"VK_NVX_multiview_per_view_attributes\0".as_ptr();
pub const VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION               : i32 = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME             : *const u8 = b"VK_NV_viewport_swizzle\0".as_ptr();
pub const VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION            : i32 = 1;
pub const VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME          : *const u8 = b"VK_EXT_discard_rectangles\0".as_ptr();
pub const VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION    : i32 = 1;
pub const VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME  : *const u8 = b"VK_EXT_conservative_rasterization\0".as_ptr();
pub const VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION             : i32 = 1;
pub const VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME           : *const u8 = b"VK_EXT_depth_clip_enable\0".as_ptr();
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION         : i32 = 4;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME       : *const u8 = b"VK_EXT_swapchain_colorspace\0".as_ptr();
pub const VK_EXT_HDR_METADATA_SPEC_VERSION                  : i32 = 2;
pub const VK_EXT_HDR_METADATA_EXTENSION_NAME                : *const u8 = b"VK_EXT_hdr_metadata\0".as_ptr();
pub const VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME       : *const u8 = b"VK_KHR_imageless_framebuffer\0".as_ptr();
pub const VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION           : i32 = 1;
pub const VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME         : *const u8 = b"VK_KHR_create_renderpass2\0".as_ptr();
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION      : i32 = 1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME    : *const u8 = b"VK_KHR_shared_presentable_image\0".as_ptr();
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION   : i32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME : *const u8 = b"VK_KHR_external_fence_capabilities\0".as_ptr();
pub const VK_KHR_EXTERNAL_FENCE_SPEC_VERSION                : i32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME              : *const u8 = b"VK_KHR_external_fence\0".as_ptr();
pub const VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION          : i32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME        : *const u8 = b"VK_KHR_external_fence_win32\0".as_ptr();
pub const VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME           : *const u8 = b"VK_KHR_external_fence_fd\0".as_ptr();
pub const VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME           : *const u8 = b"VK_KHR_performance_query\0".as_ptr();
pub const VK_KHR_MAINTENANCE2_SPEC_VERSION                  : i32 = 1;
pub const VK_KHR_MAINTENANCE2_EXTENSION_NAME                : *const u8 = b"VK_KHR_maintenance2\0".as_ptr();
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION    : i32 = 1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME  : *const u8 = b"VK_KHR_get_surface_capabilities2\0".as_ptr();
pub const VK_KHR_VARIABLE_POINTERS_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME           : *const u8 = b"VK_KHR_variable_pointers\0".as_ptr();
pub const VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION      : i32 = 1;
pub const VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME    : *const u8 = b"VK_KHR_get_display_properties2\0".as_ptr();
pub const VK_MVK_IOS_SURFACE_SPEC_VERSION                   : i32 = 3;
pub const VK_MVK_IOS_SURFACE_EXTENSION_NAME                 : *const u8 = b"VK_MVK_ios_surface\0".as_ptr();
pub const VK_MVK_MACOS_SURFACE_SPEC_VERSION                 : i32 = 3;
pub const VK_MVK_MACOS_SURFACE_EXTENSION_NAME               : *const u8 = b"VK_MVK_macos_surface\0".as_ptr();
pub const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION       : i32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME     : *const u8 = b"VK_EXT_external_memory_dma_buf\0".as_ptr();
pub const VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION          : i32 = 1;
pub const VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME        : *const u8 = b"VK_EXT_queue_family_foreign\0".as_ptr();
pub const VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION          : i32 = 3;
pub const VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME        : *const u8 = b"VK_KHR_dedicated_allocation\0".as_ptr();
pub const VK_EXT_DEBUG_UTILS_SPEC_VERSION                   : i32 = 2;
pub const VK_EXT_DEBUG_UTILS_EXTENSION_NAME                 : *const u8 = b"VK_EXT_debug_utils\0".as_ptr();
pub const VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION: i32 = 3;
pub const VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME: *const u8 = b"VK_ANDROID_external_memory_android_hardware_buffer\0".as_ptr();
pub const VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION         : i32 = 2;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME       : *const u8 = b"VK_EXT_sampler_filter_minmax\0".as_ptr();
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION  : i32 = 1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME: *const u8 = b"VK_KHR_storage_buffer_storage_class\0".as_ptr();
pub const VK_AMD_GPU_SHADER_INT16_SPEC_VERSION              : i32 = 2;
pub const VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME            : *const u8 = b"VK_AMD_gpu_shader_int16\0".as_ptr();
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION      : i32 = 1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME    : *const u8 = b"VK_AMD_mixed_attachment_samples\0".as_ptr();
pub const VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION          : i32 = 1;
pub const VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME        : *const u8 = b"VK_AMD_shader_fragment_mask\0".as_ptr();
pub const VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION          : i32 = 1;
pub const VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME        : *const u8 = b"VK_EXT_inline_uniform_block\0".as_ptr();
pub const VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION         : i32 = 1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME       : *const u8 = b"VK_EXT_shader_stencil_export\0".as_ptr();
pub const VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME            : *const u8 = b"VK_EXT_sample_locations\0".as_ptr();
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION          : i32 = 1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME        : *const u8 = b"VK_KHR_relaxed_block_layout\0".as_ptr();
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION     : i32 = 1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME   : *const u8 = b"VK_KHR_get_memory_requirements2\0".as_ptr();
pub const VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME           : *const u8 = b"VK_KHR_image_format_list\0".as_ptr();
pub const VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION      : i32 = 2;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME    : *const u8 = b"VK_EXT_blend_operation_advanced\0".as_ptr();
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION     : i32 = 1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME   : *const u8 = b"VK_NV_fragment_coverage_to_color\0".as_ptr();
pub const VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION        : i32 = 11;
pub const VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME      : *const u8 = b"VK_KHR_acceleration_structure\0".as_ptr();
pub const VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION          : i32 = 1;
pub const VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME        : *const u8 = b"VK_KHR_ray_tracing_pipeline\0".as_ptr();
pub const VK_KHR_RAY_QUERY_SPEC_VERSION                     : i32 = 1;
pub const VK_KHR_RAY_QUERY_EXTENSION_NAME                   : *const u8 = b"VK_KHR_ray_query\0".as_ptr();
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION      : i32 = 1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME    : *const u8 = b"VK_NV_framebuffer_mixed_samples\0".as_ptr();
pub const VK_NV_FILL_RECTANGLE_SPEC_VERSION                 : i32 = 1;
pub const VK_NV_FILL_RECTANGLE_EXTENSION_NAME               : *const u8 = b"VK_NV_fill_rectangle\0".as_ptr();
pub const VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION             : i32 = 1;
pub const VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME           : *const u8 = b"VK_NV_shader_sm_builtins\0".as_ptr();
pub const VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION           : i32 = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME         : *const u8 = b"VK_EXT_post_depth_coverage\0".as_ptr();
pub const VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION      : i32 = 14;
pub const VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME    : *const u8 = b"VK_KHR_sampler_ycbcr_conversion\0".as_ptr();
pub const VK_KHR_BIND_MEMORY_2_SPEC_VERSION                 : i32 = 1;
pub const VK_KHR_BIND_MEMORY_2_EXTENSION_NAME               : *const u8 = b"VK_KHR_bind_memory2\0".as_ptr();
pub const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION     : i32 = 1;
pub const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME   : *const u8 = b"VK_EXT_image_drm_format_modifier\0".as_ptr();
pub const VK_EXT_VALIDATION_CACHE_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_VALIDATION_CACHE_EXTENSION_NAME            : *const u8 = b"VK_EXT_validation_cache\0".as_ptr();
pub const VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION           : i32 = 2;
pub const VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME         : *const u8 = b"VK_EXT_descriptor_indexing\0".as_ptr();
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION   : i32 = 1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME : *const u8 = b"VK_EXT_shader_viewport_index_layer\0".as_ptr();
pub const VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION            : i32 = 1;
pub const VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME          : *const u8 = b"VK_KHR_portability_subset\0".as_ptr();
pub const VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION             : i32 = 3;
pub const VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME           : *const u8 = b"VK_NV_shading_rate_image\0".as_ptr();
pub const VK_NV_RAY_TRACING_SPEC_VERSION                    : i32 = 3;
pub const VK_NV_RAY_TRACING_EXTENSION_NAME                  : *const u8 = b"VK_NV_ray_tracing\0".as_ptr();
pub const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION   : i32 = 2;
pub const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME : *const u8 = b"VK_NV_representative_fragment_test\0".as_ptr();
pub const VK_KHR_MAINTENANCE3_SPEC_VERSION                  : i32 = 1;
pub const VK_KHR_MAINTENANCE3_EXTENSION_NAME                : *const u8 = b"VK_KHR_maintenance3\0".as_ptr();
pub const VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION           : i32 = 1;
pub const VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME         : *const u8 = b"VK_KHR_draw_indirect_count\0".as_ptr();
pub const VK_EXT_FILTER_CUBIC_SPEC_VERSION                  : i32 = 3;
pub const VK_EXT_FILTER_CUBIC_EXTENSION_NAME                : *const u8 = b"VK_EXT_filter_cubic\0".as_ptr();
pub const VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION   : i32 = 4;
pub const VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME : *const u8 = b"VK_QCOM_render_pass_shader_resolve\0".as_ptr();
pub const VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION               : i32 = 2;
pub const VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME             : *const u8 = b"VK_EXT_global_priority\0".as_ptr();
pub const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION: i32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME: *const u8 = b"VK_KHR_shader_subgroup_extended_types\0".as_ptr();
pub const VK_KHR_8BIT_STORAGE_SPEC_VERSION                  : i32 = 1;
pub const VK_KHR_8BIT_STORAGE_EXTENSION_NAME                : *const u8 = b"VK_KHR_8bit_storage\0".as_ptr();
pub const VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION          : i32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME        : *const u8 = b"VK_EXT_external_memory_host\0".as_ptr();
pub const VK_AMD_BUFFER_MARKER_SPEC_VERSION                 : i32 = 1;
pub const VK_AMD_BUFFER_MARKER_EXTENSION_NAME               : *const u8 = b"VK_AMD_buffer_marker\0".as_ptr();
pub const VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION           : i32 = 1;
pub const VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME         : *const u8 = b"VK_KHR_shader_atomic_int64\0".as_ptr();
pub const VK_KHR_SHADER_CLOCK_SPEC_VERSION                  : i32 = 1;
pub const VK_KHR_SHADER_CLOCK_EXTENSION_NAME                : *const u8 = b"VK_KHR_shader_clock\0".as_ptr();
pub const VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION     : i32 = 1;
pub const VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME   : *const u8 = b"VK_AMD_pipeline_compiler_control\0".as_ptr();
pub const VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION         : i32 = 2;
pub const VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME       : *const u8 = b"VK_EXT_calibrated_timestamps\0".as_ptr();
pub const VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION        : i32 = 2;
pub const VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME      : *const u8 = b"VK_AMD_shader_core_properties\0".as_ptr();
pub const VK_EXT_VIDEO_DECODE_H265_SPEC_VERSION             : i32 = 1;
pub const VK_EXT_VIDEO_DECODE_H265_EXTENSION_NAME           : *const u8 = b"VK_EXT_video_decode_h265\0".as_ptr();
pub const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION: i32 = 1;
pub const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME: *const u8 = b"VK_AMD_memory_overallocation_behavior\0".as_ptr();
pub const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION      : i32 = 3;
pub const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME    : *const u8 = b"VK_EXT_vertex_attribute_divisor\0".as_ptr();
pub const VK_GGP_FRAME_TOKEN_SPEC_VERSION                   : i32 = 1;
pub const VK_GGP_FRAME_TOKEN_EXTENSION_NAME                 : *const u8 = b"VK_GGP_frame_token\0".as_ptr();
pub const VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION    : i32 = 1;
pub const VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME  : *const u8 = b"VK_EXT_pipeline_creation_feedback\0".as_ptr();
pub const VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME           : *const u8 = b"VK_KHR_driver_properties\0".as_ptr();
pub const VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION         : i32 = 4;
pub const VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME       : *const u8 = b"VK_KHR_shader_float_controls\0".as_ptr();
pub const VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION    : i32 = 1;
pub const VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME  : *const u8 = b"VK_NV_shader_subgroup_partitioned\0".as_ptr();
pub const VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME       : *const u8 = b"VK_KHR_depth_stencil_resolve\0".as_ptr();
pub const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION      : i32 = 1;
pub const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME    : *const u8 = b"VK_KHR_swapchain_mutable_format\0".as_ptr();
pub const VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION     : i32 = 1;
pub const VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME   : *const u8 = b"VK_NV_compute_shader_derivatives\0".as_ptr();
pub const VK_NV_MESH_SHADER_SPEC_VERSION                    : i32 = 1;
pub const VK_NV_MESH_SHADER_EXTENSION_NAME                  : *const u8 = b"VK_NV_mesh_shader\0".as_ptr();
pub const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION    : i32 = 1;
pub const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME  : *const u8 = b"VK_NV_fragment_shader_barycentric\0".as_ptr();
pub const VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION         : i32 = 2;
pub const VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME       : *const u8 = b"VK_NV_shader_image_footprint\0".as_ptr();
pub const VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION              : i32 = 1;
pub const VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME            : *const u8 = b"VK_NV_scissor_exclusive\0".as_ptr();
pub const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION  : i32 = 2;
pub const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME: *const u8 = b"VK_NV_device_diagnostic_checkpoints\0".as_ptr();
pub const VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION            : i32 = 2;
pub const VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME          : *const u8 = b"VK_KHR_timeline_semaphore\0".as_ptr();
pub const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION  : i32 = 1;
pub const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME: *const u8 = b"VK_INTEL_shader_integer_functions2\0".as_ptr();
pub const VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION           : i32 = 2;
pub const VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME         : *const u8 = b"VK_INTEL_performance_query\0".as_ptr();
pub const VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION           : i32 = 3;
pub const VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME         : *const u8 = b"VK_KHR_vulkan_memory_model\0".as_ptr();
pub const VK_EXT_PCI_BUS_INFO_SPEC_VERSION                  : i32 = 2;
pub const VK_EXT_PCI_BUS_INFO_EXTENSION_NAME                : *const u8 = b"VK_EXT_pci_bus_info\0".as_ptr();
pub const VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION            : i32 = 1;
pub const VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME          : *const u8 = b"VK_AMD_display_native_hdr\0".as_ptr();
pub const VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION         : i32 = 1;
pub const VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME       : *const u8 = b"VK_FUCHSIA_imagepipe_surface\0".as_ptr();
pub const VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION   : i32 = 1;
pub const VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME : *const u8 = b"VK_KHR_shader_terminate_invocation\0".as_ptr();
pub const VK_EXT_METAL_SURFACE_SPEC_VERSION                 : i32 = 1;
pub const VK_EXT_METAL_SURFACE_EXTENSION_NAME               : *const u8 = b"VK_EXT_metal_surface\0".as_ptr();
pub const VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION          : i32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME        : *const u8 = b"VK_EXT_fragment_density_map\0".as_ptr();
pub const VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION           : i32 = 1;
pub const VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME         : *const u8 = b"VK_EXT_scalar_block_layout\0".as_ptr();
pub const VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION        : i32 = 1;
pub const VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME      : *const u8 = b"VK_GOOGLE_hlsl_functionality1\0".as_ptr();
pub const VK_GOOGLE_DECORATE_STRING_SPEC_VERSION            : i32 = 1;
pub const VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME          : *const u8 = b"VK_GOOGLE_decorate_string\0".as_ptr();
pub const VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION         : i32 = 2;
pub const VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME       : *const u8 = b"VK_EXT_subgroup_size_control\0".as_ptr();
pub const VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME       : *const u8 = b"VK_KHR_fragment_shading_rate\0".as_ptr();
pub const VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION      : i32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME    : *const u8 = b"VK_AMD_shader_core_properties2\0".as_ptr();
pub const VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION        : i32 = 1;
pub const VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME      : *const u8 = b"VK_AMD_device_coherent_memory\0".as_ptr();
pub const VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION     : i32 = 1;
pub const VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME   : *const u8 = b"VK_EXT_shader_image_atomic_int64\0".as_ptr();
pub const VK_KHR_SPIRV_1_4_SPEC_VERSION                     : i32 = 1;
pub const VK_KHR_SPIRV_1_4_EXTENSION_NAME                   : *const u8 = b"VK_KHR_spirv_1_4\0".as_ptr();
pub const VK_EXT_MEMORY_BUDGET_SPEC_VERSION                 : i32 = 1;
pub const VK_EXT_MEMORY_BUDGET_EXTENSION_NAME               : *const u8 = b"VK_EXT_memory_budget\0".as_ptr();
pub const VK_EXT_MEMORY_PRIORITY_SPEC_VERSION               : i32 = 1;
pub const VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME             : *const u8 = b"VK_EXT_memory_priority\0".as_ptr();
pub const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION: i32 = 1;
pub const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME: *const u8 = b"VK_KHR_surface_protected_capabilities\0".as_ptr();
pub const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION: i32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME: *const u8 = b"VK_NV_dedicated_allocation_image_aliasing\0".as_ptr();
pub const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION: i32 = 1;
pub const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME: *const u8 = b"VK_KHR_separate_depth_stencil_layouts\0".as_ptr();
pub const VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION         : i32 = 2;
pub const VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME       : *const u8 = b"VK_EXT_buffer_device_address\0".as_ptr();
pub const VK_EXT_TOOLING_INFO_SPEC_VERSION                  : i32 = 1;
pub const VK_EXT_TOOLING_INFO_EXTENSION_NAME                : *const u8 = b"VK_EXT_tooling_info\0".as_ptr();
pub const VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION        : i32 = 1;
pub const VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME      : *const u8 = b"VK_EXT_separate_stencil_usage\0".as_ptr();
pub const VK_EXT_VALIDATION_FEATURES_SPEC_VERSION           : i32 = 5;
pub const VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME         : *const u8 = b"VK_EXT_validation_features\0".as_ptr();
pub const VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION             : i32 = 1;
pub const VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME           : *const u8 = b"VK_NV_cooperative_matrix\0".as_ptr();
pub const VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION        : i32 = 1;
pub const VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME      : *const u8 = b"VK_NV_coverage_reduction_mode\0".as_ptr();
pub const VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION     : i32 = 1;
pub const VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME   : *const u8 = b"VK_EXT_fragment_shader_interlock\0".as_ptr();
pub const VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION            : i32 = 1;
pub const VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME          : *const u8 = b"VK_EXT_ycbcr_image_arrays\0".as_ptr();
pub const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION: i32 = 1;
pub const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME: *const u8 = b"VK_KHR_uniform_buffer_standard_layout\0".as_ptr();
pub const VK_EXT_PROVOKING_VERTEX_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME            : *const u8 = b"VK_EXT_provoking_vertex\0".as_ptr();
pub const VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION         : i32 = 4;
pub const VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME       : *const u8 = b"VK_EXT_full_screen_exclusive\0".as_ptr();
pub const VK_EXT_HEADLESS_SURFACE_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME            : *const u8 = b"VK_EXT_headless_surface\0".as_ptr();
pub const VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION         : i32 = 1;
pub const VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME       : *const u8 = b"VK_KHR_buffer_device_address\0".as_ptr();
pub const VK_EXT_LINE_RASTERIZATION_SPEC_VERSION            : i32 = 1;
pub const VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME          : *const u8 = b"VK_EXT_line_rasterization\0".as_ptr();
pub const VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION           : i32 = 1;
pub const VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME         : *const u8 = b"VK_EXT_shader_atomic_float\0".as_ptr();
pub const VK_EXT_HOST_QUERY_RESET_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME            : *const u8 = b"VK_EXT_host_query_reset\0".as_ptr();
pub const VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME            : *const u8 = b"VK_EXT_index_type_uint8\0".as_ptr();
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION        : i32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME      : *const u8 = b"VK_EXT_extended_dynamic_state\0".as_ptr();
pub const VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION      : i32 = 4;
pub const VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME    : *const u8 = b"VK_KHR_deferred_host_operations\0".as_ptr();
pub const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION: i32 = 1;
pub const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME: *const u8 = b"VK_KHR_pipeline_executable_properties\0".as_ptr();
pub const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION: i32 = 1;
pub const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME: *const u8 = b"VK_EXT_shader_demote_to_helper_invocation\0".as_ptr();
pub const VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION      : i32 = 3;
pub const VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME    : *const u8 = b"VK_NV_device_generated_commands\0".as_ptr();
pub const VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION     : i32 = 1;
pub const VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME   : *const u8 = b"VK_NV_inherited_viewport_scissor\0".as_ptr();
pub const VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION        : i32 = 1;
pub const VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME      : *const u8 = b"VK_EXT_texel_buffer_alignment\0".as_ptr();
pub const VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION        : i32 = 2;
pub const VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME      : *const u8 = b"VK_QCOM_render_pass_transform\0".as_ptr();
pub const VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION          : i32 = 2;
pub const VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME        : *const u8 = b"VK_EXT_device_memory_report\0".as_ptr();
pub const VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION           : i32 = 1;
pub const VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME         : *const u8 = b"VK_EXT_acquire_drm_display\0".as_ptr();
pub const VK_EXT_ROBUSTNESS_2_SPEC_VERSION                  : i32 = 1;
pub const VK_EXT_ROBUSTNESS_2_EXTENSION_NAME                : *const u8 = b"VK_EXT_robustness2\0".as_ptr();
pub const VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION           : i32 = 12;
pub const VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME         : *const u8 = b"VK_EXT_custom_border_color\0".as_ptr();
pub const VK_GOOGLE_USER_TYPE_SPEC_VERSION                  : i32 = 1;
pub const VK_GOOGLE_USER_TYPE_EXTENSION_NAME                : *const u8 = b"VK_GOOGLE_user_type\0".as_ptr();
pub const VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION              : i32 = 1;
pub const VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME            : *const u8 = b"VK_KHR_pipeline_library\0".as_ptr();
pub const VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION      : i32 = 1;
pub const VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME    : *const u8 = b"VK_KHR_shader_non_semantic_info\0".as_ptr();
pub const VK_EXT_PRIVATE_DATA_SPEC_VERSION                  : i32 = 1;
pub const VK_EXT_PRIVATE_DATA_EXTENSION_NAME                : *const u8 = b"VK_EXT_private_data\0".as_ptr();
pub const VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION: i32 = 3;
pub const VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME: *const u8 = b"VK_EXT_pipeline_creation_cache_control\0".as_ptr();
pub const VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION            : i32 = 2;
pub const VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME          : *const u8 = b"VK_KHR_video_encode_queue\0".as_ptr();
pub const VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION      : i32 = 1;
pub const VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME    : *const u8 = b"VK_NV_device_diagnostics_config\0".as_ptr();
pub const VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION        : i32 = 2;
pub const VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME      : *const u8 = b"VK_QCOM_render_pass_store_ops\0".as_ptr();
pub const VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION             : i32 = 1;
pub const VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME           : *const u8 = b"VK_KHR_synchronization2\0".as_ptr();
pub const VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION: i32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME: *const u8 = b"VK_KHR_shader_subgroup_uniform_control_flow\0".as_ptr();
pub const VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION: i32 = 1;
pub const VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME: *const u8 = b"VK_KHR_zero_initialize_workgroup_memory\0".as_ptr();
pub const VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION    : i32 = 1;
pub const VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME  : *const u8 = b"VK_NV_fragment_shading_rate_enums\0".as_ptr();
pub const VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION        : i32 = 1;
pub const VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME      : *const u8 = b"VK_NV_ray_tracing_motion_blur\0".as_ptr();
pub const VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION      : i32 = 1;
pub const VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME    : *const u8 = b"VK_EXT_ycbcr_2plane_444_formats\0".as_ptr();
pub const VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION        : i32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME      : *const u8 = b"VK_EXT_fragment_density_map2\0".as_ptr();
pub const VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION        : i32 = 1;
pub const VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME      : *const u8 = b"VK_QCOM_rotated_copy_commands\0".as_ptr();
pub const VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME            : *const u8 = b"VK_EXT_image_robustness\0".as_ptr();
pub const VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION: i32 = 1;
pub const VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME: *const u8 = b"VK_KHR_workgroup_memory_explicit_layout\0".as_ptr();
pub const VK_KHR_COPY_COMMANDS_2_SPEC_VERSION               : i32 = 1;
pub const VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME             : *const u8 = b"VK_KHR_copy_commands2\0".as_ptr();
pub const VK_EXT_4444_FORMATS_SPEC_VERSION                  : i32 = 1;
pub const VK_EXT_4444_FORMATS_EXTENSION_NAME                : *const u8 = b"VK_EXT_4444_formats\0".as_ptr();
pub const VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION          : i32 = 1;
pub const VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME        : *const u8 = b"VK_NV_acquire_winrt_display\0".as_ptr();
pub const VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION              : i32 = 1;
pub const VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME            : *const u8 = b"VK_EXT_directfb_surface\0".as_ptr();
pub const VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION     : i32 = 1;
pub const VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME   : *const u8 = b"VK_VALVE_mutable_descriptor_type\0".as_ptr();
pub const VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION    : i32 = 2;
pub const VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME  : *const u8 = b"VK_EXT_vertex_input_dynamic_state\0".as_ptr();
pub const VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION           : i32 = 1;
pub const VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME         : *const u8 = b"VK_EXT_physical_device_drm\0".as_ptr();
pub const VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION           : i32 = 1;
pub const VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME         : *const u8 = b"VK_FUCHSIA_external_memory\0".as_ptr();
pub const VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION        : i32 = 1;
pub const VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME      : *const u8 = b"VK_FUCHSIA_external_semaphore\0".as_ptr();
pub const VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION            : i32 = 2;
pub const VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME          : *const u8 = b"VK_HUAWEI_subpass_shading\0".as_ptr();
pub const VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION           : i32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME         : *const u8 = b"VK_NV_external_memory_rdma\0".as_ptr();
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION      : i32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME    : *const u8 = b"VK_EXT_extended_dynamic_state2\0".as_ptr();
pub const VK_QNX_SCREEN_SURFACE_SPEC_VERSION                : i32 = 1;
pub const VK_QNX_SCREEN_SURFACE_EXTENSION_NAME              : *const u8 = b"VK_QNX_screen_surface\0".as_ptr();
pub const VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION            : i32 = 1;
pub const VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME          : *const u8 = b"VK_EXT_color_write_enable\0".as_ptr();
pub const VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION         : i32 = 1;
pub const VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME       : *const u8 = b"VK_EXT_global_priority_query\0".as_ptr();
pub const VK_EXT_MULTI_DRAW_SPEC_VERSION                    : i32 = 1;
pub const VK_EXT_MULTI_DRAW_EXTENSION_NAME                  : *const u8 = b"VK_EXT_multi_draw\0".as_ptr();
#[inline] pub const fn VK_MAKE_VERSION(major: u32, minor: u32, patch: u32) -> u32 { (major << 22) | (minor << 12) | patch }
#[inline] pub const fn VK_VERSION_MAJOR(version: u32) -> u32 { version >> 22 }
#[inline] pub const fn VK_VERSION_MINOR(version: u32) -> u32 { version >> 12 & 0x3ff }
#[inline] pub const fn VK_VERSION_PATCH(version: u32) -> u32 { version & 0xfff }

pub type PFN_vkInternalAllocationNotification          = extern fn(
	pUserData                                    : &u8,
	size                                         : usize,
	allocationType                               : VkInternalAllocationType,
	allocationScope                              : VkSystemAllocationScope,
) -> ()
;

pub type PFN_vkInternalFreeNotification                = extern fn(
	pUserData                                    : &u8,
	size                                         : usize,
	allocationType                               : VkInternalAllocationType,
	allocationScope                              : VkSystemAllocationScope,
) -> ()
;

pub type PFN_vkReallocationFunction                    = extern fn(
	pUserData                                    : &u8,
	pOriginal                                    : &u8,
	size                                         : usize,
	alignment                                    : usize,
	allocationScope                              : VkSystemAllocationScope,
) -> ()
;

pub type PFN_vkAllocationFunction                      = extern fn(
	pUserData                                    : &u8,
	size                                         : usize,
	alignment                                    : usize,
	allocationScope                              : VkSystemAllocationScope,
) -> ()
;

pub type PFN_vkFreeFunction                            = extern fn(
	pUserData                                    : &u8,
	pMemory                                      : &u8,
) -> ()
;

pub type PFN_vkVoidFunction                            = extern fn(
) -> ()
;

pub type PFN_vkDebugReportCallbackEXT                  = extern fn(
	flags                                        : VkDebugReportFlagsEXT,
	objectType                                   : VkDebugReportObjectTypeEXT,
	object                                       : u64,
	location                                     : usize,
	messageCode                                  : i32,
	pLayerPrefix                                 : &u8,
	pMessage                                     : &u8,
	pUserData                                    : &u8,
) -> VkBool32
;

pub type PFN_vkDebugUtilsMessengerCallbackEXT          = extern fn(
	messageSeverity                              : VkDebugUtilsMessageSeverityFlagBitsEXT,
	messageTypes                                 : VkDebugUtilsMessageTypeFlagsEXT,
	pCallbackData                                : &VkDebugUtilsMessengerCallbackDataEXT,
	pUserData                                    : &u8,
) -> VkBool32
;

pub type PFN_vkDeviceMemoryReportCallbackEXT           = extern fn(
	pCallbackData                                : &VkDeviceMemoryReportCallbackDataEXT,
	pUserData                                    : &mut u8,
) -> ()
;

/// Wrapper for a `VkRenderPass` handle
#[derive(Clone, Debug)]
pub struct VkRenderPassImpl {
	pub handle: VkRenderPass,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkRenderPassImpl {
	type Target = VkRenderPass;
	
	#[inline]
	fn deref(&self) -> &VkRenderPass { &self.handle }
}

impl fmt::Display for VkRenderPassImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkRenderPassImpl {
	pub fn new(handle: VkRenderPass, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkBuffer` handle
#[derive(Clone, Debug)]
pub struct VkBufferImpl {
	pub handle: VkBuffer,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkBufferImpl {
	type Target = VkBuffer;
	
	#[inline]
	fn deref(&self) -> &VkBuffer { &self.handle }
}

impl fmt::Display for VkBufferImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkBufferImpl {
	pub fn new(handle: VkBuffer, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkIndirectCommandsLayoutNV` handle
#[derive(Clone, Debug)]
pub struct VkIndirectCommandsLayoutNVImpl {
	pub handle: VkIndirectCommandsLayoutNV,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkIndirectCommandsLayoutNVImpl {
	type Target = VkIndirectCommandsLayoutNV;
	
	#[inline]
	fn deref(&self) -> &VkIndirectCommandsLayoutNV { &self.handle }
}

impl fmt::Display for VkIndirectCommandsLayoutNVImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkIndirectCommandsLayoutNVImpl {
	pub fn new(handle: VkIndirectCommandsLayoutNV, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkSampler` handle
#[derive(Clone, Debug)]
pub struct VkSamplerImpl {
	pub handle: VkSampler,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkSamplerImpl {
	type Target = VkSampler;
	
	#[inline]
	fn deref(&self) -> &VkSampler { &self.handle }
}

impl fmt::Display for VkSamplerImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkSamplerImpl {
	pub fn new(handle: VkSampler, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDescriptorSet` handle
#[derive(Clone, Debug)]
pub struct VkDescriptorSetImpl {
	pub handle: VkDescriptorSet,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDescriptorSetImpl {
	type Target = VkDescriptorSet;
	
	#[inline]
	fn deref(&self) -> &VkDescriptorSet { &self.handle }
}

impl fmt::Display for VkDescriptorSetImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDescriptorSetImpl {
	pub fn new(handle: VkDescriptorSet, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkSwapchainKHR` handle
#[derive(Clone, Debug)]
pub struct VkSwapchainKHRImpl {
	pub handle: VkSwapchainKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkSwapchainKHRImpl {
	type Target = VkSwapchainKHR;
	
	#[inline]
	fn deref(&self) -> &VkSwapchainKHR { &self.handle }
}

impl fmt::Display for VkSwapchainKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkSwapchainKHRImpl {
	pub fn new(handle: VkSwapchainKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDisplayKHR` handle
#[derive(Clone, Debug)]
pub struct VkDisplayKHRImpl {
	pub handle: VkDisplayKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDisplayKHRImpl {
	type Target = VkDisplayKHR;
	
	#[inline]
	fn deref(&self) -> &VkDisplayKHR { &self.handle }
}

impl fmt::Display for VkDisplayKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDisplayKHRImpl {
	pub fn new(handle: VkDisplayKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkPrivateDataSlotEXT` handle
#[derive(Clone, Debug)]
pub struct VkPrivateDataSlotEXTImpl {
	pub handle: VkPrivateDataSlotEXT,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkPrivateDataSlotEXTImpl {
	type Target = VkPrivateDataSlotEXT;
	
	#[inline]
	fn deref(&self) -> &VkPrivateDataSlotEXT { &self.handle }
}

impl fmt::Display for VkPrivateDataSlotEXTImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkPrivateDataSlotEXTImpl {
	pub fn new(handle: VkPrivateDataSlotEXT, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}
impl VkInstanceImpl {
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn create(
		pCreateInfo                                  : &VkInstanceCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pInstance                                    : &mut VkInstance
	) -> VkResult {
		unsafe { (LIB_VULKAN.pfn_vkCreateInstance)(pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pInstance as *mut _ as _) }
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn enumerateVersion(
		pApiVersion                                  : &mut u32
	) -> VkResult {
		unsafe { (LIB_VULKAN.pfn_vkEnumerateInstanceVersion)(pApiVersion) }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn enumerateLayerProperties(
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkLayerProperties]>
	) -> VkResult {
		unsafe { (LIB_VULKAN.pfn_vkEnumerateInstanceLayerProperties)(pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _) }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn enumerateExtensionProperties(
		pLayerName                                   : Option<&[u8]>,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkExtensionProperties]>
	) -> VkResult {
		unsafe { (LIB_VULKAN.pfn_vkEnumerateInstanceExtensionProperties)(pLayerName.map_or(std::ptr::null(), <[_]>::as_ptr) as _, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _) }
	}
}

/// Wrapper for a `VkVideoSessionKHR` handle
#[derive(Clone, Debug)]
pub struct VkVideoSessionKHRImpl {
	pub handle: VkVideoSessionKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkVideoSessionKHRImpl {
	type Target = VkVideoSessionKHR;
	
	#[inline]
	fn deref(&self) -> &VkVideoSessionKHR { &self.handle }
}

impl fmt::Display for VkVideoSessionKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkVideoSessionKHRImpl {
	pub fn new(handle: VkVideoSessionKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkPhysicalDevice` handle
#[derive(Clone, Debug)]
pub struct VkPhysicalDeviceImpl {
	pub handle: VkPhysicalDevice,
	pub table:  Arc<VkInstanceTable>
}

impl ops::Deref for VkPhysicalDeviceImpl {
	type Target = VkPhysicalDevice;
	
	#[inline]
	fn deref(&self) -> &VkPhysicalDevice { &self.handle }
}

impl fmt::Display for VkPhysicalDeviceImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkPhysicalDeviceImpl {
	pub fn new(handle: VkPhysicalDevice, parent: &VkInstanceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getProperties(
		&self,
		pProperties                                  : &mut VkPhysicalDeviceProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceProperties)(self.handle, pProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getQueueFamilyProperties(
		&self,
		pQueueFamilyPropertyCount                    : &mut u32,
		pQueueFamilyProperties                       : Option<&mut [VkQueueFamilyProperties]>
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceQueueFamilyProperties)(self.handle, pQueueFamilyPropertyCount, pQueueFamilyProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getMemoryProperties(
		&self,
		pMemoryProperties                            : &mut VkPhysicalDeviceMemoryProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceMemoryProperties)(self.handle, pMemoryProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getFeatures(
		&self,
		pFeatures                                    : &mut VkPhysicalDeviceFeatures
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceFeatures)(self.handle, pFeatures as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getFormatProperties(
		&self,
		format                                       : VkFormat,
		pFormatProperties                            : &mut VkFormatProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceFormatProperties)(self.handle, format, pFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getImageFormatProperties(
		&self,
		format                                       : VkFormat,
		r#type                                       : VkImageType,
		tiling                                       : VkImageTiling,
		usage                                        : VkImageUsageFlags,
		flags                                        : VkImageCreateFlags,
		pImageFormatProperties                       : &mut VkImageFormatProperties
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceImageFormatProperties)(self.handle, format, r#type, tiling, usage, flags, pImageFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createDevice(
		&self,
		pCreateInfo                                  : &VkDeviceCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pDevice                                      : &mut VkDevice
	) -> VkResult {
		(self.table.pfn_vkCreateDevice)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pDevice as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn enumerateDeviceLayerProperties(
		&self,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkLayerProperties]>
	) -> VkResult {
		(self.table.pfn_vkEnumerateDeviceLayerProperties)(self.handle, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn enumerateDeviceExtensionProperties(
		&self,
		pLayerName                                   : Option<&[u8]>,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkExtensionProperties]>
	) -> VkResult {
		(self.table.pfn_vkEnumerateDeviceExtensionProperties)(self.handle, pLayerName.map_or(std::ptr::null(), <[_]>::as_ptr) as _, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getSparseImageFormatProperties(
		&self,
		format                                       : VkFormat,
		r#type                                       : VkImageType,
		samples                                      : VkSampleCountFlagBits,
		usage                                        : VkImageUsageFlags,
		tiling                                       : VkImageTiling,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkSparseImageFormatProperties]>
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceSparseImageFormatProperties)(self.handle, format, r#type, samples, usage, tiling, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn getDisplayPropertiesKHR(
		&self,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkDisplayPropertiesKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceDisplayPropertiesKHR)(self.handle, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn getDisplayPlanePropertiesKHR(
		&self,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkDisplayPlanePropertiesKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(self.handle, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn getDisplayPlaneSupportedDisplaysKHR(
		&self,
		planeIndex                                   : u32,
		pDisplayCount                                : &mut u32,
		pDisplays                                    : Option<&mut [VkDisplayKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetDisplayPlaneSupportedDisplaysKHR)(self.handle, planeIndex, pDisplayCount, pDisplays.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn getDisplayModePropertiesKHR(
		&self,
		display                                      : VkDisplayKHR,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkDisplayModePropertiesKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetDisplayModePropertiesKHR)(self.handle, display, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn createDisplayModeKHR(
		&self,
		display                                      : VkDisplayKHR,
		pCreateInfo                                  : &VkDisplayModeCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pMode                                        : &mut VkDisplayModeKHR
	) -> VkResult {
		(self.table.pfn_vkCreateDisplayModeKHR)(self.handle, display, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pMode as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn getDisplayPlaneCapabilitiesKHR(
		&self,
		mode                                         : VkDisplayModeKHR,
		planeIndex                                   : u32,
		pCapabilities                                : &mut VkDisplayPlaneCapabilitiesKHR
	) -> VkResult {
		(self.table.pfn_vkGetDisplayPlaneCapabilitiesKHR)(self.handle, mode, planeIndex, pCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_surface")]
	pub fn getSurfaceSupportKHR(
		&self,
		queueFamilyIndex                             : u32,
		surface                                      : VkSurfaceKHR,
		pSupported                                   : &mut VkBool32
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfaceSupportKHR)(self.handle, queueFamilyIndex, surface, pSupported as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_surface")]
	pub fn getSurfaceCapabilitiesKHR(
		&self,
		surface                                      : VkSurfaceKHR,
		pSurfaceCapabilities                         : &mut VkSurfaceCapabilitiesKHR
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(self.handle, surface, pSurfaceCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_surface")]
	pub fn getSurfaceFormatsKHR(
		&self,
		surface                                      : VkSurfaceKHR,
		pSurfaceFormatCount                          : &mut u32,
		pSurfaceFormats                              : Option<&mut [VkSurfaceFormatKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfaceFormatsKHR)(self.handle, surface, pSurfaceFormatCount, pSurfaceFormats.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_surface")]
	pub fn getSurfacePresentModesKHR(
		&self,
		surface                                      : VkSurfaceKHR,
		pPresentModeCount                            : &mut u32,
		pPresentModes                                : Option<&mut [VkPresentModeKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfacePresentModesKHR)(self.handle, surface, pPresentModeCount, pPresentModes.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_wayland_surface")]
	pub fn getWaylandPresentationSupportKHR(
		&self,
		queueFamilyIndex                             : u32,
		display                                      : &mut wl_display
	) -> VkBool32 {
		(self.table.pfn_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(self.handle, queueFamilyIndex, display as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_win32_surface")]
	pub fn getWin32PresentationSupportKHR(
		&self,
		queueFamilyIndex                             : u32
	) -> VkBool32 {
		(self.table.pfn_vkGetPhysicalDeviceWin32PresentationSupportKHR)(self.handle, queueFamilyIndex)
	}
	
	#[cfg(feature = "VK_KHR_xlib_surface")]
	pub fn getXlibPresentationSupportKHR(
		&self,
		queueFamilyIndex                             : u32,
		dpy                                          : &mut Display,
		visualID                                     : VisualID
	) -> VkBool32 {
		(self.table.pfn_vkGetPhysicalDeviceXlibPresentationSupportKHR)(self.handle, queueFamilyIndex, dpy as *mut _ as _, visualID)
	}
	
	#[cfg(feature = "VK_KHR_xcb_surface")]
	pub fn getXcbPresentationSupportKHR(
		&self,
		queueFamilyIndex                             : u32,
		connection                                   : &mut xcb_connection_t,
		visual_id                                    : xcb_visualid_t
	) -> VkBool32 {
		(self.table.pfn_vkGetPhysicalDeviceXcbPresentationSupportKHR)(self.handle, queueFamilyIndex, connection as *mut _ as _, visual_id)
	}
	
	#[cfg(feature = "VK_EXT_directfb_surface")]
	pub fn getDirectFBPresentationSupportEXT(
		&self,
		queueFamilyIndex                             : u32,
		dfb                                          : &mut IDirectFB
	) -> VkBool32 {
		(self.table.pfn_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)(self.handle, queueFamilyIndex, dfb as *mut _ as _)
	}
	
	#[cfg(feature = "VK_QNX_screen_surface")]
	pub fn getScreenPresentationSupportQNX(
		&self,
		queueFamilyIndex                             : u32,
		window                                       : &mut _screen_window
	) -> VkBool32 {
		(self.table.pfn_vkGetPhysicalDeviceScreenPresentationSupportQNX)(self.handle, queueFamilyIndex, window as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_external_memory_capabilities")]
	pub fn getExternalImageFormatPropertiesNV(
		&self,
		format                                       : VkFormat,
		r#type                                       : VkImageType,
		tiling                                       : VkImageTiling,
		usage                                        : VkImageUsageFlags,
		flags                                        : VkImageCreateFlags,
		externalHandleType                           : VkExternalMemoryHandleTypeFlagsNV,
		pExternalImageFormatProperties               : &mut VkExternalImageFormatPropertiesNV
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(self.handle, format, r#type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getFeatures2(
		&self,
		pFeatures                                    : &mut VkPhysicalDeviceFeatures2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceFeatures2)(self.handle, pFeatures as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getFeatures2KHR(
		&self,
		pFeatures                                    : &mut VkPhysicalDeviceFeatures2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceFeatures2KHR)(self.handle, pFeatures as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getProperties2(
		&self,
		pProperties                                  : &mut VkPhysicalDeviceProperties2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceProperties2)(self.handle, pProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getProperties2KHR(
		&self,
		pProperties                                  : &mut VkPhysicalDeviceProperties2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceProperties2KHR)(self.handle, pProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getFormatProperties2(
		&self,
		format                                       : VkFormat,
		pFormatProperties                            : &mut VkFormatProperties2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceFormatProperties2)(self.handle, format, pFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getFormatProperties2KHR(
		&self,
		format                                       : VkFormat,
		pFormatProperties                            : &mut VkFormatProperties2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceFormatProperties2KHR)(self.handle, format, pFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getImageFormatProperties2(
		&self,
		pImageFormatInfo                             : &VkPhysicalDeviceImageFormatInfo2,
		pImageFormatProperties                       : &mut VkImageFormatProperties2
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceImageFormatProperties2)(self.handle, pImageFormatInfo as *const _ as _, pImageFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getImageFormatProperties2KHR(
		&self,
		pImageFormatInfo                             : &VkPhysicalDeviceImageFormatInfo2,
		pImageFormatProperties                       : &mut VkImageFormatProperties2
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceImageFormatProperties2KHR)(self.handle, pImageFormatInfo as *const _ as _, pImageFormatProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getQueueFamilyProperties2(
		&self,
		pQueueFamilyPropertyCount                    : &mut u32,
		pQueueFamilyProperties                       : Option<&mut [VkQueueFamilyProperties2]>
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceQueueFamilyProperties2)(self.handle, pQueueFamilyPropertyCount, pQueueFamilyProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getQueueFamilyProperties2KHR(
		&self,
		pQueueFamilyPropertyCount                    : &mut u32,
		pQueueFamilyProperties                       : Option<&mut [VkQueueFamilyProperties2]>
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceQueueFamilyProperties2KHR)(self.handle, pQueueFamilyPropertyCount, pQueueFamilyProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getMemoryProperties2(
		&self,
		pMemoryProperties                            : &mut VkPhysicalDeviceMemoryProperties2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceMemoryProperties2)(self.handle, pMemoryProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getMemoryProperties2KHR(
		&self,
		pMemoryProperties                            : &mut VkPhysicalDeviceMemoryProperties2
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceMemoryProperties2KHR)(self.handle, pMemoryProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getSparseImageFormatProperties2(
		&self,
		pFormatInfo                                  : &VkPhysicalDeviceSparseImageFormatInfo2,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkSparseImageFormatProperties2]>
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceSparseImageFormatProperties2)(self.handle, pFormatInfo as *const _ as _, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pub fn getSparseImageFormatProperties2KHR(
		&self,
		pFormatInfo                                  : &VkPhysicalDeviceSparseImageFormatInfo2,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkSparseImageFormatProperties2]>
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(self.handle, pFormatInfo as *const _ as _, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getExternalBufferProperties(
		&self,
		pExternalBufferInfo                          : &VkPhysicalDeviceExternalBufferInfo,
		pExternalBufferProperties                    : &mut VkExternalBufferProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceExternalBufferProperties)(self.handle, pExternalBufferInfo as *const _ as _, pExternalBufferProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_memory_capabilities")]
	pub fn getExternalBufferPropertiesKHR(
		&self,
		pExternalBufferInfo                          : &VkPhysicalDeviceExternalBufferInfo,
		pExternalBufferProperties                    : &mut VkExternalBufferProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(self.handle, pExternalBufferInfo as *const _ as _, pExternalBufferProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getExternalSemaphoreProperties(
		&self,
		pExternalSemaphoreInfo                       : &VkPhysicalDeviceExternalSemaphoreInfo,
		pExternalSemaphoreProperties                 : &mut VkExternalSemaphoreProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceExternalSemaphoreProperties)(self.handle, pExternalSemaphoreInfo as *const _ as _, pExternalSemaphoreProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_semaphore_capabilities")]
	pub fn getExternalSemaphorePropertiesKHR(
		&self,
		pExternalSemaphoreInfo                       : &VkPhysicalDeviceExternalSemaphoreInfo,
		pExternalSemaphoreProperties                 : &mut VkExternalSemaphoreProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(self.handle, pExternalSemaphoreInfo as *const _ as _, pExternalSemaphoreProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getExternalFenceProperties(
		&self,
		pExternalFenceInfo                           : &VkPhysicalDeviceExternalFenceInfo,
		pExternalFenceProperties                     : &mut VkExternalFenceProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceExternalFenceProperties)(self.handle, pExternalFenceInfo as *const _ as _, pExternalFenceProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_fence_capabilities")]
	pub fn getExternalFencePropertiesKHR(
		&self,
		pExternalFenceInfo                           : &VkPhysicalDeviceExternalFenceInfo,
		pExternalFenceProperties                     : &mut VkExternalFenceProperties
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceExternalFencePropertiesKHR)(self.handle, pExternalFenceInfo as *const _ as _, pExternalFenceProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_direct_mode_display")]
	pub fn releaseDisplayEXT(
		&self,
		display                                      : VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkReleaseDisplayEXT)(self.handle, display)
	}
	
	#[cfg(feature = "VK_EXT_acquire_xlib_display")]
	pub fn acquireXlibDisplayEXT(
		&self,
		dpy                                          : &mut Display,
		display                                      : VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkAcquireXlibDisplayEXT)(self.handle, dpy as *mut _ as _, display)
	}
	
	#[cfg(feature = "VK_EXT_acquire_xlib_display")]
	pub fn getRandROutputDisplayEXT(
		&self,
		dpy                                          : &mut Display,
		rrOutput                                     : RROutput,
		pDisplay                                     : &mut VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkGetRandROutputDisplayEXT)(self.handle, dpy as *mut _ as _, rrOutput, pDisplay as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_acquire_winrt_display")]
	pub fn acquireWinrtDisplayNV(
		&self,
		display                                      : VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkAcquireWinrtDisplayNV)(self.handle, display)
	}
	
	#[cfg(feature = "VK_NV_acquire_winrt_display")]
	pub fn getWinrtDisplayNV(
		&self,
		deviceRelativeId                             : u32,
		pDisplay                                     : &mut VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkGetWinrtDisplayNV)(self.handle, deviceRelativeId, pDisplay as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_display_surface_counter")]
	pub fn getSurfaceCapabilities2EXT(
		&self,
		surface                                      : VkSurfaceKHR,
		pSurfaceCapabilities                         : &mut VkSurfaceCapabilities2EXT
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfaceCapabilities2EXT)(self.handle, surface, pSurfaceCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn getPresentRectanglesKHR(
		&self,
		surface                                      : VkSurfaceKHR,
		pRectCount                                   : &mut u32,
		pRects                                       : Option<&mut [VkRect2D]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDevicePresentRectanglesKHR)(self.handle, surface, pRectCount, pRects.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_sample_locations")]
	pub fn getMultisamplePropertiesEXT(
		&self,
		samples                                      : VkSampleCountFlagBits,
		pMultisampleProperties                       : &mut VkMultisamplePropertiesEXT
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceMultisamplePropertiesEXT)(self.handle, samples, pMultisampleProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
	pub fn getSurfaceCapabilities2KHR(
		&self,
		pSurfaceInfo                                 : &VkPhysicalDeviceSurfaceInfo2KHR,
		pSurfaceCapabilities                         : &mut VkSurfaceCapabilities2KHR
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfaceCapabilities2KHR)(self.handle, pSurfaceInfo as *const _ as _, pSurfaceCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
	pub fn getSurfaceFormats2KHR(
		&self,
		pSurfaceInfo                                 : &VkPhysicalDeviceSurfaceInfo2KHR,
		pSurfaceFormatCount                          : &mut u32,
		pSurfaceFormats                              : Option<&mut [VkSurfaceFormat2KHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfaceFormats2KHR)(self.handle, pSurfaceInfo as *const _ as _, pSurfaceFormatCount, pSurfaceFormats.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pub fn getDisplayProperties2KHR(
		&self,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkDisplayProperties2KHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceDisplayProperties2KHR)(self.handle, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pub fn getDisplayPlaneProperties2KHR(
		&self,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkDisplayPlaneProperties2KHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)(self.handle, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pub fn getDisplayModeProperties2KHR(
		&self,
		display                                      : VkDisplayKHR,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkDisplayModeProperties2KHR]>
	) -> VkResult {
		(self.table.pfn_vkGetDisplayModeProperties2KHR)(self.handle, display, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pub fn getDisplayPlaneCapabilities2KHR(
		&self,
		pDisplayPlaneInfo                            : &VkDisplayPlaneInfo2KHR,
		pCapabilities                                : &mut VkDisplayPlaneCapabilities2KHR
	) -> VkResult {
		(self.table.pfn_vkGetDisplayPlaneCapabilities2KHR)(self.handle, pDisplayPlaneInfo as *const _ as _, pCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_calibrated_timestamps")]
	pub fn getCalibrateableTimeDomainsEXT(
		&self,
		pTimeDomainCount                             : &mut u32,
		pTimeDomains                                 : Option<&mut [VkTimeDomainEXT]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)(self.handle, pTimeDomainCount, pTimeDomains.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_NV_cooperative_matrix")]
	pub fn getCooperativeMatrixPropertiesNV(
		&self,
		pPropertyCount                               : &mut u32,
		pProperties                                  : Option<&mut [VkCooperativeMatrixPropertiesNV]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)(self.handle, pPropertyCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pub fn getSurfacePresentModes2EXT(
		&self,
		pSurfaceInfo                                 : &VkPhysicalDeviceSurfaceInfo2KHR,
		pPresentModeCount                            : &mut u32,
		pPresentModes                                : Option<&mut [VkPresentModeKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSurfacePresentModes2EXT)(self.handle, pSurfaceInfo as *const _ as _, pPresentModeCount, pPresentModes.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_performance_query")]
	pub fn enumerateQueueFamilyPerformanceQueryCountersKHR(
		&self,
		queueFamilyIndex                             : u32,
		pCounterCount                                : &mut u32,
		pCounters                                    : Option<&mut [VkPerformanceCounterKHR]>,
		pCounterDescriptions                         : Option<&mut [VkPerformanceCounterDescriptionKHR]>
	) -> VkResult {
		(self.table.pfn_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)(self.handle, queueFamilyIndex, pCounterCount, pCounters.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _, pCounterDescriptions.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_performance_query")]
	pub fn getQueueFamilyPerformanceQueryPassesKHR(
		&self,
		pPerformanceQueryCreateInfo                  : &VkQueryPoolPerformanceCreateInfoKHR,
		pNumPasses                                   : &mut u32
	) -> () {
		(self.table.pfn_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)(self.handle, pPerformanceQueryCreateInfo as *const _ as _, pNumPasses)
	}
	
	#[cfg(feature = "VK_NV_coverage_reduction_mode")]
	pub fn getSupportedFramebufferMixedSamplesCombinationsNV(
		&self,
		pCombinationCount                            : &mut u32,
		pCombinations                                : Option<&mut [VkFramebufferMixedSamplesCombinationNV]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)(self.handle, pCombinationCount, pCombinations.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_tooling_info")]
	pub fn getToolPropertiesEXT(
		&self,
		pToolCount                                   : &mut u32,
		pToolProperties                              : Option<&mut [VkPhysicalDeviceToolPropertiesEXT]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceToolPropertiesEXT)(self.handle, pToolCount, pToolProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_fragment_shading_rate")]
	pub fn getFragmentShadingRatesKHR(
		&self,
		pFragmentShadingRateCount                    : &mut u32,
		pFragmentShadingRates                        : Option<&mut [VkPhysicalDeviceFragmentShadingRateKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceFragmentShadingRatesKHR)(self.handle, pFragmentShadingRateCount, pFragmentShadingRates.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn getVideoCapabilitiesKHR(
		&self,
		pVideoProfile                                : &VkVideoProfileKHR,
		pCapabilities                                : &mut VkVideoCapabilitiesKHR
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceVideoCapabilitiesKHR)(self.handle, pVideoProfile as *const _ as _, pCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn getVideoFormatPropertiesKHR(
		&self,
		pVideoFormatInfo                             : &VkPhysicalDeviceVideoFormatInfoKHR,
		pVideoFormatPropertyCount                    : &mut u32,
		pVideoFormatProperties                       : Option<&mut [VkVideoFormatPropertiesKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPhysicalDeviceVideoFormatPropertiesKHR)(self.handle, pVideoFormatInfo as *const _ as _, pVideoFormatPropertyCount, pVideoFormatProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_acquire_drm_display")]
	pub fn acquireDrmDisplayEXT(
		&self,
		drmFd                                        : i32,
		display                                      : VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkAcquireDrmDisplayEXT)(self.handle, drmFd, display)
	}
	
	#[cfg(feature = "VK_EXT_acquire_drm_display")]
	pub fn getDrmDisplayEXT(
		&self,
		drmFd                                        : i32,
		connectorId                                  : u32,
		display                                      : &mut VkDisplayKHR
	) -> VkResult {
		(self.table.pfn_vkGetDrmDisplayEXT)(self.handle, drmFd, connectorId, display as *mut _ as _)
	}
}

/// Wrapper for a `VkAccelerationStructureKHR` handle
#[derive(Clone, Debug)]
pub struct VkAccelerationStructureKHRImpl {
	pub handle: VkAccelerationStructureKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkAccelerationStructureKHRImpl {
	type Target = VkAccelerationStructureKHR;
	
	#[inline]
	fn deref(&self) -> &VkAccelerationStructureKHR { &self.handle }
}

impl fmt::Display for VkAccelerationStructureKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkAccelerationStructureKHRImpl {
	pub fn new(handle: VkAccelerationStructureKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDeferredOperationKHR` handle
#[derive(Clone, Debug)]
pub struct VkDeferredOperationKHRImpl {
	pub handle: VkDeferredOperationKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDeferredOperationKHRImpl {
	type Target = VkDeferredOperationKHR;
	
	#[inline]
	fn deref(&self) -> &VkDeferredOperationKHR { &self.handle }
}

impl fmt::Display for VkDeferredOperationKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDeferredOperationKHRImpl {
	pub fn new(handle: VkDeferredOperationKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDisplayModeKHR` handle
#[derive(Clone, Debug)]
pub struct VkDisplayModeKHRImpl {
	pub handle: VkDisplayModeKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDisplayModeKHRImpl {
	type Target = VkDisplayModeKHR;
	
	#[inline]
	fn deref(&self) -> &VkDisplayModeKHR { &self.handle }
}

impl fmt::Display for VkDisplayModeKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDisplayModeKHRImpl {
	pub fn new(handle: VkDisplayModeKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDevice` handle
#[derive(Clone, Debug)]
pub struct VkDeviceImpl {
	pub handle: VkDevice,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDeviceImpl {
	type Target = VkDevice;
	
	#[inline]
	fn deref(&self) -> &VkDevice { &self.handle }
}

impl fmt::Display for VkDeviceImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDeviceImpl {
	pub fn new(handle: VkDevice, parent: &VkInstanceImpl) -> Self {
		Self { handle, table: VkDeviceTable::load(handle, &parent.table) }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroy(
		&self,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDevice)(self.handle, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getQueue(
		&self,
		queueFamilyIndex                             : u32,
		queueIndex                                   : u32,
		pQueue                                       : &mut VkQueue
	) -> () {
		(self.table.pfn_vkGetDeviceQueue)(self.handle, queueFamilyIndex, queueIndex, pQueue as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn waitIdle(
		&self
	) -> VkResult {
		(self.table.pfn_vkDeviceWaitIdle)(self.handle)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn allocateMemory(
		&self,
		pAllocateInfo                                : &VkMemoryAllocateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pMemory                                      : &mut VkDeviceMemory
	) -> VkResult {
		(self.table.pfn_vkAllocateMemory)(self.handle, pAllocateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pMemory as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn freeMemory(
		&self,
		memory                                       : VkDeviceMemory,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkFreeMemory)(self.handle, memory, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn mapMemory(
		&self,
		memory                                       : VkDeviceMemory,
		offset                                       : VkDeviceSize,
		size                                         : VkDeviceSize,
		flags                                        : VkMemoryMapFlags,
		ppData                                       : &mut VkAnyMut
	) -> VkResult {
		(self.table.pfn_vkMapMemory)(self.handle, memory, offset, size, flags, ppData as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn unmapMemory(
		&self,
		memory                                       : VkDeviceMemory
	) -> () {
		(self.table.pfn_vkUnmapMemory)(self.handle, memory)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn flushMappedMemoryRanges(
		&self,
		pMemoryRanges                                : &[VkMappedMemoryRange]
	) -> VkResult {
		(self.table.pfn_vkFlushMappedMemoryRanges)(self.handle, pMemoryRanges.len() as _, pMemoryRanges.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn invalidateMappedMemoryRanges(
		&self,
		pMemoryRanges                                : &[VkMappedMemoryRange]
	) -> VkResult {
		(self.table.pfn_vkInvalidateMappedMemoryRanges)(self.handle, pMemoryRanges.len() as _, pMemoryRanges.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getMemoryCommitment(
		&self,
		memory                                       : VkDeviceMemory,
		pCommittedMemoryInBytes                      : &mut VkDeviceSize
	) -> () {
		(self.table.pfn_vkGetDeviceMemoryCommitment)(self.handle, memory, pCommittedMemoryInBytes as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getBufferMemoryRequirements(
		&self,
		buffer                                       : VkBuffer,
		pMemoryRequirements                          : &mut VkMemoryRequirements
	) -> () {
		(self.table.pfn_vkGetBufferMemoryRequirements)(self.handle, buffer, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn bindBufferMemory(
		&self,
		buffer                                       : VkBuffer,
		memory                                       : VkDeviceMemory,
		memoryOffset                                 : VkDeviceSize
	) -> VkResult {
		(self.table.pfn_vkBindBufferMemory)(self.handle, buffer, memory, memoryOffset)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getImageMemoryRequirements(
		&self,
		image                                        : VkImage,
		pMemoryRequirements                          : &mut VkMemoryRequirements
	) -> () {
		(self.table.pfn_vkGetImageMemoryRequirements)(self.handle, image, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn bindImageMemory(
		&self,
		image                                        : VkImage,
		memory                                       : VkDeviceMemory,
		memoryOffset                                 : VkDeviceSize
	) -> VkResult {
		(self.table.pfn_vkBindImageMemory)(self.handle, image, memory, memoryOffset)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getImageSparseMemoryRequirements(
		&self,
		image                                        : VkImage,
		pSparseMemoryRequirementCount                : &mut u32,
		pSparseMemoryRequirements                    : Option<&mut [VkSparseImageMemoryRequirements]>
	) -> () {
		(self.table.pfn_vkGetImageSparseMemoryRequirements)(self.handle, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createFence(
		&self,
		pCreateInfo                                  : &VkFenceCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pFence                                       : &mut VkFence
	) -> VkResult {
		(self.table.pfn_vkCreateFence)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pFence as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyFence(
		&self,
		fence                                        : VkFence,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyFence)(self.handle, fence, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn resetFences(
		&self,
		pFences                                      : &[VkFence]
	) -> VkResult {
		(self.table.pfn_vkResetFences)(self.handle, pFences.len() as _, pFences.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getFenceStatus(
		&self,
		fence                                        : VkFence
	) -> VkResult {
		(self.table.pfn_vkGetFenceStatus)(self.handle, fence)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn waitForFences(
		&self,
		pFences                                      : &[VkFence],
		waitAll                                      : VkBool32,
		timeout                                      : u64
	) -> VkResult {
		(self.table.pfn_vkWaitForFences)(self.handle, pFences.len() as _, pFences.as_ptr() as _, waitAll, timeout)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createSemaphore(
		&self,
		pCreateInfo                                  : &VkSemaphoreCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSemaphore                                   : &mut VkSemaphore
	) -> VkResult {
		(self.table.pfn_vkCreateSemaphore)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSemaphore as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroySemaphore(
		&self,
		semaphore                                    : VkSemaphore,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroySemaphore)(self.handle, semaphore, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createEvent(
		&self,
		pCreateInfo                                  : &VkEventCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pEvent                                       : &mut VkEvent
	) -> VkResult {
		(self.table.pfn_vkCreateEvent)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pEvent as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyEvent(
		&self,
		event                                        : VkEvent,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyEvent)(self.handle, event, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getEventStatus(
		&self,
		event                                        : VkEvent
	) -> VkResult {
		(self.table.pfn_vkGetEventStatus)(self.handle, event)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn setEvent(
		&self,
		event                                        : VkEvent
	) -> VkResult {
		(self.table.pfn_vkSetEvent)(self.handle, event)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn resetEvent(
		&self,
		event                                        : VkEvent
	) -> VkResult {
		(self.table.pfn_vkResetEvent)(self.handle, event)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createQueryPool(
		&self,
		pCreateInfo                                  : &VkQueryPoolCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pQueryPool                                   : &mut VkQueryPool
	) -> VkResult {
		(self.table.pfn_vkCreateQueryPool)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pQueryPool as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyQueryPool(
		&self,
		queryPool                                    : VkQueryPool,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyQueryPool)(self.handle, queryPool, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getQueryPoolResults(
		&self,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32,
		queryCount                                   : u32,
		pData                                        : &mut [u8],
		stride                                       : VkDeviceSize,
		flags                                        : VkQueryResultFlags
	) -> VkResult {
		(self.table.pfn_vkGetQueryPoolResults)(self.handle, queryPool, firstQuery, queryCount, pData.len() as _, pData.as_mut_ptr() as _, stride, flags)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn resetQueryPool(
		&self,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32,
		queryCount                                   : u32
	) -> () {
		(self.table.pfn_vkResetQueryPool)(self.handle, queryPool, firstQuery, queryCount)
	}
	
	#[cfg(feature = "VK_EXT_host_query_reset")]
	pub fn resetQueryPoolEXT(
		&self,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32,
		queryCount                                   : u32
	) -> () {
		(self.table.pfn_vkResetQueryPoolEXT)(self.handle, queryPool, firstQuery, queryCount)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createBuffer(
		&self,
		pCreateInfo                                  : &VkBufferCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pBuffer                                      : &mut VkBuffer
	) -> VkResult {
		(self.table.pfn_vkCreateBuffer)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pBuffer as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyBuffer(
		&self,
		buffer                                       : VkBuffer,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyBuffer)(self.handle, buffer, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createBufferView(
		&self,
		pCreateInfo                                  : &VkBufferViewCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pView                                        : &mut VkBufferView
	) -> VkResult {
		(self.table.pfn_vkCreateBufferView)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pView as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyBufferView(
		&self,
		bufferView                                   : VkBufferView,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyBufferView)(self.handle, bufferView, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createImage(
		&self,
		pCreateInfo                                  : &VkImageCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pImage                                       : &mut VkImage
	) -> VkResult {
		(self.table.pfn_vkCreateImage)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pImage as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyImage(
		&self,
		image                                        : VkImage,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyImage)(self.handle, image, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getImageSubresourceLayout(
		&self,
		image                                        : VkImage,
		pSubresource                                 : &VkImageSubresource,
		pLayout                                      : &mut VkSubresourceLayout
	) -> () {
		(self.table.pfn_vkGetImageSubresourceLayout)(self.handle, image, pSubresource as *const _ as _, pLayout as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createImageView(
		&self,
		pCreateInfo                                  : &VkImageViewCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pView                                        : &mut VkImageView
	) -> VkResult {
		(self.table.pfn_vkCreateImageView)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pView as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyImageView(
		&self,
		imageView                                    : VkImageView,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyImageView)(self.handle, imageView, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createShaderModule(
		&self,
		pCreateInfo                                  : &VkShaderModuleCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pShaderModule                                : &mut VkShaderModule
	) -> VkResult {
		(self.table.pfn_vkCreateShaderModule)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pShaderModule as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyShaderModule(
		&self,
		shaderModule                                 : VkShaderModule,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyShaderModule)(self.handle, shaderModule, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createPipelineCache(
		&self,
		pCreateInfo                                  : &VkPipelineCacheCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPipelineCache                               : &mut VkPipelineCache
	) -> VkResult {
		(self.table.pfn_vkCreatePipelineCache)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPipelineCache as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyPipelineCache(
		&self,
		pipelineCache                                : VkPipelineCache,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyPipelineCache)(self.handle, pipelineCache, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getPipelineCacheData(
		&self,
		pipelineCache                                : VkPipelineCache,
		pDataSize                                    : &mut usize,
		pData                                        : Option<&mut [u8]>
	) -> VkResult {
		(self.table.pfn_vkGetPipelineCacheData)(self.handle, pipelineCache, pDataSize, pData.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn mergePipelineCaches(
		&self,
		dstCache                                     : VkPipelineCache,
		pSrcCaches                                   : &[VkPipelineCache]
	) -> VkResult {
		(self.table.pfn_vkMergePipelineCaches)(self.handle, dstCache, pSrcCaches.len() as _, pSrcCaches.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createGraphicsPipelines(
		&self,
		pipelineCache                                : VkPipelineCache,
		pCreateInfos                                 : &[VkGraphicsPipelineCreateInfo],
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPipelines                                   : &mut [VkPipeline]
	) -> VkResult {
		(self.table.pfn_vkCreateGraphicsPipelines)(self.handle, pipelineCache, pPipelines.len() as _, pCreateInfos.as_ptr() as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPipelines.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createComputePipelines(
		&self,
		pipelineCache                                : VkPipelineCache,
		pCreateInfos                                 : &[VkComputePipelineCreateInfo],
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPipelines                                   : &mut [VkPipeline]
	) -> VkResult {
		(self.table.pfn_vkCreateComputePipelines)(self.handle, pipelineCache, pPipelines.len() as _, pCreateInfos.as_ptr() as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPipelines.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_HUAWEI_subpass_shading")]
	pub fn getSubpassShadingMaxWorkgroupSizeHUAWEI(
		&self,
		renderpass                                   : VkRenderPass,
		pMaxWorkgroupSize                            : &mut VkExtent2D
	) -> VkResult {
		(self.table.pfn_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)(self.handle, renderpass, pMaxWorkgroupSize as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyPipeline(
		&self,
		pipeline                                     : VkPipeline,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyPipeline)(self.handle, pipeline, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createPipelineLayout(
		&self,
		pCreateInfo                                  : &VkPipelineLayoutCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPipelineLayout                              : &mut VkPipelineLayout
	) -> VkResult {
		(self.table.pfn_vkCreatePipelineLayout)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPipelineLayout as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyPipelineLayout(
		&self,
		pipelineLayout                               : VkPipelineLayout,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyPipelineLayout)(self.handle, pipelineLayout, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createSampler(
		&self,
		pCreateInfo                                  : &VkSamplerCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSampler                                     : &mut VkSampler
	) -> VkResult {
		(self.table.pfn_vkCreateSampler)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSampler as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroySampler(
		&self,
		sampler                                      : VkSampler,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroySampler)(self.handle, sampler, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createDescriptorSetLayout(
		&self,
		pCreateInfo                                  : &VkDescriptorSetLayoutCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSetLayout                                   : &mut VkDescriptorSetLayout
	) -> VkResult {
		(self.table.pfn_vkCreateDescriptorSetLayout)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSetLayout as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyDescriptorSetLayout(
		&self,
		descriptorSetLayout                          : VkDescriptorSetLayout,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDescriptorSetLayout)(self.handle, descriptorSetLayout, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createDescriptorPool(
		&self,
		pCreateInfo                                  : &VkDescriptorPoolCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pDescriptorPool                              : &mut VkDescriptorPool
	) -> VkResult {
		(self.table.pfn_vkCreateDescriptorPool)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pDescriptorPool as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyDescriptorPool(
		&self,
		descriptorPool                               : VkDescriptorPool,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDescriptorPool)(self.handle, descriptorPool, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn resetDescriptorPool(
		&self,
		descriptorPool                               : VkDescriptorPool,
		flags                                        : VkDescriptorPoolResetFlags
	) -> VkResult {
		(self.table.pfn_vkResetDescriptorPool)(self.handle, descriptorPool, flags)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn allocateDescriptorSets(
		&self,
		pAllocateInfo                                : &VkDescriptorSetAllocateInfo,
		pDescriptorSets                              : &mut [VkDescriptorSet]
	) -> VkResult {
		(self.table.pfn_vkAllocateDescriptorSets)(self.handle, pAllocateInfo as *const _ as _, pDescriptorSets.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn freeDescriptorSets(
		&self,
		descriptorPool                               : VkDescriptorPool,
		pDescriptorSets                              : &[VkDescriptorSet]
	) -> VkResult {
		(self.table.pfn_vkFreeDescriptorSets)(self.handle, descriptorPool, pDescriptorSets.len() as _, pDescriptorSets.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn updateDescriptorSets(
		&self,
		pDescriptorWrites                            : &[VkWriteDescriptorSet],
		pDescriptorCopies                            : &[VkCopyDescriptorSet]
	) -> () {
		(self.table.pfn_vkUpdateDescriptorSets)(self.handle, pDescriptorWrites.len() as _, pDescriptorWrites.as_ptr() as _, pDescriptorCopies.len() as _, pDescriptorCopies.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createFramebuffer(
		&self,
		pCreateInfo                                  : &VkFramebufferCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pFramebuffer                                 : &mut VkFramebuffer
	) -> VkResult {
		(self.table.pfn_vkCreateFramebuffer)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pFramebuffer as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyFramebuffer(
		&self,
		framebuffer                                  : VkFramebuffer,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyFramebuffer)(self.handle, framebuffer, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createRenderPass(
		&self,
		pCreateInfo                                  : &VkRenderPassCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pRenderPass                                  : &mut VkRenderPass
	) -> VkResult {
		(self.table.pfn_vkCreateRenderPass)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pRenderPass as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyRenderPass(
		&self,
		renderPass                                   : VkRenderPass,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyRenderPass)(self.handle, renderPass, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn getRenderAreaGranularity(
		&self,
		renderPass                                   : VkRenderPass,
		pGranularity                                 : &mut VkExtent2D
	) -> () {
		(self.table.pfn_vkGetRenderAreaGranularity)(self.handle, renderPass, pGranularity as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn createCommandPool(
		&self,
		pCreateInfo                                  : &VkCommandPoolCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pCommandPool                                 : &mut VkCommandPool
	) -> VkResult {
		(self.table.pfn_vkCreateCommandPool)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pCommandPool as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroyCommandPool(
		&self,
		commandPool                                  : VkCommandPool,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyCommandPool)(self.handle, commandPool, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn resetCommandPool(
		&self,
		commandPool                                  : VkCommandPool,
		flags                                        : VkCommandPoolResetFlags
	) -> VkResult {
		(self.table.pfn_vkResetCommandPool)(self.handle, commandPool, flags)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn allocateCommandBuffers(
		&self,
		pAllocateInfo                                : &VkCommandBufferAllocateInfo,
		pCommandBuffers                              : &mut [VkCommandBuffer]
	) -> VkResult {
		(self.table.pfn_vkAllocateCommandBuffers)(self.handle, pAllocateInfo as *const _ as _, pCommandBuffers.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn freeCommandBuffers(
		&self,
		commandPool                                  : VkCommandPool,
		pCommandBuffers                              : &[VkCommandBuffer]
	) -> () {
		(self.table.pfn_vkFreeCommandBuffers)(self.handle, commandPool, pCommandBuffers.len() as _, pCommandBuffers.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_display_swapchain")]
	pub fn createSharedSwapchainsKHR(
		&self,
		pCreateInfos                                 : &[VkSwapchainCreateInfoKHR],
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSwapchains                                  : &mut [VkSwapchainKHR]
	) -> VkResult {
		(self.table.pfn_vkCreateSharedSwapchainsKHR)(self.handle, pSwapchains.len() as _, pCreateInfos.as_ptr() as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSwapchains.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_swapchain")]
	pub fn createSwapchainKHR(
		&self,
		pCreateInfo                                  : &VkSwapchainCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSwapchain                                   : &mut VkSwapchainKHR
	) -> VkResult {
		(self.table.pfn_vkCreateSwapchainKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSwapchain as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_swapchain")]
	pub fn destroySwapchainKHR(
		&self,
		swapchain                                    : VkSwapchainKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroySwapchainKHR)(self.handle, swapchain, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_KHR_swapchain")]
	pub fn getSwapchainImagesKHR(
		&self,
		swapchain                                    : VkSwapchainKHR,
		pSwapchainImageCount                         : &mut u32,
		pSwapchainImages                             : Option<&mut [VkImage]>
	) -> VkResult {
		(self.table.pfn_vkGetSwapchainImagesKHR)(self.handle, swapchain, pSwapchainImageCount, pSwapchainImages.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_swapchain")]
	pub fn acquireNextImageKHR(
		&self,
		swapchain                                    : VkSwapchainKHR,
		timeout                                      : u64,
		semaphore                                    : VkSemaphore,
		fence                                        : VkFence,
		pImageIndex                                  : &mut u32
	) -> VkResult {
		(self.table.pfn_vkAcquireNextImageKHR)(self.handle, swapchain, timeout, semaphore, fence, pImageIndex)
	}
	
	#[cfg(feature = "VK_EXT_debug_marker")]
	pub fn debugMarkerSetObjectNameEXT(
		&self,
		pNameInfo                                    : &VkDebugMarkerObjectNameInfoEXT
	) -> VkResult {
		(self.table.pfn_vkDebugMarkerSetObjectNameEXT)(self.handle, pNameInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_marker")]
	pub fn debugMarkerSetObjectTagEXT(
		&self,
		pTagInfo                                     : &VkDebugMarkerObjectTagInfoEXT
	) -> VkResult {
		(self.table.pfn_vkDebugMarkerSetObjectTagEXT)(self.handle, pTagInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NV_external_memory_win32")]
	pub fn getMemoryWin32HandleNV(
		&self,
		memory                                       : VkDeviceMemory,
		handleType                                   : VkExternalMemoryHandleTypeFlagsNV,
		pHandle                                      : &mut HANDLE
	) -> VkResult {
		(self.table.pfn_vkGetMemoryWin32HandleNV)(self.handle, memory, handleType, pHandle as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pub fn getGeneratedCommandsMemoryRequirementsNV(
		&self,
		pInfo                                        : &VkGeneratedCommandsMemoryRequirementsInfoNV,
		pMemoryRequirements                          : &mut VkMemoryRequirements2
	) -> () {
		(self.table.pfn_vkGetGeneratedCommandsMemoryRequirementsNV)(self.handle, pInfo as *const _ as _, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pub fn createIndirectCommandsLayoutNV(
		&self,
		pCreateInfo                                  : &VkIndirectCommandsLayoutCreateInfoNV,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pIndirectCommandsLayout                      : &mut VkIndirectCommandsLayoutNV
	) -> VkResult {
		(self.table.pfn_vkCreateIndirectCommandsLayoutNV)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pIndirectCommandsLayout as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pub fn destroyIndirectCommandsLayoutNV(
		&self,
		indirectCommandsLayout                       : VkIndirectCommandsLayoutNV,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyIndirectCommandsLayoutNV)(self.handle, indirectCommandsLayout, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn trimCommandPool(
		&self,
		commandPool                                  : VkCommandPool,
		flags                                        : VkCommandPoolTrimFlags
	) -> () {
		(self.table.pfn_vkTrimCommandPool)(self.handle, commandPool, flags)
	}
	
	#[cfg(feature = "VK_KHR_maintenance1")]
	pub fn trimCommandPoolKHR(
		&self,
		commandPool                                  : VkCommandPool,
		flags                                        : VkCommandPoolTrimFlags
	) -> () {
		(self.table.pfn_vkTrimCommandPoolKHR)(self.handle, commandPool, flags)
	}
	
	#[cfg(feature = "VK_KHR_external_memory_win32")]
	pub fn getMemoryWin32HandleKHR(
		&self,
		pGetWin32HandleInfo                          : &VkMemoryGetWin32HandleInfoKHR,
		pHandle                                      : &mut HANDLE
	) -> VkResult {
		(self.table.pfn_vkGetMemoryWin32HandleKHR)(self.handle, pGetWin32HandleInfo as *const _ as _, pHandle as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_memory_win32")]
	pub fn getMemoryWin32HandlePropertiesKHR(
		&self,
		handleType                                   : VkExternalMemoryHandleTypeFlagBits,
		handle                                       : HANDLE,
		pMemoryWin32HandleProperties                 : &mut VkMemoryWin32HandlePropertiesKHR
	) -> VkResult {
		(self.table.pfn_vkGetMemoryWin32HandlePropertiesKHR)(self.handle, handleType, handle, pMemoryWin32HandleProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_memory_fd")]
	pub fn getMemoryFdKHR(
		&self,
		pGetFdInfo                                   : &VkMemoryGetFdInfoKHR,
		pFd                                          : &mut i32
	) -> VkResult {
		(self.table.pfn_vkGetMemoryFdKHR)(self.handle, pGetFdInfo as *const _ as _, pFd)
	}
	
	#[cfg(feature = "VK_KHR_external_memory_fd")]
	pub fn getMemoryFdPropertiesKHR(
		&self,
		handleType                                   : VkExternalMemoryHandleTypeFlagBits,
		fd                                           : i32,
		pMemoryFdProperties                          : &mut VkMemoryFdPropertiesKHR
	) -> VkResult {
		(self.table.pfn_vkGetMemoryFdPropertiesKHR)(self.handle, handleType, fd, pMemoryFdProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_FUCHSIA_external_memory")]
	pub fn getMemoryZirconHandleFUCHSIA(
		&self,
		pGetZirconHandleInfo                         : &VkMemoryGetZirconHandleInfoFUCHSIA,
		pZirconHandle                                : &mut zx_handle_t
	) -> VkResult {
		(self.table.pfn_vkGetMemoryZirconHandleFUCHSIA)(self.handle, pGetZirconHandleInfo as *const _ as _, pZirconHandle as *mut _ as _)
	}
	
	#[cfg(feature = "VK_FUCHSIA_external_memory")]
	pub fn getMemoryZirconHandlePropertiesFUCHSIA(
		&self,
		handleType                                   : VkExternalMemoryHandleTypeFlagBits,
		zirconHandle                                 : zx_handle_t,
		pMemoryZirconHandleProperties                : &mut VkMemoryZirconHandlePropertiesFUCHSIA
	) -> VkResult {
		(self.table.pfn_vkGetMemoryZirconHandlePropertiesFUCHSIA)(self.handle, handleType, zirconHandle, pMemoryZirconHandleProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_external_memory_rdma")]
	pub fn getMemoryRemoteAddressNV(
		&self,
		getMemoryRemoteAddressInfo                   : &VkMemoryGetRemoteAddressInfoNV,
		pAddress                                     : &mut VkRemoteAddressNV
	) -> VkResult {
		(self.table.pfn_vkGetMemoryRemoteAddressNV)(self.handle, getMemoryRemoteAddressInfo as *const _ as _, pAddress as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_semaphore_win32")]
	pub fn getSemaphoreWin32HandleKHR(
		&self,
		pGetWin32HandleInfo                          : &VkSemaphoreGetWin32HandleInfoKHR,
		pHandle                                      : &mut HANDLE
	) -> VkResult {
		(self.table.pfn_vkGetSemaphoreWin32HandleKHR)(self.handle, pGetWin32HandleInfo as *const _ as _, pHandle as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_semaphore_win32")]
	pub fn importSemaphoreWin32HandleKHR(
		&self,
		pImportSemaphoreWin32HandleInfo              : &VkImportSemaphoreWin32HandleInfoKHR
	) -> VkResult {
		(self.table.pfn_vkImportSemaphoreWin32HandleKHR)(self.handle, pImportSemaphoreWin32HandleInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_semaphore_fd")]
	pub fn getSemaphoreFdKHR(
		&self,
		pGetFdInfo                                   : &VkSemaphoreGetFdInfoKHR,
		pFd                                          : &mut i32
	) -> VkResult {
		(self.table.pfn_vkGetSemaphoreFdKHR)(self.handle, pGetFdInfo as *const _ as _, pFd)
	}
	
	#[cfg(feature = "VK_KHR_external_semaphore_fd")]
	pub fn importSemaphoreFdKHR(
		&self,
		pImportSemaphoreFdInfo                       : &VkImportSemaphoreFdInfoKHR
	) -> VkResult {
		(self.table.pfn_vkImportSemaphoreFdKHR)(self.handle, pImportSemaphoreFdInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_FUCHSIA_external_semaphore")]
	pub fn getSemaphoreZirconHandleFUCHSIA(
		&self,
		pGetZirconHandleInfo                         : &VkSemaphoreGetZirconHandleInfoFUCHSIA,
		pZirconHandle                                : &mut zx_handle_t
	) -> VkResult {
		(self.table.pfn_vkGetSemaphoreZirconHandleFUCHSIA)(self.handle, pGetZirconHandleInfo as *const _ as _, pZirconHandle as *mut _ as _)
	}
	
	#[cfg(feature = "VK_FUCHSIA_external_semaphore")]
	pub fn importSemaphoreZirconHandleFUCHSIA(
		&self,
		pImportSemaphoreZirconHandleInfo             : &VkImportSemaphoreZirconHandleInfoFUCHSIA
	) -> VkResult {
		(self.table.pfn_vkImportSemaphoreZirconHandleFUCHSIA)(self.handle, pImportSemaphoreZirconHandleInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_fence_win32")]
	pub fn getFenceWin32HandleKHR(
		&self,
		pGetWin32HandleInfo                          : &VkFenceGetWin32HandleInfoKHR,
		pHandle                                      : &mut HANDLE
	) -> VkResult {
		(self.table.pfn_vkGetFenceWin32HandleKHR)(self.handle, pGetWin32HandleInfo as *const _ as _, pHandle as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_fence_win32")]
	pub fn importFenceWin32HandleKHR(
		&self,
		pImportFenceWin32HandleInfo                  : &VkImportFenceWin32HandleInfoKHR
	) -> VkResult {
		(self.table.pfn_vkImportFenceWin32HandleKHR)(self.handle, pImportFenceWin32HandleInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_external_fence_fd")]
	pub fn getFenceFdKHR(
		&self,
		pGetFdInfo                                   : &VkFenceGetFdInfoKHR,
		pFd                                          : &mut i32
	) -> VkResult {
		(self.table.pfn_vkGetFenceFdKHR)(self.handle, pGetFdInfo as *const _ as _, pFd)
	}
	
	#[cfg(feature = "VK_KHR_external_fence_fd")]
	pub fn importFenceFdKHR(
		&self,
		pImportFenceFdInfo                           : &VkImportFenceFdInfoKHR
	) -> VkResult {
		(self.table.pfn_vkImportFenceFdKHR)(self.handle, pImportFenceFdInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_display_control")]
	pub fn displayPowerControlEXT(
		&self,
		display                                      : VkDisplayKHR,
		pDisplayPowerInfo                            : &VkDisplayPowerInfoEXT
	) -> VkResult {
		(self.table.pfn_vkDisplayPowerControlEXT)(self.handle, display, pDisplayPowerInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_display_control")]
	pub fn registerEventEXT(
		&self,
		pDeviceEventInfo                             : &VkDeviceEventInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pFence                                       : &mut VkFence
	) -> VkResult {
		(self.table.pfn_vkRegisterDeviceEventEXT)(self.handle, pDeviceEventInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pFence as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_display_control")]
	pub fn registerDisplayEventEXT(
		&self,
		display                                      : VkDisplayKHR,
		pDisplayEventInfo                            : &VkDisplayEventInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pFence                                       : &mut VkFence
	) -> VkResult {
		(self.table.pfn_vkRegisterDisplayEventEXT)(self.handle, display, pDisplayEventInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pFence as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_display_control")]
	pub fn getSwapchainCounterEXT(
		&self,
		swapchain                                    : VkSwapchainKHR,
		counter                                      : VkSurfaceCounterFlagBitsEXT,
		pCounterValue                                : &mut u64
	) -> VkResult {
		(self.table.pfn_vkGetSwapchainCounterEXT)(self.handle, swapchain, counter, pCounterValue)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getGroupPeerMemoryFeatures(
		&self,
		heapIndex                                    : u32,
		localDeviceIndex                             : u32,
		remoteDeviceIndex                            : u32,
		pPeerMemoryFeatures                          : &mut VkPeerMemoryFeatureFlags
	) -> () {
		(self.table.pfn_vkGetDeviceGroupPeerMemoryFeatures)(self.handle, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn getGroupPeerMemoryFeaturesKHR(
		&self,
		heapIndex                                    : u32,
		localDeviceIndex                             : u32,
		remoteDeviceIndex                            : u32,
		pPeerMemoryFeatures                          : &mut VkPeerMemoryFeatureFlags
	) -> () {
		(self.table.pfn_vkGetDeviceGroupPeerMemoryFeaturesKHR)(self.handle, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn bindBufferMemory2(
		&self,
		pBindInfos                                   : &[VkBindBufferMemoryInfo]
	) -> VkResult {
		(self.table.pfn_vkBindBufferMemory2)(self.handle, pBindInfos.len() as _, pBindInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_bind_memory2")]
	pub fn bindBufferMemory2KHR(
		&self,
		pBindInfos                                   : &[VkBindBufferMemoryInfo]
	) -> VkResult {
		(self.table.pfn_vkBindBufferMemory2KHR)(self.handle, pBindInfos.len() as _, pBindInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn bindImageMemory2(
		&self,
		pBindInfos                                   : &[VkBindImageMemoryInfo]
	) -> VkResult {
		(self.table.pfn_vkBindImageMemory2)(self.handle, pBindInfos.len() as _, pBindInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_bind_memory2")]
	pub fn bindImageMemory2KHR(
		&self,
		pBindInfos                                   : &[VkBindImageMemoryInfo]
	) -> VkResult {
		(self.table.pfn_vkBindImageMemory2KHR)(self.handle, pBindInfos.len() as _, pBindInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn getGroupPresentCapabilitiesKHR(
		&self,
		pDeviceGroupPresentCapabilities              : &mut VkDeviceGroupPresentCapabilitiesKHR
	) -> VkResult {
		(self.table.pfn_vkGetDeviceGroupPresentCapabilitiesKHR)(self.handle, pDeviceGroupPresentCapabilities as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn getGroupSurfacePresentModesKHR(
		&self,
		surface                                      : VkSurfaceKHR,
		pModes                                       : &mut VkDeviceGroupPresentModeFlagsKHR
	) -> VkResult {
		(self.table.pfn_vkGetDeviceGroupSurfacePresentModesKHR)(self.handle, surface, pModes as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn acquireNextImage2KHR(
		&self,
		pAcquireInfo                                 : &VkAcquireNextImageInfoKHR,
		pImageIndex                                  : &mut u32
	) -> VkResult {
		(self.table.pfn_vkAcquireNextImage2KHR)(self.handle, pAcquireInfo as *const _ as _, pImageIndex)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn createDescriptorUpdateTemplate(
		&self,
		pCreateInfo                                  : &VkDescriptorUpdateTemplateCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pDescriptorUpdateTemplate                    : &mut VkDescriptorUpdateTemplate
	) -> VkResult {
		(self.table.pfn_vkCreateDescriptorUpdateTemplate)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pDescriptorUpdateTemplate as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pub fn createDescriptorUpdateTemplateKHR(
		&self,
		pCreateInfo                                  : &VkDescriptorUpdateTemplateCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pDescriptorUpdateTemplate                    : &mut VkDescriptorUpdateTemplate
	) -> VkResult {
		(self.table.pfn_vkCreateDescriptorUpdateTemplateKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pDescriptorUpdateTemplate as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn destroyDescriptorUpdateTemplate(
		&self,
		descriptorUpdateTemplate                     : VkDescriptorUpdateTemplate,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDescriptorUpdateTemplate)(self.handle, descriptorUpdateTemplate, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pub fn destroyDescriptorUpdateTemplateKHR(
		&self,
		descriptorUpdateTemplate                     : VkDescriptorUpdateTemplate,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDescriptorUpdateTemplateKHR)(self.handle, descriptorUpdateTemplate, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn updateDescriptorSetWithTemplate(
		&self,
		descriptorSet                                : VkDescriptorSet,
		descriptorUpdateTemplate                     : VkDescriptorUpdateTemplate,
		pData                                        : VkAnyRef
	) -> () {
		(self.table.pfn_vkUpdateDescriptorSetWithTemplate)(self.handle, descriptorSet, descriptorUpdateTemplate, (pData).into())
	}
	
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pub fn updateDescriptorSetWithTemplateKHR(
		&self,
		descriptorSet                                : VkDescriptorSet,
		descriptorUpdateTemplate                     : VkDescriptorUpdateTemplate,
		pData                                        : VkAnyRef
	) -> () {
		(self.table.pfn_vkUpdateDescriptorSetWithTemplateKHR)(self.handle, descriptorSet, descriptorUpdateTemplate, (pData).into())
	}
	
	#[cfg(feature = "VK_EXT_hdr_metadata")]
	pub fn setHdrMetadataEXT(
		&self,
		pSwapchains                                  : &[VkSwapchainKHR],
		pMetadata                                    : &[VkHdrMetadataEXT]
	) -> () {
		(self.table.pfn_vkSetHdrMetadataEXT)(self.handle, pMetadata.len() as _, pSwapchains.as_ptr() as _, pMetadata.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_shared_presentable_image")]
	pub fn getSwapchainStatusKHR(
		&self,
		swapchain                                    : VkSwapchainKHR
	) -> VkResult {
		(self.table.pfn_vkGetSwapchainStatusKHR)(self.handle, swapchain)
	}
	
	#[cfg(feature = "VK_GOOGLE_display_timing")]
	pub fn getRefreshCycleDurationGOOGLE(
		&self,
		swapchain                                    : VkSwapchainKHR,
		pDisplayTimingProperties                     : &mut VkRefreshCycleDurationGOOGLE
	) -> VkResult {
		(self.table.pfn_vkGetRefreshCycleDurationGOOGLE)(self.handle, swapchain, pDisplayTimingProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_GOOGLE_display_timing")]
	pub fn getPastPresentationTimingGOOGLE(
		&self,
		swapchain                                    : VkSwapchainKHR,
		pPresentationTimingCount                     : &mut u32,
		pPresentationTimings                         : Option<&mut [VkPastPresentationTimingGOOGLE]>
	) -> VkResult {
		(self.table.pfn_vkGetPastPresentationTimingGOOGLE)(self.handle, swapchain, pPresentationTimingCount, pPresentationTimings.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getBufferMemoryRequirements2(
		&self,
		pInfo                                        : &VkBufferMemoryRequirementsInfo2,
		pMemoryRequirements                          : &mut VkMemoryRequirements2
	) -> () {
		(self.table.pfn_vkGetBufferMemoryRequirements2)(self.handle, pInfo as *const _ as _, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_memory_requirements2")]
	pub fn getBufferMemoryRequirements2KHR(
		&self,
		pInfo                                        : &VkBufferMemoryRequirementsInfo2,
		pMemoryRequirements                          : &mut VkMemoryRequirements2
	) -> () {
		(self.table.pfn_vkGetBufferMemoryRequirements2KHR)(self.handle, pInfo as *const _ as _, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getImageMemoryRequirements2(
		&self,
		pInfo                                        : &VkImageMemoryRequirementsInfo2,
		pMemoryRequirements                          : &mut VkMemoryRequirements2
	) -> () {
		(self.table.pfn_vkGetImageMemoryRequirements2)(self.handle, pInfo as *const _ as _, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_get_memory_requirements2")]
	pub fn getImageMemoryRequirements2KHR(
		&self,
		pInfo                                        : &VkImageMemoryRequirementsInfo2,
		pMemoryRequirements                          : &mut VkMemoryRequirements2
	) -> () {
		(self.table.pfn_vkGetImageMemoryRequirements2KHR)(self.handle, pInfo as *const _ as _, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getImageSparseMemoryRequirements2(
		&self,
		pInfo                                        : &VkImageSparseMemoryRequirementsInfo2,
		pSparseMemoryRequirementCount                : &mut u32,
		pSparseMemoryRequirements                    : Option<&mut [VkSparseImageMemoryRequirements2]>
	) -> () {
		(self.table.pfn_vkGetImageSparseMemoryRequirements2)(self.handle, pInfo as *const _ as _, pSparseMemoryRequirementCount, pSparseMemoryRequirements.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_get_memory_requirements2")]
	pub fn getImageSparseMemoryRequirements2KHR(
		&self,
		pInfo                                        : &VkImageSparseMemoryRequirementsInfo2,
		pSparseMemoryRequirementCount                : &mut u32,
		pSparseMemoryRequirements                    : Option<&mut [VkSparseImageMemoryRequirements2]>
	) -> () {
		(self.table.pfn_vkGetImageSparseMemoryRequirements2KHR)(self.handle, pInfo as *const _ as _, pSparseMemoryRequirementCount, pSparseMemoryRequirements.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn createSamplerYcbcrConversion(
		&self,
		pCreateInfo                                  : &VkSamplerYcbcrConversionCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pYcbcrConversion                             : &mut VkSamplerYcbcrConversion
	) -> VkResult {
		(self.table.pfn_vkCreateSamplerYcbcrConversion)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pYcbcrConversion as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
	pub fn createSamplerYcbcrConversionKHR(
		&self,
		pCreateInfo                                  : &VkSamplerYcbcrConversionCreateInfo,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pYcbcrConversion                             : &mut VkSamplerYcbcrConversion
	) -> VkResult {
		(self.table.pfn_vkCreateSamplerYcbcrConversionKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pYcbcrConversion as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn destroySamplerYcbcrConversion(
		&self,
		ycbcrConversion                              : VkSamplerYcbcrConversion,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroySamplerYcbcrConversion)(self.handle, ycbcrConversion, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
	pub fn destroySamplerYcbcrConversionKHR(
		&self,
		ycbcrConversion                              : VkSamplerYcbcrConversion,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroySamplerYcbcrConversionKHR)(self.handle, ycbcrConversion, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getQueue2(
		&self,
		pQueueInfo                                   : &VkDeviceQueueInfo2,
		pQueue                                       : &mut VkQueue
	) -> () {
		(self.table.pfn_vkGetDeviceQueue2)(self.handle, pQueueInfo as *const _ as _, pQueue as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_validation_cache")]
	pub fn createValidationCacheEXT(
		&self,
		pCreateInfo                                  : &VkValidationCacheCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pValidationCache                             : &mut VkValidationCacheEXT
	) -> VkResult {
		(self.table.pfn_vkCreateValidationCacheEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pValidationCache as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_validation_cache")]
	pub fn destroyValidationCacheEXT(
		&self,
		validationCache                              : VkValidationCacheEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyValidationCacheEXT)(self.handle, validationCache, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_EXT_validation_cache")]
	pub fn getValidationCacheDataEXT(
		&self,
		validationCache                              : VkValidationCacheEXT,
		pDataSize                                    : &mut usize,
		pData                                        : Option<&mut [u8]>
	) -> VkResult {
		(self.table.pfn_vkGetValidationCacheDataEXT)(self.handle, validationCache, pDataSize, pData.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_validation_cache")]
	pub fn mergeValidationCachesEXT(
		&self,
		dstCache                                     : VkValidationCacheEXT,
		pSrcCaches                                   : &[VkValidationCacheEXT]
	) -> VkResult {
		(self.table.pfn_vkMergeValidationCachesEXT)(self.handle, dstCache, pSrcCaches.len() as _, pSrcCaches.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn getDescriptorSetLayoutSupport(
		&self,
		pCreateInfo                                  : &VkDescriptorSetLayoutCreateInfo,
		pSupport                                     : &mut VkDescriptorSetLayoutSupport
	) -> () {
		(self.table.pfn_vkGetDescriptorSetLayoutSupport)(self.handle, pCreateInfo as *const _ as _, pSupport as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_maintenance3")]
	pub fn getDescriptorSetLayoutSupportKHR(
		&self,
		pCreateInfo                                  : &VkDescriptorSetLayoutCreateInfo,
		pSupport                                     : &mut VkDescriptorSetLayoutSupport
	) -> () {
		(self.table.pfn_vkGetDescriptorSetLayoutSupportKHR)(self.handle, pCreateInfo as *const _ as _, pSupport as *mut _ as _)
	}
	
	pub fn getSwapchainGrallocUsageANDROID(
		&self,
		format                                       : VkFormat,
		imageUsage                                   : VkImageUsageFlags,
		grallocUsage                                 : &mut i32
	) -> VkResult {
		(self.table.pfn_vkGetSwapchainGrallocUsageANDROID)(self.handle, format, imageUsage, grallocUsage)
	}
	
	pub fn getSwapchainGrallocUsage2ANDROID(
		&self,
		format                                       : VkFormat,
		imageUsage                                   : VkImageUsageFlags,
		swapchainImageUsage                          : VkSwapchainImageUsageFlagsANDROID,
		grallocConsumerUsage                         : &mut u64,
		grallocProducerUsage                         : &mut u64
	) -> VkResult {
		(self.table.pfn_vkGetSwapchainGrallocUsage2ANDROID)(self.handle, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage)
	}
	
	pub fn acquireImageANDROID(
		&self,
		image                                        : VkImage,
		nativeFenceFd                                : i32,
		semaphore                                    : VkSemaphore,
		fence                                        : VkFence
	) -> VkResult {
		(self.table.pfn_vkAcquireImageANDROID)(self.handle, image, nativeFenceFd, semaphore, fence)
	}
	
	#[cfg(feature = "VK_AMD_shader_info")]
	pub fn getShaderInfoAMD(
		&self,
		pipeline                                     : VkPipeline,
		shaderStage                                  : VkShaderStageFlagBits,
		infoType                                     : VkShaderInfoTypeAMD,
		pInfoSize                                    : &mut usize,
		pInfo                                        : Option<&mut [u8]>
	) -> VkResult {
		(self.table.pfn_vkGetShaderInfoAMD)(self.handle, pipeline, shaderStage, infoType, pInfoSize, pInfo.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_AMD_display_native_hdr")]
	pub fn setLocalDimmingAMD(
		&self,
		swapChain                                    : VkSwapchainKHR,
		localDimmingEnable                           : VkBool32
	) -> () {
		(self.table.pfn_vkSetLocalDimmingAMD)(self.handle, swapChain, localDimmingEnable)
	}
	
	#[cfg(feature = "VK_EXT_calibrated_timestamps")]
	pub fn getCalibratedTimestampsEXT(
		&self,
		pTimestampInfos                              : &[VkCalibratedTimestampInfoEXT],
		pTimestamps                                  : &mut [u64],
		pMaxDeviation                                : &mut u64
	) -> VkResult {
		(self.table.pfn_vkGetCalibratedTimestampsEXT)(self.handle, pTimestamps.len() as _, pTimestampInfos.as_ptr() as _, pTimestamps.as_mut_ptr() as _, pMaxDeviation)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn setDebugUtilsObjectNameEXT(
		&self,
		pNameInfo                                    : &VkDebugUtilsObjectNameInfoEXT
	) -> VkResult {
		(self.table.pfn_vkSetDebugUtilsObjectNameEXT)(self.handle, pNameInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn setDebugUtilsObjectTagEXT(
		&self,
		pTagInfo                                     : &VkDebugUtilsObjectTagInfoEXT
	) -> VkResult {
		(self.table.pfn_vkSetDebugUtilsObjectTagEXT)(self.handle, pTagInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_external_memory_host")]
	pub fn getMemoryHostPointerPropertiesEXT(
		&self,
		handleType                                   : VkExternalMemoryHandleTypeFlagBits,
		pHostPointer                                 : VkAnyRef,
		pMemoryHostPointerProperties                 : &mut VkMemoryHostPointerPropertiesEXT
	) -> VkResult {
		(self.table.pfn_vkGetMemoryHostPointerPropertiesEXT)(self.handle, handleType, (pHostPointer).into(), pMemoryHostPointerProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn createRenderPass2(
		&self,
		pCreateInfo                                  : &VkRenderPassCreateInfo2,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pRenderPass                                  : &mut VkRenderPass
	) -> VkResult {
		(self.table.pfn_vkCreateRenderPass2)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pRenderPass as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pub fn createRenderPass2KHR(
		&self,
		pCreateInfo                                  : &VkRenderPassCreateInfo2,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pRenderPass                                  : &mut VkRenderPass
	) -> VkResult {
		(self.table.pfn_vkCreateRenderPass2KHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pRenderPass as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn getSemaphoreCounterValue(
		&self,
		semaphore                                    : VkSemaphore,
		pValue                                       : &mut u64
	) -> VkResult {
		(self.table.pfn_vkGetSemaphoreCounterValue)(self.handle, semaphore, pValue)
	}
	
	#[cfg(feature = "VK_KHR_timeline_semaphore")]
	pub fn getSemaphoreCounterValueKHR(
		&self,
		semaphore                                    : VkSemaphore,
		pValue                                       : &mut u64
	) -> VkResult {
		(self.table.pfn_vkGetSemaphoreCounterValueKHR)(self.handle, semaphore, pValue)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn waitSemaphores(
		&self,
		pWaitInfo                                    : &VkSemaphoreWaitInfo,
		timeout                                      : u64
	) -> VkResult {
		(self.table.pfn_vkWaitSemaphores)(self.handle, pWaitInfo as *const _ as _, timeout)
	}
	
	#[cfg(feature = "VK_KHR_timeline_semaphore")]
	pub fn waitSemaphoresKHR(
		&self,
		pWaitInfo                                    : &VkSemaphoreWaitInfo,
		timeout                                      : u64
	) -> VkResult {
		(self.table.pfn_vkWaitSemaphoresKHR)(self.handle, pWaitInfo as *const _ as _, timeout)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn signalSemaphore(
		&self,
		pSignalInfo                                  : &VkSemaphoreSignalInfo
	) -> VkResult {
		(self.table.pfn_vkSignalSemaphore)(self.handle, pSignalInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_timeline_semaphore")]
	pub fn signalSemaphoreKHR(
		&self,
		pSignalInfo                                  : &VkSemaphoreSignalInfo
	) -> VkResult {
		(self.table.pfn_vkSignalSemaphoreKHR)(self.handle, pSignalInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
	pub fn getAndroidHardwareBufferPropertiesANDROID(
		&self,
		buffer                                       : &AHardwareBuffer,
		pProperties                                  : &mut VkAndroidHardwareBufferPropertiesANDROID
	) -> VkResult {
		(self.table.pfn_vkGetAndroidHardwareBufferPropertiesANDROID)(self.handle, buffer as *const _ as _, pProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
	pub fn getMemoryAndroidHardwareBufferANDROID(
		&self,
		pInfo                                        : &VkMemoryGetAndroidHardwareBufferInfoANDROID,
		pBuffer                                      : &mut &mut AHardwareBuffer
	) -> VkResult {
		(self.table.pfn_vkGetMemoryAndroidHardwareBufferANDROID)(self.handle, pInfo as *const _ as _, pBuffer as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn compileDeferredNV(
		&self,
		pipeline                                     : VkPipeline,
		shader                                       : u32
	) -> VkResult {
		(self.table.pfn_vkCompileDeferredNV)(self.handle, pipeline, shader)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn createAccelerationStructureNV(
		&self,
		pCreateInfo                                  : &VkAccelerationStructureCreateInfoNV,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pAccelerationStructure                       : &mut VkAccelerationStructureNV
	) -> VkResult {
		(self.table.pfn_vkCreateAccelerationStructureNV)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pAccelerationStructure as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn destroyAccelerationStructureKHR(
		&self,
		accelerationStructure                        : VkAccelerationStructureKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyAccelerationStructureKHR)(self.handle, accelerationStructure, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn destroyAccelerationStructureNV(
		&self,
		accelerationStructure                        : VkAccelerationStructureNV,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyAccelerationStructureNV)(self.handle, accelerationStructure, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn getAccelerationStructureMemoryRequirementsNV(
		&self,
		pInfo                                        : &VkAccelerationStructureMemoryRequirementsInfoNV,
		pMemoryRequirements                          : &mut VkMemoryRequirements2KHR
	) -> () {
		(self.table.pfn_vkGetAccelerationStructureMemoryRequirementsNV)(self.handle, pInfo as *const _ as _, pMemoryRequirements as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn bindAccelerationStructureMemoryNV(
		&self,
		pBindInfos                                   : &[VkBindAccelerationStructureMemoryInfoNV]
	) -> VkResult {
		(self.table.pfn_vkBindAccelerationStructureMemoryNV)(self.handle, pBindInfos.len() as _, pBindInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn copyAccelerationStructureKHR(
		&self,
		deferredOperation                            : VkDeferredOperationKHR,
		pInfo                                        : &VkCopyAccelerationStructureInfoKHR
	) -> VkResult {
		(self.table.pfn_vkCopyAccelerationStructureKHR)(self.handle, deferredOperation, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn copyAccelerationStructureToMemoryKHR(
		&self,
		deferredOperation                            : VkDeferredOperationKHR,
		pInfo                                        : &VkCopyAccelerationStructureToMemoryInfoKHR
	) -> VkResult {
		(self.table.pfn_vkCopyAccelerationStructureToMemoryKHR)(self.handle, deferredOperation, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn copyMemoryToAccelerationStructureKHR(
		&self,
		deferredOperation                            : VkDeferredOperationKHR,
		pInfo                                        : &VkCopyMemoryToAccelerationStructureInfoKHR
	) -> VkResult {
		(self.table.pfn_vkCopyMemoryToAccelerationStructureKHR)(self.handle, deferredOperation, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn writeAccelerationStructuresPropertiesKHR(
		&self,
		pAccelerationStructures                      : &[VkAccelerationStructureKHR],
		queryType                                    : VkQueryType,
		pData                                        : &mut [u8],
		stride                                       : usize
	) -> VkResult {
		(self.table.pfn_vkWriteAccelerationStructuresPropertiesKHR)(self.handle, pAccelerationStructures.len() as _, pAccelerationStructures.as_ptr() as _, queryType, pData.len() as _, pData.as_mut_ptr() as _, stride)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn getRayTracingShaderGroupHandlesKHR(
		&self,
		pipeline                                     : VkPipeline,
		firstGroup                                   : u32,
		groupCount                                   : u32,
		pData                                        : &mut [u8]
	) -> VkResult {
		(self.table.pfn_vkGetRayTracingShaderGroupHandlesKHR)(self.handle, pipeline, firstGroup, groupCount, pData.len() as _, pData.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn getRayTracingShaderGroupHandlesNV(
		&self,
		pipeline                                     : VkPipeline,
		firstGroup                                   : u32,
		groupCount                                   : u32,
		pData                                        : &mut [u8]
	) -> VkResult {
		(self.table.pfn_vkGetRayTracingShaderGroupHandlesNV)(self.handle, pipeline, firstGroup, groupCount, pData.len() as _, pData.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn getRayTracingCaptureReplayShaderGroupHandlesKHR(
		&self,
		pipeline                                     : VkPipeline,
		firstGroup                                   : u32,
		groupCount                                   : u32,
		pData                                        : &mut [u8]
	) -> VkResult {
		(self.table.pfn_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)(self.handle, pipeline, firstGroup, groupCount, pData.len() as _, pData.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn getAccelerationStructureHandleNV(
		&self,
		accelerationStructure                        : VkAccelerationStructureNV,
		pData                                        : &mut [u8]
	) -> VkResult {
		(self.table.pfn_vkGetAccelerationStructureHandleNV)(self.handle, accelerationStructure, pData.len() as _, pData.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn createRayTracingPipelinesNV(
		&self,
		pipelineCache                                : VkPipelineCache,
		pCreateInfos                                 : &[VkRayTracingPipelineCreateInfoNV],
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPipelines                                   : &mut [VkPipeline]
	) -> VkResult {
		(self.table.pfn_vkCreateRayTracingPipelinesNV)(self.handle, pipelineCache, pPipelines.len() as _, pCreateInfos.as_ptr() as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPipelines.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn createRayTracingPipelinesKHR(
		&self,
		deferredOperation                            : VkDeferredOperationKHR,
		pipelineCache                                : VkPipelineCache,
		pCreateInfos                                 : &[VkRayTracingPipelineCreateInfoKHR],
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPipelines                                   : &mut [VkPipeline]
	) -> VkResult {
		(self.table.pfn_vkCreateRayTracingPipelinesKHR)(self.handle, deferredOperation, pipelineCache, pPipelines.len() as _, pCreateInfos.as_ptr() as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPipelines.as_mut_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn getAccelerationStructureCompatibilityKHR(
		&self,
		pVersionInfo                                 : &VkAccelerationStructureVersionInfoKHR,
		pCompatibility                               : &mut VkAccelerationStructureCompatibilityKHR
	) -> () {
		(self.table.pfn_vkGetDeviceAccelerationStructureCompatibilityKHR)(self.handle, pVersionInfo as *const _ as _, pCompatibility as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn getRayTracingShaderGroupStackSizeKHR(
		&self,
		pipeline                                     : VkPipeline,
		group                                        : u32,
		groupShader                                  : VkShaderGroupShaderKHR
	) -> VkDeviceSize {
		(self.table.pfn_vkGetRayTracingShaderGroupStackSizeKHR)(self.handle, pipeline, group, groupShader)
	}
	
	#[cfg(feature = "VK_NVX_image_view_handle")]
	pub fn getImageViewHandleNVX(
		&self,
		pInfo                                        : &VkImageViewHandleInfoNVX
	) -> u32 {
		(self.table.pfn_vkGetImageViewHandleNVX)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NVX_image_view_handle")]
	pub fn getImageViewAddressNVX(
		&self,
		imageView                                    : VkImageView,
		pProperties                                  : &mut VkImageViewAddressPropertiesNVX
	) -> VkResult {
		(self.table.pfn_vkGetImageViewAddressNVX)(self.handle, imageView, pProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pub fn getGroupSurfacePresentModes2EXT(
		&self,
		pSurfaceInfo                                 : &VkPhysicalDeviceSurfaceInfo2KHR,
		pModes                                       : &mut VkDeviceGroupPresentModeFlagsKHR
	) -> VkResult {
		(self.table.pfn_vkGetDeviceGroupSurfacePresentModes2EXT)(self.handle, pSurfaceInfo as *const _ as _, pModes as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pub fn acquireFullScreenExclusiveModeEXT(
		&self,
		swapchain                                    : VkSwapchainKHR
	) -> VkResult {
		(self.table.pfn_vkAcquireFullScreenExclusiveModeEXT)(self.handle, swapchain)
	}
	
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pub fn releaseFullScreenExclusiveModeEXT(
		&self,
		swapchain                                    : VkSwapchainKHR
	) -> VkResult {
		(self.table.pfn_vkReleaseFullScreenExclusiveModeEXT)(self.handle, swapchain)
	}
	
	#[cfg(feature = "VK_KHR_performance_query")]
	pub fn acquireProfilingLockKHR(
		&self,
		pInfo                                        : &VkAcquireProfilingLockInfoKHR
	) -> VkResult {
		(self.table.pfn_vkAcquireProfilingLockKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_performance_query")]
	pub fn releaseProfilingLockKHR(
		&self
	) -> () {
		(self.table.pfn_vkReleaseProfilingLockKHR)(self.handle)
	}
	
	#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
	pub fn getImageDrmFormatModifierPropertiesEXT(
		&self,
		image                                        : VkImage,
		pProperties                                  : &mut VkImageDrmFormatModifierPropertiesEXT
	) -> VkResult {
		(self.table.pfn_vkGetImageDrmFormatModifierPropertiesEXT)(self.handle, image, pProperties as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn getBufferOpaqueCaptureAddress(
		&self,
		pInfo                                        : &VkBufferDeviceAddressInfo
	) -> u64 {
		(self.table.pfn_vkGetBufferOpaqueCaptureAddress)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_buffer_device_address")]
	pub fn getBufferOpaqueCaptureAddressKHR(
		&self,
		pInfo                                        : &VkBufferDeviceAddressInfo
	) -> u64 {
		(self.table.pfn_vkGetBufferOpaqueCaptureAddressKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn getBufferAddress(
		&self,
		pInfo                                        : &VkBufferDeviceAddressInfo
	) -> VkDeviceAddress {
		(self.table.pfn_vkGetBufferDeviceAddress)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_buffer_device_address")]
	pub fn getBufferAddressKHR(
		&self,
		pInfo                                        : &VkBufferDeviceAddressInfo
	) -> VkDeviceAddress {
		(self.table.pfn_vkGetBufferDeviceAddressKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_buffer_device_address")]
	pub fn getBufferAddressEXT(
		&self,
		pInfo                                        : &VkBufferDeviceAddressInfo
	) -> VkDeviceAddress {
		(self.table.pfn_vkGetBufferDeviceAddressEXT)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn initializePerformanceApiINTEL(
		&self,
		pInitializeInfo                              : &VkInitializePerformanceApiInfoINTEL
	) -> VkResult {
		(self.table.pfn_vkInitializePerformanceApiINTEL)(self.handle, pInitializeInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn uninitializePerformanceApiINTEL(
		&self
	) -> () {
		(self.table.pfn_vkUninitializePerformanceApiINTEL)(self.handle)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn acquirePerformanceConfigurationINTEL(
		&self,
		pAcquireInfo                                 : &VkPerformanceConfigurationAcquireInfoINTEL,
		pConfiguration                               : &mut VkPerformanceConfigurationINTEL
	) -> VkResult {
		(self.table.pfn_vkAcquirePerformanceConfigurationINTEL)(self.handle, pAcquireInfo as *const _ as _, pConfiguration as *mut _ as _)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn releasePerformanceConfigurationINTEL(
		&self,
		configuration                                : VkPerformanceConfigurationINTEL
	) -> VkResult {
		(self.table.pfn_vkReleasePerformanceConfigurationINTEL)(self.handle, configuration)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn getPerformanceParameterINTEL(
		&self,
		parameter                                    : VkPerformanceParameterTypeINTEL,
		pValue                                       : &mut VkPerformanceValueINTEL
	) -> VkResult {
		(self.table.pfn_vkGetPerformanceParameterINTEL)(self.handle, parameter, pValue as *mut _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn getMemoryOpaqueCaptureAddress(
		&self,
		pInfo                                        : &VkDeviceMemoryOpaqueCaptureAddressInfo
	) -> u64 {
		(self.table.pfn_vkGetDeviceMemoryOpaqueCaptureAddress)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_buffer_device_address")]
	pub fn getMemoryOpaqueCaptureAddressKHR(
		&self,
		pInfo                                        : &VkDeviceMemoryOpaqueCaptureAddressInfo
	) -> u64 {
		(self.table.pfn_vkGetDeviceMemoryOpaqueCaptureAddressKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
	pub fn getPipelineExecutablePropertiesKHR(
		&self,
		pPipelineInfo                                : &VkPipelineInfoKHR,
		pExecutableCount                             : &mut u32,
		pProperties                                  : Option<&mut [VkPipelineExecutablePropertiesKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPipelineExecutablePropertiesKHR)(self.handle, pPipelineInfo as *const _ as _, pExecutableCount, pProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
	pub fn getPipelineExecutableStatisticsKHR(
		&self,
		pExecutableInfo                              : &VkPipelineExecutableInfoKHR,
		pStatisticCount                              : &mut u32,
		pStatistics                                  : Option<&mut [VkPipelineExecutableStatisticKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPipelineExecutableStatisticsKHR)(self.handle, pExecutableInfo as *const _ as _, pStatisticCount, pStatistics.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
	pub fn getPipelineExecutableInternalRepresentationsKHR(
		&self,
		pExecutableInfo                              : &VkPipelineExecutableInfoKHR,
		pInternalRepresentationCount                 : &mut u32,
		pInternalRepresentations                     : Option<&mut [VkPipelineExecutableInternalRepresentationKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetPipelineExecutableInternalRepresentationsKHR)(self.handle, pExecutableInfo as *const _ as _, pInternalRepresentationCount, pInternalRepresentations.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn createAccelerationStructureKHR(
		&self,
		pCreateInfo                                  : &VkAccelerationStructureCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pAccelerationStructure                       : &mut VkAccelerationStructureKHR
	) -> VkResult {
		(self.table.pfn_vkCreateAccelerationStructureKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pAccelerationStructure as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn buildAccelerationStructuresKHR(
		&self,
		deferredOperation                            : VkDeferredOperationKHR,
		pInfos                                       : &[VkAccelerationStructureBuildGeometryInfoKHR],
		ppBuildRangeInfos                            : &[&VkAccelerationStructureBuildRangeInfoKHR]
	) -> VkResult {
		(self.table.pfn_vkBuildAccelerationStructuresKHR)(self.handle, deferredOperation, ppBuildRangeInfos.len() as _, pInfos.as_ptr() as _, ppBuildRangeInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn getAccelerationStructureAddressKHR(
		&self,
		pInfo                                        : &VkAccelerationStructureDeviceAddressInfoKHR
	) -> VkDeviceAddress {
		(self.table.pfn_vkGetAccelerationStructureDeviceAddressKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pub fn createDeferredOperationKHR(
		&self,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pDeferredOperation                           : &mut VkDeferredOperationKHR
	) -> VkResult {
		(self.table.pfn_vkCreateDeferredOperationKHR)(self.handle, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pDeferredOperation as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pub fn destroyDeferredOperationKHR(
		&self,
		operation                                    : VkDeferredOperationKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDeferredOperationKHR)(self.handle, operation, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pub fn getDeferredOperationMaxConcurrencyKHR(
		&self,
		operation                                    : VkDeferredOperationKHR
	) -> u32 {
		(self.table.pfn_vkGetDeferredOperationMaxConcurrencyKHR)(self.handle, operation)
	}
	
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pub fn getDeferredOperationResultKHR(
		&self,
		operation                                    : VkDeferredOperationKHR
	) -> VkResult {
		(self.table.pfn_vkGetDeferredOperationResultKHR)(self.handle, operation)
	}
	
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pub fn deferredOperationJoinKHR(
		&self,
		operation                                    : VkDeferredOperationKHR
	) -> VkResult {
		(self.table.pfn_vkDeferredOperationJoinKHR)(self.handle, operation)
	}
	
	#[cfg(feature = "VK_EXT_private_data")]
	pub fn createPrivateDataSlotEXT(
		&self,
		pCreateInfo                                  : &VkPrivateDataSlotCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pPrivateDataSlot                             : &mut VkPrivateDataSlotEXT
	) -> VkResult {
		(self.table.pfn_vkCreatePrivateDataSlotEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pPrivateDataSlot as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_private_data")]
	pub fn destroyPrivateDataSlotEXT(
		&self,
		privateDataSlot                              : VkPrivateDataSlotEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyPrivateDataSlotEXT)(self.handle, privateDataSlot, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_EXT_private_data")]
	pub fn setPrivateDataEXT(
		&self,
		objectType                                   : VkObjectType,
		objectHandle                                 : u64,
		privateDataSlot                              : VkPrivateDataSlotEXT,
		data                                         : u64
	) -> VkResult {
		(self.table.pfn_vkSetPrivateDataEXT)(self.handle, objectType, objectHandle, privateDataSlot, data)
	}
	
	#[cfg(feature = "VK_EXT_private_data")]
	pub fn getPrivateDataEXT(
		&self,
		objectType                                   : VkObjectType,
		objectHandle                                 : u64,
		privateDataSlot                              : VkPrivateDataSlotEXT,
		pData                                        : &mut u64
	) -> () {
		(self.table.pfn_vkGetPrivateDataEXT)(self.handle, objectType, objectHandle, privateDataSlot, pData)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn getAccelerationStructureBuildSizesKHR(
		&self,
		buildType                                    : VkAccelerationStructureBuildTypeKHR,
		pBuildInfo                                   : &VkAccelerationStructureBuildGeometryInfoKHR,
		pMaxPrimitiveCounts                          : Option<&[u32]>,
		pSizeInfo                                    : &mut VkAccelerationStructureBuildSizesInfoKHR
	) -> () {
		(self.table.pfn_vkGetAccelerationStructureBuildSizesKHR)(self.handle, buildType, pBuildInfo as *const _ as _, pMaxPrimitiveCounts.map_or(std::ptr::null(), <[_]>::as_ptr) as _, pSizeInfo as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn createVideoSessionKHR(
		&self,
		pCreateInfo                                  : &VkVideoSessionCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pVideoSession                                : &mut VkVideoSessionKHR
	) -> VkResult {
		(self.table.pfn_vkCreateVideoSessionKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pVideoSession as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn destroyVideoSessionKHR(
		&self,
		videoSession                                 : VkVideoSessionKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyVideoSessionKHR)(self.handle, videoSession, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn createVideoSessionParametersKHR(
		&self,
		pCreateInfo                                  : &VkVideoSessionParametersCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pVideoSessionParameters                      : &mut VkVideoSessionParametersKHR
	) -> VkResult {
		(self.table.pfn_vkCreateVideoSessionParametersKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pVideoSessionParameters as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn updateVideoSessionParametersKHR(
		&self,
		videoSessionParameters                       : VkVideoSessionParametersKHR,
		pUpdateInfo                                  : &VkVideoSessionParametersUpdateInfoKHR
	) -> VkResult {
		(self.table.pfn_vkUpdateVideoSessionParametersKHR)(self.handle, videoSessionParameters, pUpdateInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn destroyVideoSessionParametersKHR(
		&self,
		videoSessionParameters                       : VkVideoSessionParametersKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyVideoSessionParametersKHR)(self.handle, videoSessionParameters, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn getVideoSessionMemoryRequirementsKHR(
		&self,
		videoSession                                 : VkVideoSessionKHR,
		pVideoSessionMemoryRequirementsCount         : &mut u32,
		pVideoSessionMemoryRequirements              : Option<&mut [VkVideoGetMemoryPropertiesKHR]>
	) -> VkResult {
		(self.table.pfn_vkGetVideoSessionMemoryRequirementsKHR)(self.handle, videoSession, pVideoSessionMemoryRequirementsCount, pVideoSessionMemoryRequirements.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn bindVideoSessionMemoryKHR(
		&self,
		videoSession                                 : VkVideoSessionKHR,
		pVideoSessionBindMemories                    : &[VkVideoBindMemoryKHR]
	) -> VkResult {
		(self.table.pfn_vkBindVideoSessionMemoryKHR)(self.handle, videoSession, pVideoSessionBindMemories.len() as _, pVideoSessionBindMemories.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_NVX_binary_import")]
	pub fn createCuModuleNVX(
		&self,
		pCreateInfo                                  : &VkCuModuleCreateInfoNVX,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pModule                                      : &mut VkCuModuleNVX
	) -> VkResult {
		(self.table.pfn_vkCreateCuModuleNVX)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pModule as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NVX_binary_import")]
	pub fn createCuFunctionNVX(
		&self,
		pCreateInfo                                  : &VkCuFunctionCreateInfoNVX,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pFunction                                    : &mut VkCuFunctionNVX
	) -> VkResult {
		(self.table.pfn_vkCreateCuFunctionNVX)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pFunction as *mut _ as _)
	}
	
	#[cfg(feature = "VK_NVX_binary_import")]
	pub fn destroyCuModuleNVX(
		&self,
		module                                       : VkCuModuleNVX,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyCuModuleNVX)(self.handle, module, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_NVX_binary_import")]
	pub fn destroyCuFunctionNVX(
		&self,
		function                                     : VkCuFunctionNVX,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyCuFunctionNVX)(self.handle, function, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
}

/// Wrapper for a `VkPipeline` handle
#[derive(Clone, Debug)]
pub struct VkPipelineImpl {
	pub handle: VkPipeline,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkPipelineImpl {
	type Target = VkPipeline;
	
	#[inline]
	fn deref(&self) -> &VkPipeline { &self.handle }
}

impl fmt::Display for VkPipelineImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkPipelineImpl {
	pub fn new(handle: VkPipeline, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkPipelineCache` handle
#[derive(Clone, Debug)]
pub struct VkPipelineCacheImpl {
	pub handle: VkPipelineCache,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkPipelineCacheImpl {
	type Target = VkPipelineCache;
	
	#[inline]
	fn deref(&self) -> &VkPipelineCache { &self.handle }
}

impl fmt::Display for VkPipelineCacheImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkPipelineCacheImpl {
	pub fn new(handle: VkPipelineCache, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkQueryPool` handle
#[derive(Clone, Debug)]
pub struct VkQueryPoolImpl {
	pub handle: VkQueryPool,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkQueryPoolImpl {
	type Target = VkQueryPool;
	
	#[inline]
	fn deref(&self) -> &VkQueryPool { &self.handle }
}

impl fmt::Display for VkQueryPoolImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkQueryPoolImpl {
	pub fn new(handle: VkQueryPool, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkImageView` handle
#[derive(Clone, Debug)]
pub struct VkImageViewImpl {
	pub handle: VkImageView,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkImageViewImpl {
	type Target = VkImageView;
	
	#[inline]
	fn deref(&self) -> &VkImageView { &self.handle }
}

impl fmt::Display for VkImageViewImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkImageViewImpl {
	pub fn new(handle: VkImageView, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkSamplerYcbcrConversionKHR` handle
#[derive(Clone, Debug)]
pub struct VkSamplerYcbcrConversionKHRImpl {
	pub handle: VkSamplerYcbcrConversionKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkSamplerYcbcrConversionKHRImpl {
	type Target = VkSamplerYcbcrConversionKHR;
	
	#[inline]
	fn deref(&self) -> &VkSamplerYcbcrConversionKHR { &self.handle }
}

impl fmt::Display for VkSamplerYcbcrConversionKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkSamplerYcbcrConversionKHRImpl {
	pub fn new(handle: VkSamplerYcbcrConversionKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkCommandPool` handle
#[derive(Clone, Debug)]
pub struct VkCommandPoolImpl {
	pub handle: VkCommandPool,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkCommandPoolImpl {
	type Target = VkCommandPool;
	
	#[inline]
	fn deref(&self) -> &VkCommandPool { &self.handle }
}

impl fmt::Display for VkCommandPoolImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkCommandPoolImpl {
	pub fn new(handle: VkCommandPool, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkBufferView` handle
#[derive(Clone, Debug)]
pub struct VkBufferViewImpl {
	pub handle: VkBufferView,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkBufferViewImpl {
	type Target = VkBufferView;
	
	#[inline]
	fn deref(&self) -> &VkBufferView { &self.handle }
}

impl fmt::Display for VkBufferViewImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkBufferViewImpl {
	pub fn new(handle: VkBufferView, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDescriptorUpdateTemplate` handle
#[derive(Clone, Debug)]
pub struct VkDescriptorUpdateTemplateImpl {
	pub handle: VkDescriptorUpdateTemplate,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDescriptorUpdateTemplateImpl {
	type Target = VkDescriptorUpdateTemplate;
	
	#[inline]
	fn deref(&self) -> &VkDescriptorUpdateTemplate { &self.handle }
}

impl fmt::Display for VkDescriptorUpdateTemplateImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDescriptorUpdateTemplateImpl {
	pub fn new(handle: VkDescriptorUpdateTemplate, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkEvent` handle
#[derive(Clone, Debug)]
pub struct VkEventImpl {
	pub handle: VkEvent,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkEventImpl {
	type Target = VkEvent;
	
	#[inline]
	fn deref(&self) -> &VkEvent { &self.handle }
}

impl fmt::Display for VkEventImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkEventImpl {
	pub fn new(handle: VkEvent, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkQueue` handle
#[derive(Clone, Debug)]
pub struct VkQueueImpl {
	pub handle: VkQueue,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkQueueImpl {
	type Target = VkQueue;
	
	#[inline]
	fn deref(&self) -> &VkQueue { &self.handle }
}

impl fmt::Display for VkQueueImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkQueueImpl {
	pub fn new(handle: VkQueue, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn submit(
		&self,
		pSubmits                                     : &[VkSubmitInfo],
		fence                                        : VkFence
	) -> VkResult {
		(self.table.pfn_vkQueueSubmit)(self.handle, pSubmits.len() as _, pSubmits.as_ptr() as _, fence)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn waitIdle(
		&self
	) -> VkResult {
		(self.table.pfn_vkQueueWaitIdle)(self.handle)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn bindSparse(
		&self,
		pBindInfo                                    : &[VkBindSparseInfo],
		fence                                        : VkFence
	) -> VkResult {
		(self.table.pfn_vkQueueBindSparse)(self.handle, pBindInfo.len() as _, pBindInfo.as_ptr() as _, fence)
	}
	
	#[cfg(feature = "VK_KHR_swapchain")]
	pub fn presentKHR(
		&self,
		pPresentInfo                                 : &VkPresentInfoKHR
	) -> VkResult {
		(self.table.pfn_vkQueuePresentKHR)(self.handle, pPresentInfo as *const _ as _)
	}
	
	pub fn signalReleaseImageANDROID(
		&self,
		pWaitSemaphores                              : &[VkSemaphore],
		image                                        : VkImage,
		pNativeFenceFd                               : &mut i32
	) -> VkResult {
		(self.table.pfn_vkQueueSignalReleaseImageANDROID)(self.handle, pWaitSemaphores.len() as _, pWaitSemaphores.as_ptr() as _, image, pNativeFenceFd)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn beginDebugUtilsLabelEXT(
		&self,
		pLabelInfo                                   : &VkDebugUtilsLabelEXT
	) -> () {
		(self.table.pfn_vkQueueBeginDebugUtilsLabelEXT)(self.handle, pLabelInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn endDebugUtilsLabelEXT(
		&self
	) -> () {
		(self.table.pfn_vkQueueEndDebugUtilsLabelEXT)(self.handle)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn insertDebugUtilsLabelEXT(
		&self,
		pLabelInfo                                   : &VkDebugUtilsLabelEXT
	) -> () {
		(self.table.pfn_vkQueueInsertDebugUtilsLabelEXT)(self.handle, pLabelInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
	pub fn getCheckpointDataNV(
		&self,
		pCheckpointDataCount                         : &mut u32,
		pCheckpointData                              : Option<&mut [VkCheckpointDataNV]>
	) -> () {
		(self.table.pfn_vkGetQueueCheckpointDataNV)(self.handle, pCheckpointDataCount, pCheckpointData.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn setPerformanceConfigurationINTEL(
		&self,
		configuration                                : VkPerformanceConfigurationINTEL
	) -> VkResult {
		(self.table.pfn_vkQueueSetPerformanceConfigurationINTEL)(self.handle, configuration)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn submit2KHR(
		&self,
		pSubmits                                     : &[VkSubmitInfo2KHR],
		fence                                        : VkFence
	) -> VkResult {
		(self.table.pfn_vkQueueSubmit2KHR)(self.handle, pSubmits.len() as _, pSubmits.as_ptr() as _, fence)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn getCheckpointData2NV(
		&self,
		pCheckpointDataCount                         : &mut u32,
		pCheckpointData                              : Option<&mut [VkCheckpointData2NV]>
	) -> () {
		(self.table.pfn_vkGetQueueCheckpointData2NV)(self.handle, pCheckpointDataCount, pCheckpointData.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
}

/// Wrapper for a `VkSurfaceKHR` handle
#[derive(Clone, Debug)]
pub struct VkSurfaceKHRImpl {
	pub handle: VkSurfaceKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkSurfaceKHRImpl {
	type Target = VkSurfaceKHR;
	
	#[inline]
	fn deref(&self) -> &VkSurfaceKHR { &self.handle }
}

impl fmt::Display for VkSurfaceKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkSurfaceKHRImpl {
	pub fn new(handle: VkSurfaceKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDebugReportCallbackEXT` handle
#[derive(Clone, Debug)]
pub struct VkDebugReportCallbackEXTImpl {
	pub handle: VkDebugReportCallbackEXT,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDebugReportCallbackEXTImpl {
	type Target = VkDebugReportCallbackEXT;
	
	#[inline]
	fn deref(&self) -> &VkDebugReportCallbackEXT { &self.handle }
}

impl fmt::Display for VkDebugReportCallbackEXTImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDebugReportCallbackEXTImpl {
	pub fn new(handle: VkDebugReportCallbackEXT, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkImage` handle
#[derive(Clone, Debug)]
pub struct VkImageImpl {
	pub handle: VkImage,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkImageImpl {
	type Target = VkImage;
	
	#[inline]
	fn deref(&self) -> &VkImage { &self.handle }
}

impl fmt::Display for VkImageImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkImageImpl {
	pub fn new(handle: VkImage, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkSamplerYcbcrConversion` handle
#[derive(Clone, Debug)]
pub struct VkSamplerYcbcrConversionImpl {
	pub handle: VkSamplerYcbcrConversion,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkSamplerYcbcrConversionImpl {
	type Target = VkSamplerYcbcrConversion;
	
	#[inline]
	fn deref(&self) -> &VkSamplerYcbcrConversion { &self.handle }
}

impl fmt::Display for VkSamplerYcbcrConversionImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkSamplerYcbcrConversionImpl {
	pub fn new(handle: VkSamplerYcbcrConversion, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkAccelerationStructureNV` handle
#[derive(Clone, Debug)]
pub struct VkAccelerationStructureNVImpl {
	pub handle: VkAccelerationStructureNV,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkAccelerationStructureNVImpl {
	type Target = VkAccelerationStructureNV;
	
	#[inline]
	fn deref(&self) -> &VkAccelerationStructureNV { &self.handle }
}

impl fmt::Display for VkAccelerationStructureNVImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkAccelerationStructureNVImpl {
	pub fn new(handle: VkAccelerationStructureNV, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDescriptorSetLayout` handle
#[derive(Clone, Debug)]
pub struct VkDescriptorSetLayoutImpl {
	pub handle: VkDescriptorSetLayout,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDescriptorSetLayoutImpl {
	type Target = VkDescriptorSetLayout;
	
	#[inline]
	fn deref(&self) -> &VkDescriptorSetLayout { &self.handle }
}

impl fmt::Display for VkDescriptorSetLayoutImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDescriptorSetLayoutImpl {
	pub fn new(handle: VkDescriptorSetLayout, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkShaderModule` handle
#[derive(Clone, Debug)]
pub struct VkShaderModuleImpl {
	pub handle: VkShaderModule,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkShaderModuleImpl {
	type Target = VkShaderModule;
	
	#[inline]
	fn deref(&self) -> &VkShaderModule { &self.handle }
}

impl fmt::Display for VkShaderModuleImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkShaderModuleImpl {
	pub fn new(handle: VkShaderModule, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkCuModuleNVX` handle
#[derive(Clone, Debug)]
pub struct VkCuModuleNVXImpl {
	pub handle: VkCuModuleNVX,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkCuModuleNVXImpl {
	type Target = VkCuModuleNVX;
	
	#[inline]
	fn deref(&self) -> &VkCuModuleNVX { &self.handle }
}

impl fmt::Display for VkCuModuleNVXImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkCuModuleNVXImpl {
	pub fn new(handle: VkCuModuleNVX, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDescriptorUpdateTemplateKHR` handle
#[derive(Clone, Debug)]
pub struct VkDescriptorUpdateTemplateKHRImpl {
	pub handle: VkDescriptorUpdateTemplateKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDescriptorUpdateTemplateKHRImpl {
	type Target = VkDescriptorUpdateTemplateKHR;
	
	#[inline]
	fn deref(&self) -> &VkDescriptorUpdateTemplateKHR { &self.handle }
}

impl fmt::Display for VkDescriptorUpdateTemplateKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDescriptorUpdateTemplateKHRImpl {
	pub fn new(handle: VkDescriptorUpdateTemplateKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkPerformanceConfigurationINTEL` handle
#[derive(Clone, Debug)]
pub struct VkPerformanceConfigurationINTELImpl {
	pub handle: VkPerformanceConfigurationINTEL,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkPerformanceConfigurationINTELImpl {
	type Target = VkPerformanceConfigurationINTEL;
	
	#[inline]
	fn deref(&self) -> &VkPerformanceConfigurationINTEL { &self.handle }
}

impl fmt::Display for VkPerformanceConfigurationINTELImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkPerformanceConfigurationINTELImpl {
	pub fn new(handle: VkPerformanceConfigurationINTEL, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDeviceMemory` handle
#[derive(Clone, Debug)]
pub struct VkDeviceMemoryImpl {
	pub handle: VkDeviceMemory,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDeviceMemoryImpl {
	type Target = VkDeviceMemory;
	
	#[inline]
	fn deref(&self) -> &VkDeviceMemory { &self.handle }
}

impl fmt::Display for VkDeviceMemoryImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDeviceMemoryImpl {
	pub fn new(handle: VkDeviceMemory, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkCuFunctionNVX` handle
#[derive(Clone, Debug)]
pub struct VkCuFunctionNVXImpl {
	pub handle: VkCuFunctionNVX,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkCuFunctionNVXImpl {
	type Target = VkCuFunctionNVX;
	
	#[inline]
	fn deref(&self) -> &VkCuFunctionNVX { &self.handle }
}

impl fmt::Display for VkCuFunctionNVXImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkCuFunctionNVXImpl {
	pub fn new(handle: VkCuFunctionNVX, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDebugUtilsMessengerEXT` handle
#[derive(Clone, Debug)]
pub struct VkDebugUtilsMessengerEXTImpl {
	pub handle: VkDebugUtilsMessengerEXT,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDebugUtilsMessengerEXTImpl {
	type Target = VkDebugUtilsMessengerEXT;
	
	#[inline]
	fn deref(&self) -> &VkDebugUtilsMessengerEXT { &self.handle }
}

impl fmt::Display for VkDebugUtilsMessengerEXTImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDebugUtilsMessengerEXTImpl {
	pub fn new(handle: VkDebugUtilsMessengerEXT, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkFence` handle
#[derive(Clone, Debug)]
pub struct VkFenceImpl {
	pub handle: VkFence,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkFenceImpl {
	type Target = VkFence;
	
	#[inline]
	fn deref(&self) -> &VkFence { &self.handle }
}

impl fmt::Display for VkFenceImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkFenceImpl {
	pub fn new(handle: VkFence, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkCommandBuffer` handle
#[derive(Clone, Debug)]
pub struct VkCommandBufferImpl {
	pub handle: VkCommandBuffer,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkCommandBufferImpl {
	type Target = VkCommandBuffer;
	
	#[inline]
	fn deref(&self) -> &VkCommandBuffer { &self.handle }
}

impl fmt::Display for VkCommandBufferImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkCommandBufferImpl {
	pub fn new(handle: VkCommandBuffer, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn begin(
		&self,
		pBeginInfo                                   : &VkCommandBufferBeginInfo
	) -> VkResult {
		(self.table.pfn_vkBeginCommandBuffer)(self.handle, pBeginInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn end(
		&self
	) -> VkResult {
		(self.table.pfn_vkEndCommandBuffer)(self.handle)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn reset(
		&self,
		flags                                        : VkCommandBufferResetFlags
	) -> VkResult {
		(self.table.pfn_vkResetCommandBuffer)(self.handle, flags)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBindPipeline(
		&self,
		pipelineBindPoint                            : VkPipelineBindPoint,
		pipeline                                     : VkPipeline
	) -> () {
		(self.table.pfn_vkCmdBindPipeline)(self.handle, pipelineBindPoint, pipeline)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetViewport(
		&self,
		firstViewport                                : u32,
		pViewports                                   : &[VkViewport]
	) -> () {
		(self.table.pfn_vkCmdSetViewport)(self.handle, firstViewport, pViewports.len() as _, pViewports.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetScissor(
		&self,
		firstScissor                                 : u32,
		pScissors                                    : &[VkRect2D]
	) -> () {
		(self.table.pfn_vkCmdSetScissor)(self.handle, firstScissor, pScissors.len() as _, pScissors.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetLineWidth(
		&self,
		lineWidth                                    : f32
	) -> () {
		(self.table.pfn_vkCmdSetLineWidth)(self.handle, lineWidth)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetDepthBias(
		&self,
		depthBiasConstantFactor                      : f32,
		depthBiasClamp                               : f32,
		depthBiasSlopeFactor                         : f32
	) -> () {
		(self.table.pfn_vkCmdSetDepthBias)(self.handle, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetBlendConstants(
		&self,
		blendConstants                               : [f32;  4 as usize]
	) -> () {
		(self.table.pfn_vkCmdSetBlendConstants)(self.handle, blendConstants)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetDepthBounds(
		&self,
		minDepthBounds                               : f32,
		maxDepthBounds                               : f32
	) -> () {
		(self.table.pfn_vkCmdSetDepthBounds)(self.handle, minDepthBounds, maxDepthBounds)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetStencilCompareMask(
		&self,
		faceMask                                     : VkStencilFaceFlags,
		compareMask                                  : u32
	) -> () {
		(self.table.pfn_vkCmdSetStencilCompareMask)(self.handle, faceMask, compareMask)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetStencilWriteMask(
		&self,
		faceMask                                     : VkStencilFaceFlags,
		writeMask                                    : u32
	) -> () {
		(self.table.pfn_vkCmdSetStencilWriteMask)(self.handle, faceMask, writeMask)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetStencilReference(
		&self,
		faceMask                                     : VkStencilFaceFlags,
		reference                                    : u32
	) -> () {
		(self.table.pfn_vkCmdSetStencilReference)(self.handle, faceMask, reference)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBindDescriptorSets(
		&self,
		pipelineBindPoint                            : VkPipelineBindPoint,
		layout                                       : VkPipelineLayout,
		firstSet                                     : u32,
		pDescriptorSets                              : &[VkDescriptorSet],
		pDynamicOffsets                              : &[u32]
	) -> () {
		(self.table.pfn_vkCmdBindDescriptorSets)(self.handle, pipelineBindPoint, layout, firstSet, pDescriptorSets.len() as _, pDescriptorSets.as_ptr() as _, pDynamicOffsets.len() as _, pDynamicOffsets.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBindIndexBuffer(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		indexType                                    : VkIndexType
	) -> () {
		(self.table.pfn_vkCmdBindIndexBuffer)(self.handle, buffer, offset, indexType)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBindVertexBuffers(
		&self,
		firstBinding                                 : u32,
		pBuffers                                     : &[VkBuffer],
		pOffsets                                     : &[VkDeviceSize]
	) -> () {
		(self.table.pfn_vkCmdBindVertexBuffers)(self.handle, firstBinding, pOffsets.len() as _, pBuffers.as_ptr() as _, pOffsets.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdDraw(
		&self,
		vertexCount                                  : u32,
		instanceCount                                : u32,
		firstVertex                                  : u32,
		firstInstance                                : u32
	) -> () {
		(self.table.pfn_vkCmdDraw)(self.handle, vertexCount, instanceCount, firstVertex, firstInstance)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdDrawIndexed(
		&self,
		indexCount                                   : u32,
		instanceCount                                : u32,
		firstIndex                                   : u32,
		vertexOffset                                 : i32,
		firstInstance                                : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndexed)(self.handle, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
	}
	
	#[cfg(feature = "VK_EXT_multi_draw")]
	pub fn cmdDrawMultiEXT(
		&self,
		pVertexInfo                                  : &[VkMultiDrawInfoEXT],
		instanceCount                                : u32,
		firstInstance                                : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawMultiEXT)(self.handle, pVertexInfo.len() as _, pVertexInfo.as_ptr() as _, instanceCount, firstInstance, stride)
	}
	
	#[cfg(feature = "VK_EXT_multi_draw")]
	pub fn cmdDrawMultiIndexedEXT(
		&self,
		pIndexInfo                                   : &[VkMultiDrawIndexedInfoEXT],
		instanceCount                                : u32,
		firstInstance                                : u32,
		stride                                       : u32,
		pVertexOffset                                : Option<&i32>
	) -> () {
		(self.table.pfn_vkCmdDrawMultiIndexedEXT)(self.handle, pIndexInfo.len() as _, pIndexInfo.as_ptr() as _, instanceCount, firstInstance, stride, pVertexOffset.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdDrawIndirect(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		drawCount                                    : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndirect)(self.handle, buffer, offset, drawCount, stride)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdDrawIndexedIndirect(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		drawCount                                    : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndexedIndirect)(self.handle, buffer, offset, drawCount, stride)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdDispatch(
		&self,
		groupCountX                                  : u32,
		groupCountY                                  : u32,
		groupCountZ                                  : u32
	) -> () {
		(self.table.pfn_vkCmdDispatch)(self.handle, groupCountX, groupCountY, groupCountZ)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdDispatchIndirect(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize
	) -> () {
		(self.table.pfn_vkCmdDispatchIndirect)(self.handle, buffer, offset)
	}
	
	#[cfg(feature = "VK_HUAWEI_subpass_shading")]
	pub fn cmdSubpassShadingHUAWEI(
		&self
	) -> () {
		(self.table.pfn_vkCmdSubpassShadingHUAWEI)(self.handle)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdCopyBuffer(
		&self,
		srcBuffer                                    : VkBuffer,
		dstBuffer                                    : VkBuffer,
		pRegions                                     : &[VkBufferCopy]
	) -> () {
		(self.table.pfn_vkCmdCopyBuffer)(self.handle, srcBuffer, dstBuffer, pRegions.len() as _, pRegions.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdCopyImage(
		&self,
		srcImage                                     : VkImage,
		srcImageLayout                               : VkImageLayout,
		dstImage                                     : VkImage,
		dstImageLayout                               : VkImageLayout,
		pRegions                                     : &[VkImageCopy]
	) -> () {
		(self.table.pfn_vkCmdCopyImage)(self.handle, srcImage, srcImageLayout, dstImage, dstImageLayout, pRegions.len() as _, pRegions.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBlitImage(
		&self,
		srcImage                                     : VkImage,
		srcImageLayout                               : VkImageLayout,
		dstImage                                     : VkImage,
		dstImageLayout                               : VkImageLayout,
		pRegions                                     : &[VkImageBlit],
		filter                                       : VkFilter
	) -> () {
		(self.table.pfn_vkCmdBlitImage)(self.handle, srcImage, srcImageLayout, dstImage, dstImageLayout, pRegions.len() as _, pRegions.as_ptr() as _, filter)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdCopyBufferToImage(
		&self,
		srcBuffer                                    : VkBuffer,
		dstImage                                     : VkImage,
		dstImageLayout                               : VkImageLayout,
		pRegions                                     : &[VkBufferImageCopy]
	) -> () {
		(self.table.pfn_vkCmdCopyBufferToImage)(self.handle, srcBuffer, dstImage, dstImageLayout, pRegions.len() as _, pRegions.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdCopyImageToBuffer(
		&self,
		srcImage                                     : VkImage,
		srcImageLayout                               : VkImageLayout,
		dstBuffer                                    : VkBuffer,
		pRegions                                     : &[VkBufferImageCopy]
	) -> () {
		(self.table.pfn_vkCmdCopyImageToBuffer)(self.handle, srcImage, srcImageLayout, dstBuffer, pRegions.len() as _, pRegions.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdUpdateBuffer(
		&self,
		dstBuffer                                    : VkBuffer,
		dstOffset                                    : VkDeviceSize,
		dataSize                                     : VkDeviceSize,
		pData                                        : &[u8]
	) -> () {
		(self.table.pfn_vkCmdUpdateBuffer)(self.handle, dstBuffer, dstOffset, dataSize, pData.as_ptr() as _)
	}
	
	/// transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdFillBuffer(
		&self,
		dstBuffer                                    : VkBuffer,
		dstOffset                                    : VkDeviceSize,
		size                                         : VkDeviceSize,
		data                                         : u32
	) -> () {
		(self.table.pfn_vkCmdFillBuffer)(self.handle, dstBuffer, dstOffset, size, data)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdClearColorImage(
		&self,
		image                                        : VkImage,
		imageLayout                                  : VkImageLayout,
		pColor                                       : &VkClearColorValue,
		pRanges                                      : &[VkImageSubresourceRange]
	) -> () {
		(self.table.pfn_vkCmdClearColorImage)(self.handle, image, imageLayout, pColor as *const _ as _, pRanges.len() as _, pRanges.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdClearDepthStencilImage(
		&self,
		image                                        : VkImage,
		imageLayout                                  : VkImageLayout,
		pDepthStencil                                : &VkClearDepthStencilValue,
		pRanges                                      : &[VkImageSubresourceRange]
	) -> () {
		(self.table.pfn_vkCmdClearDepthStencilImage)(self.handle, image, imageLayout, pDepthStencil as *const _ as _, pRanges.len() as _, pRanges.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdClearAttachments(
		&self,
		pAttachments                                 : &[VkClearAttachment],
		pRects                                       : &[VkClearRect]
	) -> () {
		(self.table.pfn_vkCmdClearAttachments)(self.handle, pAttachments.len() as _, pAttachments.as_ptr() as _, pRects.len() as _, pRects.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdResolveImage(
		&self,
		srcImage                                     : VkImage,
		srcImageLayout                               : VkImageLayout,
		dstImage                                     : VkImage,
		dstImageLayout                               : VkImageLayout,
		pRegions                                     : &[VkImageResolve]
	) -> () {
		(self.table.pfn_vkCmdResolveImage)(self.handle, srcImage, srcImageLayout, dstImage, dstImageLayout, pRegions.len() as _, pRegions.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdSetEvent(
		&self,
		event                                        : VkEvent,
		stageMask                                    : VkPipelineStageFlags
	) -> () {
		(self.table.pfn_vkCmdSetEvent)(self.handle, event, stageMask)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdResetEvent(
		&self,
		event                                        : VkEvent,
		stageMask                                    : VkPipelineStageFlags
	) -> () {
		(self.table.pfn_vkCmdResetEvent)(self.handle, event, stageMask)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdWaitEvents(
		&self,
		pEvents                                      : &[VkEvent],
		srcStageMask                                 : VkPipelineStageFlags,
		dstStageMask                                 : VkPipelineStageFlags,
		pMemoryBarriers                              : &[VkMemoryBarrier],
		pBufferMemoryBarriers                        : &[VkBufferMemoryBarrier],
		pImageMemoryBarriers                         : &[VkImageMemoryBarrier]
	) -> () {
		(self.table.pfn_vkCmdWaitEvents)(self.handle, pEvents.len() as _, pEvents.as_ptr() as _, srcStageMask, dstStageMask, pMemoryBarriers.len() as _, pMemoryBarriers.as_ptr() as _, pBufferMemoryBarriers.len() as _, pBufferMemoryBarriers.as_ptr() as _, pImageMemoryBarriers.len() as _, pImageMemoryBarriers.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdPipelineBarrier(
		&self,
		srcStageMask                                 : VkPipelineStageFlags,
		dstStageMask                                 : VkPipelineStageFlags,
		dependencyFlags                              : VkDependencyFlags,
		pMemoryBarriers                              : &[VkMemoryBarrier],
		pBufferMemoryBarriers                        : &[VkBufferMemoryBarrier],
		pImageMemoryBarriers                         : &[VkImageMemoryBarrier]
	) -> () {
		(self.table.pfn_vkCmdPipelineBarrier)(self.handle, srcStageMask, dstStageMask, dependencyFlags, pMemoryBarriers.len() as _, pMemoryBarriers.as_ptr() as _, pBufferMemoryBarriers.len() as _, pBufferMemoryBarriers.as_ptr() as _, pImageMemoryBarriers.len() as _, pImageMemoryBarriers.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBeginQuery(
		&self,
		queryPool                                    : VkQueryPool,
		query                                        : u32,
		flags                                        : VkQueryControlFlags
	) -> () {
		(self.table.pfn_vkCmdBeginQuery)(self.handle, queryPool, query, flags)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdEndQuery(
		&self,
		queryPool                                    : VkQueryPool,
		query                                        : u32
	) -> () {
		(self.table.pfn_vkCmdEndQuery)(self.handle, queryPool, query)
	}
	
	#[cfg(feature = "VK_EXT_conditional_rendering")]
	pub fn cmdBeginConditionalRenderingEXT(
		&self,
		pConditionalRenderingBegin                   : &VkConditionalRenderingBeginInfoEXT
	) -> () {
		(self.table.pfn_vkCmdBeginConditionalRenderingEXT)(self.handle, pConditionalRenderingBegin as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_conditional_rendering")]
	pub fn cmdEndConditionalRenderingEXT(
		&self
	) -> () {
		(self.table.pfn_vkCmdEndConditionalRenderingEXT)(self.handle)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdResetQueryPool(
		&self,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32,
		queryCount                                   : u32
	) -> () {
		(self.table.pfn_vkCmdResetQueryPool)(self.handle, queryPool, firstQuery, queryCount)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdWriteTimestamp(
		&self,
		pipelineStage                                : VkPipelineStageFlagBits,
		queryPool                                    : VkQueryPool,
		query                                        : u32
	) -> () {
		(self.table.pfn_vkCmdWriteTimestamp)(self.handle, pipelineStage, queryPool, query)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdCopyQueryPoolResults(
		&self,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32,
		queryCount                                   : u32,
		dstBuffer                                    : VkBuffer,
		dstOffset                                    : VkDeviceSize,
		stride                                       : VkDeviceSize,
		flags                                        : VkQueryResultFlags
	) -> () {
		(self.table.pfn_vkCmdCopyQueryPoolResults)(self.handle, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdPushConstants(
		&self,
		layout                                       : VkPipelineLayout,
		stageFlags                                   : VkShaderStageFlags,
		offset                                       : u32,
		pValues                                      : &[u8]
	) -> () {
		(self.table.pfn_vkCmdPushConstants)(self.handle, layout, stageFlags, offset, pValues.len() as _, pValues.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdBeginRenderPass(
		&self,
		pRenderPassBegin                             : &VkRenderPassBeginInfo,
		contents                                     : VkSubpassContents
	) -> () {
		(self.table.pfn_vkCmdBeginRenderPass)(self.handle, pRenderPassBegin as *const _ as _, contents)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdNextSubpass(
		&self,
		contents                                     : VkSubpassContents
	) -> () {
		(self.table.pfn_vkCmdNextSubpass)(self.handle, contents)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdEndRenderPass(
		&self
	) -> () {
		(self.table.pfn_vkCmdEndRenderPass)(self.handle)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn cmdExecuteCommands(
		&self,
		pCommandBuffers                              : &[VkCommandBuffer]
	) -> () {
		(self.table.pfn_vkCmdExecuteCommands)(self.handle, pCommandBuffers.len() as _, pCommandBuffers.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_marker")]
	pub fn cmdDebugMarkerBeginEXT(
		&self,
		pMarkerInfo                                  : &VkDebugMarkerMarkerInfoEXT
	) -> () {
		(self.table.pfn_vkCmdDebugMarkerBeginEXT)(self.handle, pMarkerInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_marker")]
	pub fn cmdDebugMarkerEndEXT(
		&self
	) -> () {
		(self.table.pfn_vkCmdDebugMarkerEndEXT)(self.handle)
	}
	
	#[cfg(feature = "VK_EXT_debug_marker")]
	pub fn cmdDebugMarkerInsertEXT(
		&self,
		pMarkerInfo                                  : &VkDebugMarkerMarkerInfoEXT
	) -> () {
		(self.table.pfn_vkCmdDebugMarkerInsertEXT)(self.handle, pMarkerInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pub fn cmdExecuteGeneratedCommandsNV(
		&self,
		isPreprocessed                               : VkBool32,
		pGeneratedCommandsInfo                       : &VkGeneratedCommandsInfoNV
	) -> () {
		(self.table.pfn_vkCmdExecuteGeneratedCommandsNV)(self.handle, isPreprocessed, pGeneratedCommandsInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pub fn cmdPreprocessGeneratedCommandsNV(
		&self,
		pGeneratedCommandsInfo                       : &VkGeneratedCommandsInfoNV
	) -> () {
		(self.table.pfn_vkCmdPreprocessGeneratedCommandsNV)(self.handle, pGeneratedCommandsInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pub fn cmdBindPipelineShaderGroupNV(
		&self,
		pipelineBindPoint                            : VkPipelineBindPoint,
		pipeline                                     : VkPipeline,
		groupIndex                                   : u32
	) -> () {
		(self.table.pfn_vkCmdBindPipelineShaderGroupNV)(self.handle, pipelineBindPoint, pipeline, groupIndex)
	}
	
	#[cfg(feature = "VK_KHR_push_descriptor")]
	pub fn cmdPushDescriptorSetKHR(
		&self,
		pipelineBindPoint                            : VkPipelineBindPoint,
		layout                                       : VkPipelineLayout,
		set                                          : u32,
		pDescriptorWrites                            : &[VkWriteDescriptorSet]
	) -> () {
		(self.table.pfn_vkCmdPushDescriptorSetKHR)(self.handle, pipelineBindPoint, layout, set, pDescriptorWrites.len() as _, pDescriptorWrites.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn cmdSetDeviceMask(
		&self,
		deviceMask                                   : u32
	) -> () {
		(self.table.pfn_vkCmdSetDeviceMask)(self.handle, deviceMask)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn cmdSetDeviceMaskKHR(
		&self,
		deviceMask                                   : u32
	) -> () {
		(self.table.pfn_vkCmdSetDeviceMaskKHR)(self.handle, deviceMask)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn cmdDispatchBase(
		&self,
		baseGroupX                                   : u32,
		baseGroupY                                   : u32,
		baseGroupZ                                   : u32,
		groupCountX                                  : u32,
		groupCountY                                  : u32,
		groupCountZ                                  : u32
	) -> () {
		(self.table.pfn_vkCmdDispatchBase)(self.handle, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
	}
	
	#[cfg(feature = "VK_KHR_device_group")]
	pub fn cmdDispatchBaseKHR(
		&self,
		baseGroupX                                   : u32,
		baseGroupY                                   : u32,
		baseGroupZ                                   : u32,
		groupCountX                                  : u32,
		groupCountY                                  : u32,
		groupCountZ                                  : u32
	) -> () {
		(self.table.pfn_vkCmdDispatchBaseKHR)(self.handle, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
	}
	
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pub fn cmdPushDescriptorSetWithTemplateKHR(
		&self,
		descriptorUpdateTemplate                     : VkDescriptorUpdateTemplate,
		layout                                       : VkPipelineLayout,
		set                                          : u32,
		pData                                        : VkAnyRef
	) -> () {
		(self.table.pfn_vkCmdPushDescriptorSetWithTemplateKHR)(self.handle, descriptorUpdateTemplate, layout, set, (pData).into())
	}
	
	#[cfg(feature = "VK_NV_clip_space_w_scaling")]
	pub fn cmdSetViewportWScalingNV(
		&self,
		firstViewport                                : u32,
		pViewportWScalings                           : &[VkViewportWScalingNV]
	) -> () {
		(self.table.pfn_vkCmdSetViewportWScalingNV)(self.handle, firstViewport, pViewportWScalings.len() as _, pViewportWScalings.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_discard_rectangles")]
	pub fn cmdSetDiscardRectangleEXT(
		&self,
		firstDiscardRectangle                        : u32,
		pDiscardRectangles                           : &[VkRect2D]
	) -> () {
		(self.table.pfn_vkCmdSetDiscardRectangleEXT)(self.handle, firstDiscardRectangle, pDiscardRectangles.len() as _, pDiscardRectangles.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_sample_locations")]
	pub fn cmdSetSampleLocationsEXT(
		&self,
		pSampleLocationsInfo                         : &VkSampleLocationsInfoEXT
	) -> () {
		(self.table.pfn_vkCmdSetSampleLocationsEXT)(self.handle, pSampleLocationsInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn cmdBeginDebugUtilsLabelEXT(
		&self,
		pLabelInfo                                   : &VkDebugUtilsLabelEXT
	) -> () {
		(self.table.pfn_vkCmdBeginDebugUtilsLabelEXT)(self.handle, pLabelInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn cmdEndDebugUtilsLabelEXT(
		&self
	) -> () {
		(self.table.pfn_vkCmdEndDebugUtilsLabelEXT)(self.handle)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn cmdInsertDebugUtilsLabelEXT(
		&self,
		pLabelInfo                                   : &VkDebugUtilsLabelEXT
	) -> () {
		(self.table.pfn_vkCmdInsertDebugUtilsLabelEXT)(self.handle, pLabelInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_AMD_buffer_marker")]
	pub fn cmdWriteBufferMarkerAMD(
		&self,
		pipelineStage                                : VkPipelineStageFlagBits,
		dstBuffer                                    : VkBuffer,
		dstOffset                                    : VkDeviceSize,
		marker                                       : u32
	) -> () {
		(self.table.pfn_vkCmdWriteBufferMarkerAMD)(self.handle, pipelineStage, dstBuffer, dstOffset, marker)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn cmdBeginRenderPass2(
		&self,
		pRenderPassBegin                             : &VkRenderPassBeginInfo,
		pSubpassBeginInfo                            : &VkSubpassBeginInfo
	) -> () {
		(self.table.pfn_vkCmdBeginRenderPass2)(self.handle, pRenderPassBegin as *const _ as _, pSubpassBeginInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pub fn cmdBeginRenderPass2KHR(
		&self,
		pRenderPassBegin                             : &VkRenderPassBeginInfo,
		pSubpassBeginInfo                            : &VkSubpassBeginInfo
	) -> () {
		(self.table.pfn_vkCmdBeginRenderPass2KHR)(self.handle, pRenderPassBegin as *const _ as _, pSubpassBeginInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn cmdNextSubpass2(
		&self,
		pSubpassBeginInfo                            : &VkSubpassBeginInfo,
		pSubpassEndInfo                              : &VkSubpassEndInfo
	) -> () {
		(self.table.pfn_vkCmdNextSubpass2)(self.handle, pSubpassBeginInfo as *const _ as _, pSubpassEndInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pub fn cmdNextSubpass2KHR(
		&self,
		pSubpassBeginInfo                            : &VkSubpassBeginInfo,
		pSubpassEndInfo                              : &VkSubpassEndInfo
	) -> () {
		(self.table.pfn_vkCmdNextSubpass2KHR)(self.handle, pSubpassBeginInfo as *const _ as _, pSubpassEndInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn cmdEndRenderPass2(
		&self,
		pSubpassEndInfo                              : &VkSubpassEndInfo
	) -> () {
		(self.table.pfn_vkCmdEndRenderPass2)(self.handle, pSubpassEndInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pub fn cmdEndRenderPass2KHR(
		&self,
		pSubpassEndInfo                              : &VkSubpassEndInfo
	) -> () {
		(self.table.pfn_vkCmdEndRenderPass2KHR)(self.handle, pSubpassEndInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn cmdDrawIndirectCount(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndirectCount)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_KHR_draw_indirect_count")]
	pub fn cmdDrawIndirectCountKHR(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndirectCountKHR)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_AMD_draw_indirect_count")]
	pub fn cmdDrawIndirectCountAMD(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndirectCountAMD)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_VERSION_1_2")]
	pub fn cmdDrawIndexedIndirectCount(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndexedIndirectCount)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_KHR_draw_indirect_count")]
	pub fn cmdDrawIndexedIndirectCountKHR(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndexedIndirectCountKHR)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_AMD_draw_indirect_count")]
	pub fn cmdDrawIndexedIndirectCountAMD(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndexedIndirectCountAMD)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
	pub fn cmdSetCheckpointNV(
		&self,
		pCheckpointMarker                            : VkAnyRef
	) -> () {
		(self.table.pfn_vkCmdSetCheckpointNV)(self.handle, (pCheckpointMarker).into())
	}
	
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pub fn cmdBindTransformFeedbackBuffersEXT(
		&self,
		firstBinding                                 : u32,
		pBuffers                                     : &[VkBuffer],
		pOffsets                                     : &[VkDeviceSize],
		pSizes                                       : Option<&[VkDeviceSize]>
	) -> () {
		(self.table.pfn_vkCmdBindTransformFeedbackBuffersEXT)(self.handle, firstBinding, pSizes.as_ref().map_or(0, |v| v.len() as _), pBuffers.as_ptr() as _, pOffsets.as_ptr() as _, pSizes.map_or(std::ptr::null(), <[_]>::as_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pub fn cmdBeginTransformFeedbackEXT(
		&self,
		firstCounterBuffer                           : u32,
		pCounterBuffers                              : &[VkBuffer],
		pCounterBufferOffsets                        : Option<&[VkDeviceSize]>
	) -> () {
		(self.table.pfn_vkCmdBeginTransformFeedbackEXT)(self.handle, firstCounterBuffer, pCounterBufferOffsets.as_ref().map_or(0, |v| v.len() as _), pCounterBuffers.as_ptr() as _, pCounterBufferOffsets.map_or(std::ptr::null(), <[_]>::as_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pub fn cmdEndTransformFeedbackEXT(
		&self,
		firstCounterBuffer                           : u32,
		pCounterBuffers                              : &[VkBuffer],
		pCounterBufferOffsets                        : Option<&[VkDeviceSize]>
	) -> () {
		(self.table.pfn_vkCmdEndTransformFeedbackEXT)(self.handle, firstCounterBuffer, pCounterBufferOffsets.as_ref().map_or(0, |v| v.len() as _), pCounterBuffers.as_ptr() as _, pCounterBufferOffsets.map_or(std::ptr::null(), <[_]>::as_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pub fn cmdBeginQueryIndexedEXT(
		&self,
		queryPool                                    : VkQueryPool,
		query                                        : u32,
		flags                                        : VkQueryControlFlags,
		index                                        : u32
	) -> () {
		(self.table.pfn_vkCmdBeginQueryIndexedEXT)(self.handle, queryPool, query, flags, index)
	}
	
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pub fn cmdEndQueryIndexedEXT(
		&self,
		queryPool                                    : VkQueryPool,
		query                                        : u32,
		index                                        : u32
	) -> () {
		(self.table.pfn_vkCmdEndQueryIndexedEXT)(self.handle, queryPool, query, index)
	}
	
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pub fn cmdDrawIndirectByteCountEXT(
		&self,
		instanceCount                                : u32,
		firstInstance                                : u32,
		counterBuffer                                : VkBuffer,
		counterBufferOffset                          : VkDeviceSize,
		counterOffset                                : u32,
		vertexStride                                 : u32
	) -> () {
		(self.table.pfn_vkCmdDrawIndirectByteCountEXT)(self.handle, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride)
	}
	
	#[cfg(feature = "VK_NV_scissor_exclusive")]
	pub fn cmdSetExclusiveScissorNV(
		&self,
		firstExclusiveScissor                        : u32,
		pExclusiveScissors                           : &[VkRect2D]
	) -> () {
		(self.table.pfn_vkCmdSetExclusiveScissorNV)(self.handle, firstExclusiveScissor, pExclusiveScissors.len() as _, pExclusiveScissors.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_NV_shading_rate_image")]
	pub fn cmdBindShadingRateImageNV(
		&self,
		imageView                                    : VkImageView,
		imageLayout                                  : VkImageLayout
	) -> () {
		(self.table.pfn_vkCmdBindShadingRateImageNV)(self.handle, imageView, imageLayout)
	}
	
	#[cfg(feature = "VK_NV_shading_rate_image")]
	pub fn cmdSetViewportShadingRatePaletteNV(
		&self,
		firstViewport                                : u32,
		pShadingRatePalettes                         : &[VkShadingRatePaletteNV]
	) -> () {
		(self.table.pfn_vkCmdSetViewportShadingRatePaletteNV)(self.handle, firstViewport, pShadingRatePalettes.len() as _, pShadingRatePalettes.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_NV_shading_rate_image")]
	pub fn cmdSetCoarseSampleOrderNV(
		&self,
		sampleOrderType                              : VkCoarseSampleOrderTypeNV,
		pCustomSampleOrders                          : &[VkCoarseSampleOrderCustomNV]
	) -> () {
		(self.table.pfn_vkCmdSetCoarseSampleOrderNV)(self.handle, sampleOrderType, pCustomSampleOrders.len() as _, pCustomSampleOrders.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_NV_mesh_shader")]
	pub fn cmdDrawMeshTasksNV(
		&self,
		taskCount                                    : u32,
		firstTask                                    : u32
	) -> () {
		(self.table.pfn_vkCmdDrawMeshTasksNV)(self.handle, taskCount, firstTask)
	}
	
	#[cfg(feature = "VK_NV_mesh_shader")]
	pub fn cmdDrawMeshTasksIndirectNV(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		drawCount                                    : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawMeshTasksIndirectNV)(self.handle, buffer, offset, drawCount, stride)
	}
	
	#[cfg(feature = "VK_NV_mesh_shader")]
	pub fn cmdDrawMeshTasksIndirectCountNV(
		&self,
		buffer                                       : VkBuffer,
		offset                                       : VkDeviceSize,
		countBuffer                                  : VkBuffer,
		countBufferOffset                            : VkDeviceSize,
		maxDrawCount                                 : u32,
		stride                                       : u32
	) -> () {
		(self.table.pfn_vkCmdDrawMeshTasksIndirectCountNV)(self.handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn cmdCopyAccelerationStructureNV(
		&self,
		dst                                          : VkAccelerationStructureNV,
		src                                          : VkAccelerationStructureNV,
		mode                                         : VkCopyAccelerationStructureModeKHR
	) -> () {
		(self.table.pfn_vkCmdCopyAccelerationStructureNV)(self.handle, dst, src, mode)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn cmdCopyAccelerationStructureKHR(
		&self,
		pInfo                                        : &VkCopyAccelerationStructureInfoKHR
	) -> () {
		(self.table.pfn_vkCmdCopyAccelerationStructureKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn cmdCopyAccelerationStructureToMemoryKHR(
		&self,
		pInfo                                        : &VkCopyAccelerationStructureToMemoryInfoKHR
	) -> () {
		(self.table.pfn_vkCmdCopyAccelerationStructureToMemoryKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn cmdCopyMemoryToAccelerationStructureKHR(
		&self,
		pInfo                                        : &VkCopyMemoryToAccelerationStructureInfoKHR
	) -> () {
		(self.table.pfn_vkCmdCopyMemoryToAccelerationStructureKHR)(self.handle, pInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn cmdWriteAccelerationStructuresPropertiesKHR(
		&self,
		pAccelerationStructures                      : &[VkAccelerationStructureKHR],
		queryType                                    : VkQueryType,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32
	) -> () {
		(self.table.pfn_vkCmdWriteAccelerationStructuresPropertiesKHR)(self.handle, pAccelerationStructures.len() as _, pAccelerationStructures.as_ptr() as _, queryType, queryPool, firstQuery)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn cmdWriteAccelerationStructuresPropertiesNV(
		&self,
		pAccelerationStructures                      : &[VkAccelerationStructureNV],
		queryType                                    : VkQueryType,
		queryPool                                    : VkQueryPool,
		firstQuery                                   : u32
	) -> () {
		(self.table.pfn_vkCmdWriteAccelerationStructuresPropertiesNV)(self.handle, pAccelerationStructures.len() as _, pAccelerationStructures.as_ptr() as _, queryType, queryPool, firstQuery)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn cmdBuildAccelerationStructureNV(
		&self,
		pInfo                                        : &VkAccelerationStructureInfoNV,
		instanceData                                 : VkBuffer,
		instanceOffset                               : VkDeviceSize,
		update                                       : VkBool32,
		dst                                          : VkAccelerationStructureNV,
		src                                          : VkAccelerationStructureNV,
		scratch                                      : VkBuffer,
		scratchOffset                                : VkDeviceSize
	) -> () {
		(self.table.pfn_vkCmdBuildAccelerationStructureNV)(self.handle, pInfo as *const _ as _, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn cmdTraceRaysKHR(
		&self,
		pRaygenShaderBindingTable                    : &VkStridedDeviceAddressRegionKHR,
		pMissShaderBindingTable                      : &VkStridedDeviceAddressRegionKHR,
		pHitShaderBindingTable                       : &VkStridedDeviceAddressRegionKHR,
		pCallableShaderBindingTable                  : &VkStridedDeviceAddressRegionKHR,
		width                                        : u32,
		height                                       : u32,
		depth                                        : u32
	) -> () {
		(self.table.pfn_vkCmdTraceRaysKHR)(self.handle, pRaygenShaderBindingTable as *const _ as _, pMissShaderBindingTable as *const _ as _, pHitShaderBindingTable as *const _ as _, pCallableShaderBindingTable as *const _ as _, width, height, depth)
	}
	
	#[cfg(feature = "VK_NV_ray_tracing")]
	pub fn cmdTraceRaysNV(
		&self,
		raygenShaderBindingTableBuffer               : VkBuffer,
		raygenShaderBindingOffset                    : VkDeviceSize,
		missShaderBindingTableBuffer                 : VkBuffer,
		missShaderBindingOffset                      : VkDeviceSize,
		missShaderBindingStride                      : VkDeviceSize,
		hitShaderBindingTableBuffer                  : VkBuffer,
		hitShaderBindingOffset                       : VkDeviceSize,
		hitShaderBindingStride                       : VkDeviceSize,
		callableShaderBindingTableBuffer             : VkBuffer,
		callableShaderBindingOffset                  : VkDeviceSize,
		callableShaderBindingStride                  : VkDeviceSize,
		width                                        : u32,
		height                                       : u32,
		depth                                        : u32
	) -> () {
		(self.table.pfn_vkCmdTraceRaysNV)(self.handle, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn cmdTraceRaysIndirectKHR(
		&self,
		pRaygenShaderBindingTable                    : &VkStridedDeviceAddressRegionKHR,
		pMissShaderBindingTable                      : &VkStridedDeviceAddressRegionKHR,
		pHitShaderBindingTable                       : &VkStridedDeviceAddressRegionKHR,
		pCallableShaderBindingTable                  : &VkStridedDeviceAddressRegionKHR,
		indirectDeviceAddress                        : VkDeviceAddress
	) -> () {
		(self.table.pfn_vkCmdTraceRaysIndirectKHR)(self.handle, pRaygenShaderBindingTable as *const _ as _, pMissShaderBindingTable as *const _ as _, pHitShaderBindingTable as *const _ as _, pCallableShaderBindingTable as *const _ as _, indirectDeviceAddress)
	}
	
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pub fn cmdSetRayTracingPipelineStackSizeKHR(
		&self,
		pipelineStackSize                            : u32
	) -> () {
		(self.table.pfn_vkCmdSetRayTracingPipelineStackSizeKHR)(self.handle, pipelineStackSize)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn cmdSetPerformanceMarkerINTEL(
		&self,
		pMarkerInfo                                  : &VkPerformanceMarkerInfoINTEL
	) -> VkResult {
		(self.table.pfn_vkCmdSetPerformanceMarkerINTEL)(self.handle, pMarkerInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn cmdSetPerformanceStreamMarkerINTEL(
		&self,
		pMarkerInfo                                  : &VkPerformanceStreamMarkerInfoINTEL
	) -> VkResult {
		(self.table.pfn_vkCmdSetPerformanceStreamMarkerINTEL)(self.handle, pMarkerInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_INTEL_performance_query")]
	pub fn cmdSetPerformanceOverrideINTEL(
		&self,
		pOverrideInfo                                : &VkPerformanceOverrideInfoINTEL
	) -> VkResult {
		(self.table.pfn_vkCmdSetPerformanceOverrideINTEL)(self.handle, pOverrideInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_line_rasterization")]
	pub fn cmdSetLineStippleEXT(
		&self,
		lineStippleFactor                            : u32,
		lineStipplePattern                           : u16
	) -> () {
		(self.table.pfn_vkCmdSetLineStippleEXT)(self.handle, lineStippleFactor, lineStipplePattern)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn cmdBuildAccelerationStructuresKHR(
		&self,
		pInfos                                       : &[VkAccelerationStructureBuildGeometryInfoKHR],
		ppBuildRangeInfos                            : &[&VkAccelerationStructureBuildRangeInfoKHR]
	) -> () {
		(self.table.pfn_vkCmdBuildAccelerationStructuresKHR)(self.handle, ppBuildRangeInfos.len() as _, pInfos.as_ptr() as _, ppBuildRangeInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pub fn cmdBuildAccelerationStructuresIndirectKHR(
		&self,
		pInfos                                       : &[VkAccelerationStructureBuildGeometryInfoKHR],
		pIndirectDeviceAddresses                     : &[VkDeviceAddress],
		pIndirectStrides                             : &[u32],
		ppMaxPrimitiveCounts                         : &[&u32]
	) -> () {
		(self.table.pfn_vkCmdBuildAccelerationStructuresIndirectKHR)(self.handle, ppMaxPrimitiveCounts.len() as _, pInfos.as_ptr() as _, pIndirectDeviceAddresses.as_ptr() as _, pIndirectStrides.as_ptr() as _, ppMaxPrimitiveCounts.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetCullModeEXT(
		&self,
		cullMode                                     : VkCullModeFlags
	) -> () {
		(self.table.pfn_vkCmdSetCullModeEXT)(self.handle, cullMode)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetFrontFaceEXT(
		&self,
		frontFace                                    : VkFrontFace
	) -> () {
		(self.table.pfn_vkCmdSetFrontFaceEXT)(self.handle, frontFace)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetPrimitiveTopologyEXT(
		&self,
		primitiveTopology                            : VkPrimitiveTopology
	) -> () {
		(self.table.pfn_vkCmdSetPrimitiveTopologyEXT)(self.handle, primitiveTopology)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetViewportWithCountEXT(
		&self,
		pViewports                                   : &[VkViewport]
	) -> () {
		(self.table.pfn_vkCmdSetViewportWithCountEXT)(self.handle, pViewports.len() as _, pViewports.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetScissorWithCountEXT(
		&self,
		pScissors                                    : &[VkRect2D]
	) -> () {
		(self.table.pfn_vkCmdSetScissorWithCountEXT)(self.handle, pScissors.len() as _, pScissors.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdBindVertexBuffers2EXT(
		&self,
		firstBinding                                 : u32,
		pBuffers                                     : &[VkBuffer],
		pOffsets                                     : &[VkDeviceSize],
		pSizes                                       : Option<&[VkDeviceSize]>,
		pStrides                                     : Option<&[VkDeviceSize]>
	) -> () {
		(self.table.pfn_vkCmdBindVertexBuffers2EXT)(self.handle, firstBinding, pStrides.as_ref().map_or(0, |v| v.len() as _), pBuffers.as_ptr() as _, pOffsets.as_ptr() as _, pSizes.map_or(std::ptr::null(), <[_]>::as_ptr) as _, pStrides.map_or(std::ptr::null(), <[_]>::as_ptr) as _)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetDepthTestEnableEXT(
		&self,
		depthTestEnable                              : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetDepthTestEnableEXT)(self.handle, depthTestEnable)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetDepthWriteEnableEXT(
		&self,
		depthWriteEnable                             : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetDepthWriteEnableEXT)(self.handle, depthWriteEnable)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetDepthCompareOpEXT(
		&self,
		depthCompareOp                               : VkCompareOp
	) -> () {
		(self.table.pfn_vkCmdSetDepthCompareOpEXT)(self.handle, depthCompareOp)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetDepthBoundsTestEnableEXT(
		&self,
		depthBoundsTestEnable                        : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetDepthBoundsTestEnableEXT)(self.handle, depthBoundsTestEnable)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetStencilTestEnableEXT(
		&self,
		stencilTestEnable                            : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetStencilTestEnableEXT)(self.handle, stencilTestEnable)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pub fn cmdSetStencilOpEXT(
		&self,
		faceMask                                     : VkStencilFaceFlags,
		failOp                                       : VkStencilOp,
		passOp                                       : VkStencilOp,
		depthFailOp                                  : VkStencilOp,
		compareOp                                    : VkCompareOp
	) -> () {
		(self.table.pfn_vkCmdSetStencilOpEXT)(self.handle, faceMask, failOp, passOp, depthFailOp, compareOp)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pub fn cmdSetPatchControlPointsEXT(
		&self,
		patchControlPoints                           : u32
	) -> () {
		(self.table.pfn_vkCmdSetPatchControlPointsEXT)(self.handle, patchControlPoints)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pub fn cmdSetRasterizerDiscardEnableEXT(
		&self,
		rasterizerDiscardEnable                      : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetRasterizerDiscardEnableEXT)(self.handle, rasterizerDiscardEnable)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pub fn cmdSetDepthBiasEnableEXT(
		&self,
		depthBiasEnable                              : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetDepthBiasEnableEXT)(self.handle, depthBiasEnable)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pub fn cmdSetLogicOpEXT(
		&self,
		logicOp                                      : VkLogicOp
	) -> () {
		(self.table.pfn_vkCmdSetLogicOpEXT)(self.handle, logicOp)
	}
	
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pub fn cmdSetPrimitiveRestartEnableEXT(
		&self,
		primitiveRestartEnable                       : VkBool32
	) -> () {
		(self.table.pfn_vkCmdSetPrimitiveRestartEnableEXT)(self.handle, primitiveRestartEnable)
	}
	
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pub fn cmdCopyBuffer2KHR(
		&self,
		pCopyBufferInfo                              : &VkCopyBufferInfo2KHR
	) -> () {
		(self.table.pfn_vkCmdCopyBuffer2KHR)(self.handle, pCopyBufferInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pub fn cmdCopyImage2KHR(
		&self,
		pCopyImageInfo                               : &VkCopyImageInfo2KHR
	) -> () {
		(self.table.pfn_vkCmdCopyImage2KHR)(self.handle, pCopyImageInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pub fn cmdBlitImage2KHR(
		&self,
		pBlitImageInfo                               : &VkBlitImageInfo2KHR
	) -> () {
		(self.table.pfn_vkCmdBlitImage2KHR)(self.handle, pBlitImageInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pub fn cmdCopyBufferToImage2KHR(
		&self,
		pCopyBufferToImageInfo                       : &VkCopyBufferToImageInfo2KHR
	) -> () {
		(self.table.pfn_vkCmdCopyBufferToImage2KHR)(self.handle, pCopyBufferToImageInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pub fn cmdCopyImageToBuffer2KHR(
		&self,
		pCopyImageToBufferInfo                       : &VkCopyImageToBufferInfo2KHR
	) -> () {
		(self.table.pfn_vkCmdCopyImageToBuffer2KHR)(self.handle, pCopyImageToBufferInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pub fn cmdResolveImage2KHR(
		&self,
		pResolveImageInfo                            : &VkResolveImageInfo2KHR
	) -> () {
		(self.table.pfn_vkCmdResolveImage2KHR)(self.handle, pResolveImageInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_fragment_shading_rate")]
	pub fn cmdSetFragmentShadingRateKHR(
		&self,
		pFragmentSize                                : &VkExtent2D,
		combinerOps                                  : [VkFragmentShadingRateCombinerOpKHR;  2 as usize]
	) -> () {
		(self.table.pfn_vkCmdSetFragmentShadingRateKHR)(self.handle, pFragmentSize as *const _ as _, combinerOps)
	}
	
	#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
	pub fn cmdSetFragmentShadingRateEnumNV(
		&self,
		shadingRate                                  : VkFragmentShadingRateNV,
		combinerOps                                  : [VkFragmentShadingRateCombinerOpKHR;  2 as usize]
	) -> () {
		(self.table.pfn_vkCmdSetFragmentShadingRateEnumNV)(self.handle, shadingRate, combinerOps)
	}
	
	#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
	pub fn cmdSetVertexInputEXT(
		&self,
		pVertexBindingDescriptions                   : &[VkVertexInputBindingDescription2EXT],
		pVertexAttributeDescriptions                 : &[VkVertexInputAttributeDescription2EXT]
	) -> () {
		(self.table.pfn_vkCmdSetVertexInputEXT)(self.handle, pVertexBindingDescriptions.len() as _, pVertexBindingDescriptions.as_ptr() as _, pVertexAttributeDescriptions.len() as _, pVertexAttributeDescriptions.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_EXT_color_write_enable")]
	pub fn cmdSetColorWriteEnableEXT(
		&self,
		pColorWriteEnables                           : &[VkBool32]
	) -> () {
		(self.table.pfn_vkCmdSetColorWriteEnableEXT)(self.handle, pColorWriteEnables.len() as _, pColorWriteEnables.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn cmdSetEvent2KHR(
		&self,
		event                                        : VkEvent,
		pDependencyInfo                              : &VkDependencyInfoKHR
	) -> () {
		(self.table.pfn_vkCmdSetEvent2KHR)(self.handle, event, pDependencyInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn cmdResetEvent2KHR(
		&self,
		event                                        : VkEvent,
		stageMask                                    : VkPipelineStageFlags2KHR
	) -> () {
		(self.table.pfn_vkCmdResetEvent2KHR)(self.handle, event, stageMask)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn cmdWaitEvents2KHR(
		&self,
		pEvents                                      : &[VkEvent],
		pDependencyInfos                             : &[VkDependencyInfoKHR]
	) -> () {
		(self.table.pfn_vkCmdWaitEvents2KHR)(self.handle, pDependencyInfos.len() as _, pEvents.as_ptr() as _, pDependencyInfos.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn cmdPipelineBarrier2KHR(
		&self,
		pDependencyInfo                              : &VkDependencyInfoKHR
	) -> () {
		(self.table.pfn_vkCmdPipelineBarrier2KHR)(self.handle, pDependencyInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn cmdWriteTimestamp2KHR(
		&self,
		stage                                        : VkPipelineStageFlags2KHR,
		queryPool                                    : VkQueryPool,
		query                                        : u32
	) -> () {
		(self.table.pfn_vkCmdWriteTimestamp2KHR)(self.handle, stage, queryPool, query)
	}
	
	#[cfg(feature = "VK_KHR_synchronization2")]
	pub fn cmdWriteBufferMarker2AMD(
		&self,
		stage                                        : VkPipelineStageFlags2KHR,
		dstBuffer                                    : VkBuffer,
		dstOffset                                    : VkDeviceSize,
		marker                                       : u32
	) -> () {
		(self.table.pfn_vkCmdWriteBufferMarker2AMD)(self.handle, stage, dstBuffer, dstOffset, marker)
	}
	
	#[cfg(feature = "VK_KHR_video_decode_queue")]
	pub fn cmdDecodeVideoKHR(
		&self,
		pFrameInfo                                   : &VkVideoDecodeInfoKHR
	) -> () {
		(self.table.pfn_vkCmdDecodeVideoKHR)(self.handle, pFrameInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn cmdBeginVideoCodingKHR(
		&self,
		pBeginInfo                                   : &VkVideoBeginCodingInfoKHR
	) -> () {
		(self.table.pfn_vkCmdBeginVideoCodingKHR)(self.handle, pBeginInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn cmdControlVideoCodingKHR(
		&self,
		pCodingControlInfo                           : &VkVideoCodingControlInfoKHR
	) -> () {
		(self.table.pfn_vkCmdControlVideoCodingKHR)(self.handle, pCodingControlInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_queue")]
	pub fn cmdEndVideoCodingKHR(
		&self,
		pEndCodingInfo                               : &VkVideoEndCodingInfoKHR
	) -> () {
		(self.table.pfn_vkCmdEndVideoCodingKHR)(self.handle, pEndCodingInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_KHR_video_encode_queue")]
	pub fn cmdEncodeVideoKHR(
		&self,
		pEncodeInfo                                  : &VkVideoEncodeInfoKHR
	) -> () {
		(self.table.pfn_vkCmdEncodeVideoKHR)(self.handle, pEncodeInfo as *const _ as _)
	}
	
	#[cfg(feature = "VK_NVX_binary_import")]
	pub fn cmdCuLaunchKernelNVX(
		&self,
		pLaunchInfo                                  : &VkCuLaunchInfoNVX
	) -> () {
		(self.table.pfn_vkCmdCuLaunchKernelNVX)(self.handle, pLaunchInfo as *const _ as _)
	}
}

/// Wrapper for a `VkValidationCacheEXT` handle
#[derive(Clone, Debug)]
pub struct VkValidationCacheEXTImpl {
	pub handle: VkValidationCacheEXT,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkValidationCacheEXTImpl {
	type Target = VkValidationCacheEXT;
	
	#[inline]
	fn deref(&self) -> &VkValidationCacheEXT { &self.handle }
}

impl fmt::Display for VkValidationCacheEXTImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkValidationCacheEXTImpl {
	pub fn new(handle: VkValidationCacheEXT, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkInstance` handle
#[derive(Clone, Debug)]
pub struct VkInstanceImpl {
	pub handle: VkInstance,
	pub table:  Arc<VkInstanceTable>
}

impl ops::Deref for VkInstanceImpl {
	type Target = VkInstance;
	
	#[inline]
	fn deref(&self) -> &VkInstance { &self.handle }
}

impl fmt::Display for VkInstanceImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkInstanceImpl {
	pub fn new(handle: VkInstance) -> Self {
		Self { handle, table: VkInstanceTable::load(handle) }
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn destroy(
		&self,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyInstance)(self.handle, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pub fn enumeratePhysicalDevices(
		&self,
		pPhysicalDeviceCount                         : &mut u32,
		pPhysicalDevices                             : Option<&mut [VkPhysicalDevice]>
	) -> VkResult {
		(self.table.pfn_vkEnumeratePhysicalDevices)(self.handle, pPhysicalDeviceCount, pPhysicalDevices.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_android_surface")]
	pub fn createAndroidSurfaceKHR(
		&self,
		pCreateInfo                                  : &VkAndroidSurfaceCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateAndroidSurfaceKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_display")]
	pub fn createDisplayPlaneSurfaceKHR(
		&self,
		pCreateInfo                                  : &VkDisplaySurfaceCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateDisplayPlaneSurfaceKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_surface")]
	pub fn destroySurfaceKHR(
		&self,
		surface                                      : VkSurfaceKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroySurfaceKHR)(self.handle, surface, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_NN_vi_surface")]
	pub fn createViSurfaceNN(
		&self,
		pCreateInfo                                  : &VkViSurfaceCreateInfoNN,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateViSurfaceNN)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_wayland_surface")]
	pub fn createWaylandSurfaceKHR(
		&self,
		pCreateInfo                                  : &VkWaylandSurfaceCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateWaylandSurfaceKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_win32_surface")]
	pub fn createWin32SurfaceKHR(
		&self,
		pCreateInfo                                  : &VkWin32SurfaceCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateWin32SurfaceKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_xlib_surface")]
	pub fn createXlibSurfaceKHR(
		&self,
		pCreateInfo                                  : &VkXlibSurfaceCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateXlibSurfaceKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_KHR_xcb_surface")]
	pub fn createXcbSurfaceKHR(
		&self,
		pCreateInfo                                  : &VkXcbSurfaceCreateInfoKHR,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateXcbSurfaceKHR)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_directfb_surface")]
	pub fn createDirectFBSurfaceEXT(
		&self,
		pCreateInfo                                  : &VkDirectFBSurfaceCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateDirectFBSurfaceEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
	pub fn createImagePipeSurfaceFUCHSIA(
		&self,
		pCreateInfo                                  : &VkImagePipeSurfaceCreateInfoFUCHSIA,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateImagePipeSurfaceFUCHSIA)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_GGP_stream_descriptor_surface")]
	pub fn createStreamDescriptorSurfaceGGP(
		&self,
		pCreateInfo                                  : &VkStreamDescriptorSurfaceCreateInfoGGP,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateStreamDescriptorSurfaceGGP)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_QNX_screen_surface")]
	pub fn createScreenSurfaceQNX(
		&self,
		pCreateInfo                                  : &VkScreenSurfaceCreateInfoQNX,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateScreenSurfaceQNX)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_report")]
	pub fn createDebugReportCallbackEXT(
		&self,
		pCreateInfo                                  : &VkDebugReportCallbackCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pCallback                                    : &mut VkDebugReportCallbackEXT
	) -> VkResult {
		(self.table.pfn_vkCreateDebugReportCallbackEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pCallback as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_report")]
	pub fn destroyDebugReportCallbackEXT(
		&self,
		callback                                     : VkDebugReportCallbackEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDebugReportCallbackEXT)(self.handle, callback, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_report")]
	pub fn debugReportMessageEXT(
		&self,
		flags                                        : VkDebugReportFlagsEXT,
		objectType                                   : VkDebugReportObjectTypeEXT,
		object                                       : u64,
		location                                     : usize,
		messageCode                                  : i32,
		pLayerPrefix                                 : &[u8],
		pMessage                                     : &[u8]
	) -> () {
		(self.table.pfn_vkDebugReportMessageEXT)(self.handle, flags, objectType, object, location, messageCode, pLayerPrefix.as_ptr() as _, pMessage.as_ptr() as _)
	}
	
	#[cfg(feature = "VK_VERSION_1_1")]
	pub fn enumeratePhysicalDeviceGroups(
		&self,
		pPhysicalDeviceGroupCount                    : &mut u32,
		pPhysicalDeviceGroupProperties               : Option<&mut [VkPhysicalDeviceGroupProperties]>
	) -> VkResult {
		(self.table.pfn_vkEnumeratePhysicalDeviceGroups)(self.handle, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_KHR_device_group_creation")]
	pub fn enumeratePhysicalDeviceGroupsKHR(
		&self,
		pPhysicalDeviceGroupCount                    : &mut u32,
		pPhysicalDeviceGroupProperties               : Option<&mut [VkPhysicalDeviceGroupProperties]>
	) -> VkResult {
		(self.table.pfn_vkEnumeratePhysicalDeviceGroupsKHR)(self.handle, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties.map_or(std::ptr::null_mut(), <[_]>::as_mut_ptr) as _)
	}
	
	#[cfg(feature = "VK_MVK_ios_surface")]
	pub fn createIOSSurfaceMVK(
		&self,
		pCreateInfo                                  : &VkIOSSurfaceCreateInfoMVK,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateIOSSurfaceMVK)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_MVK_macos_surface")]
	pub fn createMacOSSurfaceMVK(
		&self,
		pCreateInfo                                  : &VkMacOSSurfaceCreateInfoMVK,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateMacOSSurfaceMVK)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_metal_surface")]
	pub fn createMetalSurfaceEXT(
		&self,
		pCreateInfo                                  : &VkMetalSurfaceCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateMetalSurfaceEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn createDebugUtilsMessengerEXT(
		&self,
		pCreateInfo                                  : &VkDebugUtilsMessengerCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pMessenger                                   : &mut VkDebugUtilsMessengerEXT
	) -> VkResult {
		(self.table.pfn_vkCreateDebugUtilsMessengerEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pMessenger as *mut _ as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn destroyDebugUtilsMessengerEXT(
		&self,
		messenger                                    : VkDebugUtilsMessengerEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>
	) -> () {
		(self.table.pfn_vkDestroyDebugUtilsMessengerEXT)(self.handle, messenger, pAllocator.map_or(std::ptr::null(), |v| v as _) as _)
	}
	
	#[cfg(feature = "VK_EXT_debug_utils")]
	pub fn submitDebugUtilsMessageEXT(
		&self,
		messageSeverity                              : VkDebugUtilsMessageSeverityFlagBitsEXT,
		messageTypes                                 : VkDebugUtilsMessageTypeFlagsEXT,
		pCallbackData                                : &VkDebugUtilsMessengerCallbackDataEXT
	) -> () {
		(self.table.pfn_vkSubmitDebugUtilsMessageEXT)(self.handle, messageSeverity, messageTypes, pCallbackData as *const _ as _)
	}
	
	#[cfg(feature = "VK_EXT_headless_surface")]
	pub fn createHeadlessSurfaceEXT(
		&self,
		pCreateInfo                                  : &VkHeadlessSurfaceCreateInfoEXT,
		pAllocator                                   : Option<&VkAllocationCallbacks>,
		pSurface                                     : &mut VkSurfaceKHR
	) -> VkResult {
		(self.table.pfn_vkCreateHeadlessSurfaceEXT)(self.handle, pCreateInfo as *const _ as _, pAllocator.map_or(std::ptr::null(), |v| v as _) as _, pSurface as *mut _ as _)
	}
}

/// Wrapper for a `VkFramebuffer` handle
#[derive(Clone, Debug)]
pub struct VkFramebufferImpl {
	pub handle: VkFramebuffer,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkFramebufferImpl {
	type Target = VkFramebuffer;
	
	#[inline]
	fn deref(&self) -> &VkFramebuffer { &self.handle }
}

impl fmt::Display for VkFramebufferImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkFramebufferImpl {
	pub fn new(handle: VkFramebuffer, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkPipelineLayout` handle
#[derive(Clone, Debug)]
pub struct VkPipelineLayoutImpl {
	pub handle: VkPipelineLayout,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkPipelineLayoutImpl {
	type Target = VkPipelineLayout;
	
	#[inline]
	fn deref(&self) -> &VkPipelineLayout { &self.handle }
}

impl fmt::Display for VkPipelineLayoutImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkPipelineLayoutImpl {
	pub fn new(handle: VkPipelineLayout, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkDescriptorPool` handle
#[derive(Clone, Debug)]
pub struct VkDescriptorPoolImpl {
	pub handle: VkDescriptorPool,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkDescriptorPoolImpl {
	type Target = VkDescriptorPool;
	
	#[inline]
	fn deref(&self) -> &VkDescriptorPool { &self.handle }
}

impl fmt::Display for VkDescriptorPoolImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkDescriptorPoolImpl {
	pub fn new(handle: VkDescriptorPool, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkSemaphore` handle
#[derive(Clone, Debug)]
pub struct VkSemaphoreImpl {
	pub handle: VkSemaphore,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkSemaphoreImpl {
	type Target = VkSemaphore;
	
	#[inline]
	fn deref(&self) -> &VkSemaphore { &self.handle }
}

impl fmt::Display for VkSemaphoreImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkSemaphoreImpl {
	pub fn new(handle: VkSemaphore, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

/// Wrapper for a `VkVideoSessionParametersKHR` handle
#[derive(Clone, Debug)]
pub struct VkVideoSessionParametersKHRImpl {
	pub handle: VkVideoSessionParametersKHR,
	pub table:  Arc<VkDeviceTable>
}

impl ops::Deref for VkVideoSessionParametersKHRImpl {
	type Target = VkVideoSessionParametersKHR;
	
	#[inline]
	fn deref(&self) -> &VkVideoSessionParametersKHR { &self.handle }
}

impl fmt::Display for VkVideoSessionParametersKHRImpl {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "{:#x}", self.handle)
	}
}

impl VkVideoSessionParametersKHRImpl {
	pub fn new(handle: VkVideoSessionParametersKHR, parent: &VkDeviceImpl) -> Self {
		Self { handle, table: parent.table.clone() }
	}
}

pub struct VkInstanceTable {
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceProperties           : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceProperties) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceQueueFamilyProperties: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkQueueFamilyProperties) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceMemoryProperties     : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceMemoryProperties) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceFeatures             : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceFeatures) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceFormatProperties     : extern "C" fn(VkPhysicalDevice, VkFormat, *mut VkFormatProperties) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceImageFormatProperties: extern "C" fn(VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlags, *mut VkImageFormatProperties) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateDevice                          : extern "C" fn(VkPhysicalDevice, *const VkDeviceCreateInfo, *const VkAllocationCallbacks, *mut VkDevice) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumerateDeviceLayerProperties        : extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkLayerProperties) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumerateDeviceExtensionProperties    : extern "C" fn(VkPhysicalDevice, *const u8, *mut u32, *mut VkExtensionProperties) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPhysicalDeviceSparseImageFormatProperties: extern "C" fn(VkPhysicalDevice, VkFormat, VkImageType, VkSampleCountFlagBits, VkImageUsageFlags, VkImageTiling, *mut u32, *mut VkSparseImageFormatProperties) -> (),
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkGetPhysicalDeviceDisplayPropertiesKHR : extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkDisplayPropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkGetPhysicalDeviceDisplayPlanePropertiesKHR: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkDisplayPlanePropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkGetDisplayPlaneSupportedDisplaysKHR   : extern "C" fn(VkPhysicalDevice, u32, *mut u32, *mut VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkGetDisplayModePropertiesKHR           : extern "C" fn(VkPhysicalDevice, VkDisplayKHR, *mut u32, *mut VkDisplayModePropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkCreateDisplayModeKHR                  : extern "C" fn(VkPhysicalDevice, VkDisplayKHR, *const VkDisplayModeCreateInfoKHR, *const VkAllocationCallbacks, *mut VkDisplayModeKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkGetDisplayPlaneCapabilitiesKHR        : extern "C" fn(VkPhysicalDevice, VkDisplayModeKHR, u32, *mut VkDisplayPlaneCapabilitiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_surface")]
	pfn_vkGetPhysicalDeviceSurfaceSupportKHR    : extern "C" fn(VkPhysicalDevice, u32, VkSurfaceKHR, *mut VkBool32) -> VkResult,
	#[cfg(feature = "VK_KHR_surface")]
	pfn_vkGetPhysicalDeviceSurfaceCapabilitiesKHR: extern "C" fn(VkPhysicalDevice, VkSurfaceKHR, *mut VkSurfaceCapabilitiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_surface")]
	pfn_vkGetPhysicalDeviceSurfaceFormatsKHR    : extern "C" fn(VkPhysicalDevice, VkSurfaceKHR, *mut u32, *mut VkSurfaceFormatKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_surface")]
	pfn_vkGetPhysicalDeviceSurfacePresentModesKHR: extern "C" fn(VkPhysicalDevice, VkSurfaceKHR, *mut u32, *mut VkPresentModeKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_wayland_surface")]
	pfn_vkGetPhysicalDeviceWaylandPresentationSupportKHR: extern "C" fn(VkPhysicalDevice, u32, *mut wl_display) -> VkBool32,
	#[cfg(feature = "VK_KHR_win32_surface")]
	pfn_vkGetPhysicalDeviceWin32PresentationSupportKHR: extern "C" fn(VkPhysicalDevice, u32) -> VkBool32,
	#[cfg(feature = "VK_KHR_xlib_surface")]
	pfn_vkGetPhysicalDeviceXlibPresentationSupportKHR: extern "C" fn(VkPhysicalDevice, u32, *mut Display, VisualID) -> VkBool32,
	#[cfg(feature = "VK_KHR_xcb_surface")]
	pfn_vkGetPhysicalDeviceXcbPresentationSupportKHR: extern "C" fn(VkPhysicalDevice, u32, *mut xcb_connection_t, xcb_visualid_t) -> VkBool32,
	#[cfg(feature = "VK_EXT_directfb_surface")]
	pfn_vkGetPhysicalDeviceDirectFBPresentationSupportEXT: extern "C" fn(VkPhysicalDevice, u32, *mut IDirectFB) -> VkBool32,
	#[cfg(feature = "VK_QNX_screen_surface")]
	pfn_vkGetPhysicalDeviceScreenPresentationSupportQNX: extern "C" fn(VkPhysicalDevice, u32, *mut _screen_window) -> VkBool32,
	#[cfg(feature = "VK_NV_external_memory_capabilities")]
	pfn_vkGetPhysicalDeviceExternalImageFormatPropertiesNV: extern "C" fn(VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlags, VkExternalMemoryHandleTypeFlagsNV, *mut VkExternalImageFormatPropertiesNV) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceFeatures2            : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceFeatures2) -> (),
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceFeatures2KHR         : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceFeatures2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceProperties2          : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceProperties2) -> (),
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceProperties2KHR       : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceProperties2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceFormatProperties2    : extern "C" fn(VkPhysicalDevice, VkFormat, *mut VkFormatProperties2) -> (),
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceFormatProperties2KHR : extern "C" fn(VkPhysicalDevice, VkFormat, *mut VkFormatProperties2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceImageFormatProperties2: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceImageFormatInfo2, *mut VkImageFormatProperties2) -> VkResult,
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceImageFormatProperties2KHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceImageFormatInfo2, *mut VkImageFormatProperties2) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceQueueFamilyProperties2: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkQueueFamilyProperties2) -> (),
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceQueueFamilyProperties2KHR: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkQueueFamilyProperties2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceMemoryProperties2    : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceMemoryProperties2) -> (),
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceMemoryProperties2KHR : extern "C" fn(VkPhysicalDevice, *mut VkPhysicalDeviceMemoryProperties2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceSparseImageFormatProperties2: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceSparseImageFormatInfo2, *mut u32, *mut VkSparseImageFormatProperties2) -> (),
	#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
	pfn_vkGetPhysicalDeviceSparseImageFormatProperties2KHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceSparseImageFormatInfo2, *mut u32, *mut VkSparseImageFormatProperties2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceExternalBufferProperties: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceExternalBufferInfo, *mut VkExternalBufferProperties) -> (),
	#[cfg(feature = "VK_KHR_external_memory_capabilities")]
	pfn_vkGetPhysicalDeviceExternalBufferPropertiesKHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceExternalBufferInfo, *mut VkExternalBufferProperties) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceExternalSemaphoreProperties: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceExternalSemaphoreInfo, *mut VkExternalSemaphoreProperties) -> (),
	#[cfg(feature = "VK_KHR_external_semaphore_capabilities")]
	pfn_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceExternalSemaphoreInfo, *mut VkExternalSemaphoreProperties) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetPhysicalDeviceExternalFenceProperties: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceExternalFenceInfo, *mut VkExternalFenceProperties) -> (),
	#[cfg(feature = "VK_KHR_external_fence_capabilities")]
	pfn_vkGetPhysicalDeviceExternalFencePropertiesKHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceExternalFenceInfo, *mut VkExternalFenceProperties) -> (),
	#[cfg(feature = "VK_EXT_direct_mode_display")]
	pfn_vkReleaseDisplayEXT                     : extern "C" fn(VkPhysicalDevice, VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_acquire_xlib_display")]
	pfn_vkAcquireXlibDisplayEXT                 : extern "C" fn(VkPhysicalDevice, *mut Display, VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_acquire_xlib_display")]
	pfn_vkGetRandROutputDisplayEXT              : extern "C" fn(VkPhysicalDevice, *mut Display, RROutput, *mut VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_NV_acquire_winrt_display")]
	pfn_vkAcquireWinrtDisplayNV                 : extern "C" fn(VkPhysicalDevice, VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_NV_acquire_winrt_display")]
	pfn_vkGetWinrtDisplayNV                     : extern "C" fn(VkPhysicalDevice, u32, *mut VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_display_surface_counter")]
	pfn_vkGetPhysicalDeviceSurfaceCapabilities2EXT: extern "C" fn(VkPhysicalDevice, VkSurfaceKHR, *mut VkSurfaceCapabilities2EXT) -> VkResult,
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkGetPhysicalDevicePresentRectanglesKHR : extern "C" fn(VkPhysicalDevice, VkSurfaceKHR, *mut u32, *mut VkRect2D) -> VkResult,
	#[cfg(feature = "VK_EXT_sample_locations")]
	pfn_vkGetPhysicalDeviceMultisamplePropertiesEXT: extern "C" fn(VkPhysicalDevice, VkSampleCountFlagBits, *mut VkMultisamplePropertiesEXT) -> (),
	#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
	pfn_vkGetPhysicalDeviceSurfaceCapabilities2KHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceSurfaceInfo2KHR, *mut VkSurfaceCapabilities2KHR) -> VkResult,
	#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
	pfn_vkGetPhysicalDeviceSurfaceFormats2KHR   : extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceSurfaceInfo2KHR, *mut u32, *mut VkSurfaceFormat2KHR) -> VkResult,
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pfn_vkGetPhysicalDeviceDisplayProperties2KHR: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkDisplayProperties2KHR) -> VkResult,
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pfn_vkGetPhysicalDeviceDisplayPlaneProperties2KHR: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkDisplayPlaneProperties2KHR) -> VkResult,
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pfn_vkGetDisplayModeProperties2KHR          : extern "C" fn(VkPhysicalDevice, VkDisplayKHR, *mut u32, *mut VkDisplayModeProperties2KHR) -> VkResult,
	#[cfg(feature = "VK_KHR_get_display_properties2")]
	pfn_vkGetDisplayPlaneCapabilities2KHR       : extern "C" fn(VkPhysicalDevice, *const VkDisplayPlaneInfo2KHR, *mut VkDisplayPlaneCapabilities2KHR) -> VkResult,
	#[cfg(feature = "VK_EXT_calibrated_timestamps")]
	pfn_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkTimeDomainEXT) -> VkResult,
	#[cfg(feature = "VK_NV_cooperative_matrix")]
	pfn_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkCooperativeMatrixPropertiesNV) -> VkResult,
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pfn_vkGetPhysicalDeviceSurfacePresentModes2EXT: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceSurfaceInfo2KHR, *mut u32, *mut VkPresentModeKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_performance_query")]
	pfn_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: extern "C" fn(VkPhysicalDevice, u32, *mut u32, *mut VkPerformanceCounterKHR, *mut VkPerformanceCounterDescriptionKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_performance_query")]
	pfn_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR: extern "C" fn(VkPhysicalDevice, *const VkQueryPoolPerformanceCreateInfoKHR, *mut u32) -> (),
	#[cfg(feature = "VK_NV_coverage_reduction_mode")]
	pfn_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult,
	#[cfg(feature = "VK_EXT_tooling_info")]
	pfn_vkGetPhysicalDeviceToolPropertiesEXT    : extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkPhysicalDeviceToolPropertiesEXT) -> VkResult,
	#[cfg(feature = "VK_KHR_fragment_shading_rate")]
	pfn_vkGetPhysicalDeviceFragmentShadingRatesKHR: extern "C" fn(VkPhysicalDevice, *mut u32, *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkGetPhysicalDeviceVideoCapabilitiesKHR : extern "C" fn(VkPhysicalDevice, *const VkVideoProfileKHR, *mut VkVideoCapabilitiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkGetPhysicalDeviceVideoFormatPropertiesKHR: extern "C" fn(VkPhysicalDevice, *const VkPhysicalDeviceVideoFormatInfoKHR, *mut u32, *mut VkVideoFormatPropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_acquire_drm_display")]
	pfn_vkAcquireDrmDisplayEXT                  : extern "C" fn(VkPhysicalDevice, i32, VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_acquire_drm_display")]
	pfn_vkGetDrmDisplayEXT                      : extern "C" fn(VkPhysicalDevice, i32, u32, *mut VkDisplayKHR) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyInstance                       : extern "C" fn(VkInstance, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumeratePhysicalDevices              : extern "C" fn(VkInstance, *mut u32, *mut VkPhysicalDevice) -> VkResult,
	#[cfg(feature = "VK_KHR_android_surface")]
	pfn_vkCreateAndroidSurfaceKHR               : extern "C" fn(VkInstance, *const VkAndroidSurfaceCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_display")]
	pfn_vkCreateDisplayPlaneSurfaceKHR          : extern "C" fn(VkInstance, *const VkDisplaySurfaceCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_surface")]
	pfn_vkDestroySurfaceKHR                     : extern "C" fn(VkInstance, VkSurfaceKHR, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_NN_vi_surface")]
	pfn_vkCreateViSurfaceNN                     : extern "C" fn(VkInstance, *const VkViSurfaceCreateInfoNN, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_wayland_surface")]
	pfn_vkCreateWaylandSurfaceKHR               : extern "C" fn(VkInstance, *const VkWaylandSurfaceCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_win32_surface")]
	pfn_vkCreateWin32SurfaceKHR                 : extern "C" fn(VkInstance, *const VkWin32SurfaceCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_xlib_surface")]
	pfn_vkCreateXlibSurfaceKHR                  : extern "C" fn(VkInstance, *const VkXlibSurfaceCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_xcb_surface")]
	pfn_vkCreateXcbSurfaceKHR                   : extern "C" fn(VkInstance, *const VkXcbSurfaceCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_directfb_surface")]
	pfn_vkCreateDirectFBSurfaceEXT              : extern "C" fn(VkInstance, *const VkDirectFBSurfaceCreateInfoEXT, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
	pfn_vkCreateImagePipeSurfaceFUCHSIA         : extern "C" fn(VkInstance, *const VkImagePipeSurfaceCreateInfoFUCHSIA, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_GGP_stream_descriptor_surface")]
	pfn_vkCreateStreamDescriptorSurfaceGGP      : extern "C" fn(VkInstance, *const VkStreamDescriptorSurfaceCreateInfoGGP, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_QNX_screen_surface")]
	pfn_vkCreateScreenSurfaceQNX                : extern "C" fn(VkInstance, *const VkScreenSurfaceCreateInfoQNX, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_report")]
	pfn_vkCreateDebugReportCallbackEXT          : extern "C" fn(VkInstance, *const VkDebugReportCallbackCreateInfoEXT, *const VkAllocationCallbacks, *mut VkDebugReportCallbackEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_report")]
	pfn_vkDestroyDebugReportCallbackEXT         : extern "C" fn(VkInstance, VkDebugReportCallbackEXT, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_EXT_debug_report")]
	pfn_vkDebugReportMessageEXT                 : extern "C" fn(VkInstance, VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, u64, usize, i32, *const u8, *const u8) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkEnumeratePhysicalDeviceGroups         : extern "C" fn(VkInstance, *mut u32, *mut VkPhysicalDeviceGroupProperties) -> VkResult,
	#[cfg(feature = "VK_KHR_device_group_creation")]
	pfn_vkEnumeratePhysicalDeviceGroupsKHR      : extern "C" fn(VkInstance, *mut u32, *mut VkPhysicalDeviceGroupProperties) -> VkResult,
	#[cfg(feature = "VK_MVK_ios_surface")]
	pfn_vkCreateIOSSurfaceMVK                   : extern "C" fn(VkInstance, *const VkIOSSurfaceCreateInfoMVK, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_MVK_macos_surface")]
	pfn_vkCreateMacOSSurfaceMVK                 : extern "C" fn(VkInstance, *const VkMacOSSurfaceCreateInfoMVK, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_metal_surface")]
	pfn_vkCreateMetalSurfaceEXT                 : extern "C" fn(VkInstance, *const VkMetalSurfaceCreateInfoEXT, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkCreateDebugUtilsMessengerEXT          : extern "C" fn(VkInstance, *const VkDebugUtilsMessengerCreateInfoEXT, *const VkAllocationCallbacks, *mut VkDebugUtilsMessengerEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkDestroyDebugUtilsMessengerEXT         : extern "C" fn(VkInstance, VkDebugUtilsMessengerEXT, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkSubmitDebugUtilsMessageEXT            : extern "C" fn(VkInstance, VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT, *const VkDebugUtilsMessengerCallbackDataEXT) -> (),
	#[cfg(feature = "VK_EXT_headless_surface")]
	pfn_vkCreateHeadlessSurfaceEXT              : extern "C" fn(VkInstance, *const VkHeadlessSurfaceCreateInfoEXT, *const VkAllocationCallbacks, *mut VkSurfaceKHR) -> VkResult,
	pfn_vkGetDeviceProcAddr                                    : extern fn(VkDevice, *const u8) -> PFN_vkVoidFunction,
}

impl VkInstanceTable {
	fn load(handle: VkInstance) -> Arc<Self> {
		let table = unsafe { &LIB_VULKAN };
		Arc::new(unsafe { Self {
			
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceProperties                               : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceQueueFamilyProperties                    : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceQueueFamilyProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceMemoryProperties                         : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceMemoryProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceFeatures                                 : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFeatures\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceFormatProperties                         : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFormatProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceImageFormatProperties                    : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceImageFormatProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateDevice                                              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateDevice\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkEnumerateDeviceLayerProperties                            : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkEnumerateDeviceLayerProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkEnumerateDeviceExtensionProperties                        : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkEnumerateDeviceExtensionProperties\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPhysicalDeviceSparseImageFormatProperties              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSparseImageFormatProperties\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkGetPhysicalDeviceDisplayPropertiesKHR                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceDisplayPropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkGetPhysicalDeviceDisplayPlanePropertiesKHR                : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceDisplayPlanePropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkGetDisplayPlaneSupportedDisplaysKHR                       : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDisplayPlaneSupportedDisplaysKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkGetDisplayModePropertiesKHR                               : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDisplayModePropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkCreateDisplayModeKHR                                      : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateDisplayModeKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkGetDisplayPlaneCapabilitiesKHR                            : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDisplayPlaneCapabilitiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_surface")]
			pfn_vkGetPhysicalDeviceSurfaceSupportKHR                        : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfaceSupportKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_surface")]
			pfn_vkGetPhysicalDeviceSurfaceCapabilitiesKHR                   : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfaceCapabilitiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_surface")]
			pfn_vkGetPhysicalDeviceSurfaceFormatsKHR                        : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfaceFormatsKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_surface")]
			pfn_vkGetPhysicalDeviceSurfacePresentModesKHR                   : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfacePresentModesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_wayland_surface")]
			pfn_vkGetPhysicalDeviceWaylandPresentationSupportKHR            : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceWaylandPresentationSupportKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_win32_surface")]
			pfn_vkGetPhysicalDeviceWin32PresentationSupportKHR              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceWin32PresentationSupportKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_xlib_surface")]
			pfn_vkGetPhysicalDeviceXlibPresentationSupportKHR               : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceXlibPresentationSupportKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_xcb_surface")]
			pfn_vkGetPhysicalDeviceXcbPresentationSupportKHR                : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceXcbPresentationSupportKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_directfb_surface")]
			pfn_vkGetPhysicalDeviceDirectFBPresentationSupportEXT           : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceDirectFBPresentationSupportEXT\0".as_ptr())),
			#[cfg(feature = "VK_QNX_screen_surface")]
			pfn_vkGetPhysicalDeviceScreenPresentationSupportQNX             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceScreenPresentationSupportQNX\0".as_ptr())),
			#[cfg(feature = "VK_NV_external_memory_capabilities")]
			pfn_vkGetPhysicalDeviceExternalImageFormatPropertiesNV          : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalImageFormatPropertiesNV\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceFeatures2                                : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFeatures2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceFeatures2KHR                             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFeatures2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceProperties2                              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceProperties2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceProperties2KHR                           : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceFormatProperties2                        : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFormatProperties2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceFormatProperties2KHR                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFormatProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceImageFormatProperties2                   : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceImageFormatProperties2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceImageFormatProperties2KHR                : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceImageFormatProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceQueueFamilyProperties2                   : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceQueueFamilyProperties2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceQueueFamilyProperties2KHR                : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceQueueFamilyProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceMemoryProperties2                        : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceMemoryProperties2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceMemoryProperties2KHR                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceMemoryProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceSparseImageFormatProperties2             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSparseImageFormatProperties2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_physical_device_properties2")]
			pfn_vkGetPhysicalDeviceSparseImageFormatProperties2KHR          : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSparseImageFormatProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceExternalBufferProperties                 : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalBufferProperties\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_memory_capabilities")]
			pfn_vkGetPhysicalDeviceExternalBufferPropertiesKHR              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalBufferPropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceExternalSemaphoreProperties              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalSemaphoreProperties\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_semaphore_capabilities")]
			pfn_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR           : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalSemaphorePropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetPhysicalDeviceExternalFenceProperties                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalFenceProperties\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_fence_capabilities")]
			pfn_vkGetPhysicalDeviceExternalFencePropertiesKHR               : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceExternalFencePropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_direct_mode_display")]
			pfn_vkReleaseDisplayEXT                                         : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkReleaseDisplayEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_acquire_xlib_display")]
			pfn_vkAcquireXlibDisplayEXT                                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkAcquireXlibDisplayEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_acquire_xlib_display")]
			pfn_vkGetRandROutputDisplayEXT                                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetRandROutputDisplayEXT\0".as_ptr())),
			#[cfg(feature = "VK_NV_acquire_winrt_display")]
			pfn_vkAcquireWinrtDisplayNV                                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkAcquireWinrtDisplayNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_acquire_winrt_display")]
			pfn_vkGetWinrtDisplayNV                                         : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetWinrtDisplayNV\0".as_ptr())),
			#[cfg(feature = "VK_EXT_display_surface_counter")]
			pfn_vkGetPhysicalDeviceSurfaceCapabilities2EXT                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfaceCapabilities2EXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkGetPhysicalDevicePresentRectanglesKHR                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDevicePresentRectanglesKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_sample_locations")]
			pfn_vkGetPhysicalDeviceMultisamplePropertiesEXT                 : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceMultisamplePropertiesEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
			pfn_vkGetPhysicalDeviceSurfaceCapabilities2KHR                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfaceCapabilities2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
			pfn_vkGetPhysicalDeviceSurfaceFormats2KHR                       : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfaceFormats2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_display_properties2")]
			pfn_vkGetPhysicalDeviceDisplayProperties2KHR                    : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceDisplayProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_display_properties2")]
			pfn_vkGetPhysicalDeviceDisplayPlaneProperties2KHR               : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceDisplayPlaneProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_display_properties2")]
			pfn_vkGetDisplayModeProperties2KHR                              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDisplayModeProperties2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_display_properties2")]
			pfn_vkGetDisplayPlaneCapabilities2KHR                           : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDisplayPlaneCapabilities2KHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_calibrated_timestamps")]
			pfn_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT\0".as_ptr())),
			#[cfg(feature = "VK_NV_cooperative_matrix")]
			pfn_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV            : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV\0".as_ptr())),
			#[cfg(feature = "VK_EXT_full_screen_exclusive")]
			pfn_vkGetPhysicalDeviceSurfacePresentModes2EXT                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSurfacePresentModes2EXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_performance_query")]
			pfn_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_performance_query")]
			pfn_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_coverage_reduction_mode")]
			pfn_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV\0".as_ptr())),
			#[cfg(feature = "VK_EXT_tooling_info")]
			pfn_vkGetPhysicalDeviceToolPropertiesEXT                        : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceToolPropertiesEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_fragment_shading_rate")]
			pfn_vkGetPhysicalDeviceFragmentShadingRatesKHR                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceFragmentShadingRatesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkGetPhysicalDeviceVideoCapabilitiesKHR                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceVideoCapabilitiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkGetPhysicalDeviceVideoFormatPropertiesKHR                 : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetPhysicalDeviceVideoFormatPropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_acquire_drm_display")]
			pfn_vkAcquireDrmDisplayEXT                                      : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkAcquireDrmDisplayEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_acquire_drm_display")]
			pfn_vkGetDrmDisplayEXT                                          : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDrmDisplayEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyInstance                                           : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkDestroyInstance\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkEnumeratePhysicalDevices                                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkEnumeratePhysicalDevices\0".as_ptr())),
			#[cfg(feature = "VK_KHR_android_surface")]
			pfn_vkCreateAndroidSurfaceKHR                                   : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateAndroidSurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display")]
			pfn_vkCreateDisplayPlaneSurfaceKHR                              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateDisplayPlaneSurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_surface")]
			pfn_vkDestroySurfaceKHR                                         : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkDestroySurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_NN_vi_surface")]
			pfn_vkCreateViSurfaceNN                                         : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateViSurfaceNN\0".as_ptr())),
			#[cfg(feature = "VK_KHR_wayland_surface")]
			pfn_vkCreateWaylandSurfaceKHR                                   : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateWaylandSurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_win32_surface")]
			pfn_vkCreateWin32SurfaceKHR                                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateWin32SurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_xlib_surface")]
			pfn_vkCreateXlibSurfaceKHR                                      : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateXlibSurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_xcb_surface")]
			pfn_vkCreateXcbSurfaceKHR                                       : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateXcbSurfaceKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_directfb_surface")]
			pfn_vkCreateDirectFBSurfaceEXT                                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateDirectFBSurfaceEXT\0".as_ptr())),
			#[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
			pfn_vkCreateImagePipeSurfaceFUCHSIA                             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateImagePipeSurfaceFUCHSIA\0".as_ptr())),
			#[cfg(feature = "VK_GGP_stream_descriptor_surface")]
			pfn_vkCreateStreamDescriptorSurfaceGGP                          : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateStreamDescriptorSurfaceGGP\0".as_ptr())),
			#[cfg(feature = "VK_QNX_screen_surface")]
			pfn_vkCreateScreenSurfaceQNX                                    : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateScreenSurfaceQNX\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_report")]
			pfn_vkCreateDebugReportCallbackEXT                              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateDebugReportCallbackEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_report")]
			pfn_vkDestroyDebugReportCallbackEXT                             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkDestroyDebugReportCallbackEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_report")]
			pfn_vkDebugReportMessageEXT                                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkDebugReportMessageEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkEnumeratePhysicalDeviceGroups                             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkEnumeratePhysicalDeviceGroups\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group_creation")]
			pfn_vkEnumeratePhysicalDeviceGroupsKHR                          : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkEnumeratePhysicalDeviceGroupsKHR\0".as_ptr())),
			#[cfg(feature = "VK_MVK_ios_surface")]
			pfn_vkCreateIOSSurfaceMVK                                       : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateIOSSurfaceMVK\0".as_ptr())),
			#[cfg(feature = "VK_MVK_macos_surface")]
			pfn_vkCreateMacOSSurfaceMVK                                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateMacOSSurfaceMVK\0".as_ptr())),
			#[cfg(feature = "VK_EXT_metal_surface")]
			pfn_vkCreateMetalSurfaceEXT                                     : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateMetalSurfaceEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkCreateDebugUtilsMessengerEXT                              : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateDebugUtilsMessengerEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkDestroyDebugUtilsMessengerEXT                             : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkDestroyDebugUtilsMessengerEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkSubmitDebugUtilsMessageEXT                                : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkSubmitDebugUtilsMessageEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_headless_surface")]
			pfn_vkCreateHeadlessSurfaceEXT                                  : transmute((table.pfn_vkGetInstanceProcAddr)(handle, b"vkCreateHeadlessSurfaceEXT\0".as_ptr())),
			pfn_vkGetDeviceProcAddr                                         : transmute((LIB_VULKAN.pfn_vkGetInstanceProcAddr)(handle, b"vkGetDeviceProcAddr\0".as_ptr())),
		} })
	}
}

impl fmt::Debug for VkInstanceTable {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkInstanceTable").finish()
	}
}


static mut LIB_VULKAN: LibVulkan = LibVulkan {
	lib: None,
	pfn_vkGetInstanceProcAddr: { extern fn load(handle: VkInstance, name: *const u8) -> PFN_vkVoidFunction { unsafe { LIB_VULKAN.load(); (LIB_VULKAN.pfn_vkGetInstanceProcAddr)(handle, name) } } load },
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateInstance                        : { extern "C" fn load(pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance, ) -> VkResult { unsafe { LIB_VULKAN.load(); (LIB_VULKAN.pfn_vkCreateInstance)(pCreateInfo, pAllocator, pInstance, ) } } load },
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkEnumerateInstanceVersion              : { extern "C" fn load(pApiVersion: *mut u32, ) -> VkResult { unsafe { LIB_VULKAN.load(); (LIB_VULKAN.pfn_vkEnumerateInstanceVersion)(pApiVersion, ) } } load },
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumerateInstanceLayerProperties      : { extern "C" fn load(pPropertyCount: *mut u32, pProperties: *mut VkLayerProperties, ) -> VkResult { unsafe { LIB_VULKAN.load(); (LIB_VULKAN.pfn_vkEnumerateInstanceLayerProperties)(pPropertyCount, pProperties, ) } } load },
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumerateInstanceExtensionProperties  : { extern "C" fn load(pLayerName: *const u8, pPropertyCount: *mut u32, pProperties: *mut VkExtensionProperties, ) -> VkResult { unsafe { LIB_VULKAN.load(); (LIB_VULKAN.pfn_vkEnumerateInstanceExtensionProperties)(pLayerName, pPropertyCount, pProperties, ) } } load },
};

pub struct LibVulkan {
	#[allow(dead_code)]
	lib: Option<libloading::Library>,
	pfn_vkGetInstanceProcAddr: extern fn(VkInstance, *const u8) -> PFN_vkVoidFunction,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateInstance                        : extern "C" fn(*const VkInstanceCreateInfo, *const VkAllocationCallbacks, *mut VkInstance) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkEnumerateInstanceVersion              : extern "C" fn(*mut u32) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumerateInstanceLayerProperties      : extern "C" fn(*mut u32, *mut VkLayerProperties) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEnumerateInstanceExtensionProperties  : extern "C" fn(*const u8, *mut u32, *mut VkExtensionProperties) -> VkResult,
}

impl LibVulkan {
	unsafe fn load(&mut self) {
		let lib                                          = libloading::Library::new(LIB).expect("failed to load `libvulkan`");
		self.pfn_vkGetInstanceProcAddr                   = *lib.get(b"vkGetInstanceProcAddr\0").expect("failed to load `vkGetInstanceProcAddr`");
		self.lib                                         = Some(lib);
		
		#[cfg(feature = "VK_VERSION_1_0")]
			{
				self.pfn_vkCreateInstance                        = transmute((self.pfn_vkGetInstanceProcAddr)(VK_NULL_HANDLE, b"vkCreateInstance\0".as_ptr()));
			}
		#[cfg(feature = "VK_VERSION_1_1")]
			{
				self.pfn_vkEnumerateInstanceVersion              = transmute((self.pfn_vkGetInstanceProcAddr)(VK_NULL_HANDLE, b"vkEnumerateInstanceVersion\0".as_ptr()));
			}
		#[cfg(feature = "VK_VERSION_1_0")]
			{
				self.pfn_vkEnumerateInstanceLayerProperties      = transmute((self.pfn_vkGetInstanceProcAddr)(VK_NULL_HANDLE, b"vkEnumerateInstanceLayerProperties\0".as_ptr()));
			}
		#[cfg(feature = "VK_VERSION_1_0")]
			{
				self.pfn_vkEnumerateInstanceExtensionProperties  = transmute((self.pfn_vkGetInstanceProcAddr)(VK_NULL_HANDLE, b"vkEnumerateInstanceExtensionProperties\0".as_ptr()));
			}
	}
}


pub struct VkDeviceTable {
	
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyDevice                         : extern "C" fn(VkDevice, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetDeviceQueue                        : extern "C" fn(VkDevice, u32, u32, *mut VkQueue) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDeviceWaitIdle                        : extern "C" fn(VkDevice) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkAllocateMemory                        : extern "C" fn(VkDevice, *const VkMemoryAllocateInfo, *const VkAllocationCallbacks, *mut VkDeviceMemory) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkFreeMemory                            : extern "C" fn(VkDevice, VkDeviceMemory, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkMapMemory                             : extern "C" fn(VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, *mut *mut ()) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkUnmapMemory                           : extern "C" fn(VkDevice, VkDeviceMemory) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkFlushMappedMemoryRanges               : extern "C" fn(VkDevice, u32, *const VkMappedMemoryRange) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkInvalidateMappedMemoryRanges          : extern "C" fn(VkDevice, u32, *const VkMappedMemoryRange) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetDeviceMemoryCommitment             : extern "C" fn(VkDevice, VkDeviceMemory, *mut VkDeviceSize) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetBufferMemoryRequirements           : extern "C" fn(VkDevice, VkBuffer, *mut VkMemoryRequirements) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkBindBufferMemory                      : extern "C" fn(VkDevice, VkBuffer, VkDeviceMemory, VkDeviceSize) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetImageMemoryRequirements            : extern "C" fn(VkDevice, VkImage, *mut VkMemoryRequirements) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkBindImageMemory                       : extern "C" fn(VkDevice, VkImage, VkDeviceMemory, VkDeviceSize) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetImageSparseMemoryRequirements      : extern "C" fn(VkDevice, VkImage, *mut u32, *mut VkSparseImageMemoryRequirements) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateFence                           : extern "C" fn(VkDevice, *const VkFenceCreateInfo, *const VkAllocationCallbacks, *mut VkFence) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyFence                          : extern "C" fn(VkDevice, VkFence, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkResetFences                           : extern "C" fn(VkDevice, u32, *const VkFence) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetFenceStatus                        : extern "C" fn(VkDevice, VkFence) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkWaitForFences                         : extern "C" fn(VkDevice, u32, *const VkFence, VkBool32, u64) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateSemaphore                       : extern "C" fn(VkDevice, *const VkSemaphoreCreateInfo, *const VkAllocationCallbacks, *mut VkSemaphore) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroySemaphore                      : extern "C" fn(VkDevice, VkSemaphore, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateEvent                           : extern "C" fn(VkDevice, *const VkEventCreateInfo, *const VkAllocationCallbacks, *mut VkEvent) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyEvent                          : extern "C" fn(VkDevice, VkEvent, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetEventStatus                        : extern "C" fn(VkDevice, VkEvent) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkSetEvent                              : extern "C" fn(VkDevice, VkEvent) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkResetEvent                            : extern "C" fn(VkDevice, VkEvent) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateQueryPool                       : extern "C" fn(VkDevice, *const VkQueryPoolCreateInfo, *const VkAllocationCallbacks, *mut VkQueryPool) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyQueryPool                      : extern "C" fn(VkDevice, VkQueryPool, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetQueryPoolResults                   : extern "C" fn(VkDevice, VkQueryPool, u32, u32, usize, *mut (), VkDeviceSize, VkQueryResultFlags) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkResetQueryPool                        : extern "C" fn(VkDevice, VkQueryPool, u32, u32) -> (),
	#[cfg(feature = "VK_EXT_host_query_reset")]
	pfn_vkResetQueryPoolEXT                     : extern "C" fn(VkDevice, VkQueryPool, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateBuffer                          : extern "C" fn(VkDevice, *const VkBufferCreateInfo, *const VkAllocationCallbacks, *mut VkBuffer) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyBuffer                         : extern "C" fn(VkDevice, VkBuffer, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateBufferView                      : extern "C" fn(VkDevice, *const VkBufferViewCreateInfo, *const VkAllocationCallbacks, *mut VkBufferView) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyBufferView                     : extern "C" fn(VkDevice, VkBufferView, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateImage                           : extern "C" fn(VkDevice, *const VkImageCreateInfo, *const VkAllocationCallbacks, *mut VkImage) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyImage                          : extern "C" fn(VkDevice, VkImage, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetImageSubresourceLayout             : extern "C" fn(VkDevice, VkImage, *const VkImageSubresource, *mut VkSubresourceLayout) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateImageView                       : extern "C" fn(VkDevice, *const VkImageViewCreateInfo, *const VkAllocationCallbacks, *mut VkImageView) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyImageView                      : extern "C" fn(VkDevice, VkImageView, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateShaderModule                    : extern "C" fn(VkDevice, *const VkShaderModuleCreateInfo, *const VkAllocationCallbacks, *mut VkShaderModule) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyShaderModule                   : extern "C" fn(VkDevice, VkShaderModule, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreatePipelineCache                   : extern "C" fn(VkDevice, *const VkPipelineCacheCreateInfo, *const VkAllocationCallbacks, *mut VkPipelineCache) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyPipelineCache                  : extern "C" fn(VkDevice, VkPipelineCache, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetPipelineCacheData                  : extern "C" fn(VkDevice, VkPipelineCache, *mut usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkMergePipelineCaches                   : extern "C" fn(VkDevice, VkPipelineCache, u32, *const VkPipelineCache) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateGraphicsPipelines               : extern "C" fn(VkDevice, VkPipelineCache, u32, *const VkGraphicsPipelineCreateInfo, *const VkAllocationCallbacks, *mut VkPipeline) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateComputePipelines                : extern "C" fn(VkDevice, VkPipelineCache, u32, *const VkComputePipelineCreateInfo, *const VkAllocationCallbacks, *mut VkPipeline) -> VkResult,
	#[cfg(feature = "VK_HUAWEI_subpass_shading")]
	pfn_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI: extern "C" fn(VkDevice, VkRenderPass, *mut VkExtent2D) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyPipeline                       : extern "C" fn(VkDevice, VkPipeline, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreatePipelineLayout                  : extern "C" fn(VkDevice, *const VkPipelineLayoutCreateInfo, *const VkAllocationCallbacks, *mut VkPipelineLayout) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyPipelineLayout                 : extern "C" fn(VkDevice, VkPipelineLayout, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateSampler                         : extern "C" fn(VkDevice, *const VkSamplerCreateInfo, *const VkAllocationCallbacks, *mut VkSampler) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroySampler                        : extern "C" fn(VkDevice, VkSampler, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateDescriptorSetLayout             : extern "C" fn(VkDevice, *const VkDescriptorSetLayoutCreateInfo, *const VkAllocationCallbacks, *mut VkDescriptorSetLayout) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyDescriptorSetLayout            : extern "C" fn(VkDevice, VkDescriptorSetLayout, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateDescriptorPool                  : extern "C" fn(VkDevice, *const VkDescriptorPoolCreateInfo, *const VkAllocationCallbacks, *mut VkDescriptorPool) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyDescriptorPool                 : extern "C" fn(VkDevice, VkDescriptorPool, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkResetDescriptorPool                   : extern "C" fn(VkDevice, VkDescriptorPool, VkDescriptorPoolResetFlags) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkAllocateDescriptorSets                : extern "C" fn(VkDevice, *const VkDescriptorSetAllocateInfo, *mut VkDescriptorSet) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkFreeDescriptorSets                    : extern "C" fn(VkDevice, VkDescriptorPool, u32, *const VkDescriptorSet) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkUpdateDescriptorSets                  : extern "C" fn(VkDevice, u32, *const VkWriteDescriptorSet, u32, *const VkCopyDescriptorSet) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateFramebuffer                     : extern "C" fn(VkDevice, *const VkFramebufferCreateInfo, *const VkAllocationCallbacks, *mut VkFramebuffer) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyFramebuffer                    : extern "C" fn(VkDevice, VkFramebuffer, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateRenderPass                      : extern "C" fn(VkDevice, *const VkRenderPassCreateInfo, *const VkAllocationCallbacks, *mut VkRenderPass) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyRenderPass                     : extern "C" fn(VkDevice, VkRenderPass, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkGetRenderAreaGranularity              : extern "C" fn(VkDevice, VkRenderPass, *mut VkExtent2D) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCreateCommandPool                     : extern "C" fn(VkDevice, *const VkCommandPoolCreateInfo, *const VkAllocationCallbacks, *mut VkCommandPool) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkDestroyCommandPool                    : extern "C" fn(VkDevice, VkCommandPool, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkResetCommandPool                      : extern "C" fn(VkDevice, VkCommandPool, VkCommandPoolResetFlags) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkAllocateCommandBuffers                : extern "C" fn(VkDevice, *const VkCommandBufferAllocateInfo, *mut VkCommandBuffer) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkFreeCommandBuffers                    : extern "C" fn(VkDevice, VkCommandPool, u32, *const VkCommandBuffer) -> (),
	#[cfg(feature = "VK_KHR_display_swapchain")]
	pfn_vkCreateSharedSwapchainsKHR             : extern "C" fn(VkDevice, u32, *const VkSwapchainCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSwapchainKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_swapchain")]
	pfn_vkCreateSwapchainKHR                    : extern "C" fn(VkDevice, *const VkSwapchainCreateInfoKHR, *const VkAllocationCallbacks, *mut VkSwapchainKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_swapchain")]
	pfn_vkDestroySwapchainKHR                   : extern "C" fn(VkDevice, VkSwapchainKHR, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_KHR_swapchain")]
	pfn_vkGetSwapchainImagesKHR                 : extern "C" fn(VkDevice, VkSwapchainKHR, *mut u32, *mut VkImage) -> VkResult,
	#[cfg(feature = "VK_KHR_swapchain")]
	pfn_vkAcquireNextImageKHR                   : extern "C" fn(VkDevice, VkSwapchainKHR, u64, VkSemaphore, VkFence, *mut u32) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_marker")]
	pfn_vkDebugMarkerSetObjectNameEXT           : extern "C" fn(VkDevice, *const VkDebugMarkerObjectNameInfoEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_marker")]
	pfn_vkDebugMarkerSetObjectTagEXT            : extern "C" fn(VkDevice, *const VkDebugMarkerObjectTagInfoEXT) -> VkResult,
	#[cfg(feature = "VK_NV_external_memory_win32")]
	pfn_vkGetMemoryWin32HandleNV                : extern "C" fn(VkDevice, VkDeviceMemory, VkExternalMemoryHandleTypeFlagsNV, *mut HANDLE) -> VkResult,
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pfn_vkGetGeneratedCommandsMemoryRequirementsNV: extern "C" fn(VkDevice, *const VkGeneratedCommandsMemoryRequirementsInfoNV, *mut VkMemoryRequirements2) -> (),
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pfn_vkCreateIndirectCommandsLayoutNV        : extern "C" fn(VkDevice, *const VkIndirectCommandsLayoutCreateInfoNV, *const VkAllocationCallbacks, *mut VkIndirectCommandsLayoutNV) -> VkResult,
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pfn_vkDestroyIndirectCommandsLayoutNV       : extern "C" fn(VkDevice, VkIndirectCommandsLayoutNV, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkTrimCommandPool                       : extern "C" fn(VkDevice, VkCommandPool, VkCommandPoolTrimFlags) -> (),
	#[cfg(feature = "VK_KHR_maintenance1")]
	pfn_vkTrimCommandPoolKHR                    : extern "C" fn(VkDevice, VkCommandPool, VkCommandPoolTrimFlags) -> (),
	#[cfg(feature = "VK_KHR_external_memory_win32")]
	pfn_vkGetMemoryWin32HandleKHR               : extern "C" fn(VkDevice, *const VkMemoryGetWin32HandleInfoKHR, *mut HANDLE) -> VkResult,
	#[cfg(feature = "VK_KHR_external_memory_win32")]
	pfn_vkGetMemoryWin32HandlePropertiesKHR     : extern "C" fn(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, *mut VkMemoryWin32HandlePropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_external_memory_fd")]
	pfn_vkGetMemoryFdKHR                        : extern "C" fn(VkDevice, *const VkMemoryGetFdInfoKHR, *mut i32) -> VkResult,
	#[cfg(feature = "VK_KHR_external_memory_fd")]
	pfn_vkGetMemoryFdPropertiesKHR              : extern "C" fn(VkDevice, VkExternalMemoryHandleTypeFlagBits, i32, *mut VkMemoryFdPropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_FUCHSIA_external_memory")]
	pfn_vkGetMemoryZirconHandleFUCHSIA          : extern "C" fn(VkDevice, *const VkMemoryGetZirconHandleInfoFUCHSIA, *mut zx_handle_t) -> VkResult,
	#[cfg(feature = "VK_FUCHSIA_external_memory")]
	pfn_vkGetMemoryZirconHandlePropertiesFUCHSIA: extern "C" fn(VkDevice, VkExternalMemoryHandleTypeFlagBits, zx_handle_t, *mut VkMemoryZirconHandlePropertiesFUCHSIA) -> VkResult,
	#[cfg(feature = "VK_NV_external_memory_rdma")]
	pfn_vkGetMemoryRemoteAddressNV              : extern "C" fn(VkDevice, *const VkMemoryGetRemoteAddressInfoNV, *mut VkRemoteAddressNV) -> VkResult,
	#[cfg(feature = "VK_KHR_external_semaphore_win32")]
	pfn_vkGetSemaphoreWin32HandleKHR            : extern "C" fn(VkDevice, *const VkSemaphoreGetWin32HandleInfoKHR, *mut HANDLE) -> VkResult,
	#[cfg(feature = "VK_KHR_external_semaphore_win32")]
	pfn_vkImportSemaphoreWin32HandleKHR         : extern "C" fn(VkDevice, *const VkImportSemaphoreWin32HandleInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_external_semaphore_fd")]
	pfn_vkGetSemaphoreFdKHR                     : extern "C" fn(VkDevice, *const VkSemaphoreGetFdInfoKHR, *mut i32) -> VkResult,
	#[cfg(feature = "VK_KHR_external_semaphore_fd")]
	pfn_vkImportSemaphoreFdKHR                  : extern "C" fn(VkDevice, *const VkImportSemaphoreFdInfoKHR) -> VkResult,
	#[cfg(feature = "VK_FUCHSIA_external_semaphore")]
	pfn_vkGetSemaphoreZirconHandleFUCHSIA       : extern "C" fn(VkDevice, *const VkSemaphoreGetZirconHandleInfoFUCHSIA, *mut zx_handle_t) -> VkResult,
	#[cfg(feature = "VK_FUCHSIA_external_semaphore")]
	pfn_vkImportSemaphoreZirconHandleFUCHSIA    : extern "C" fn(VkDevice, *const VkImportSemaphoreZirconHandleInfoFUCHSIA) -> VkResult,
	#[cfg(feature = "VK_KHR_external_fence_win32")]
	pfn_vkGetFenceWin32HandleKHR                : extern "C" fn(VkDevice, *const VkFenceGetWin32HandleInfoKHR, *mut HANDLE) -> VkResult,
	#[cfg(feature = "VK_KHR_external_fence_win32")]
	pfn_vkImportFenceWin32HandleKHR             : extern "C" fn(VkDevice, *const VkImportFenceWin32HandleInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_external_fence_fd")]
	pfn_vkGetFenceFdKHR                         : extern "C" fn(VkDevice, *const VkFenceGetFdInfoKHR, *mut i32) -> VkResult,
	#[cfg(feature = "VK_KHR_external_fence_fd")]
	pfn_vkImportFenceFdKHR                      : extern "C" fn(VkDevice, *const VkImportFenceFdInfoKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_display_control")]
	pfn_vkDisplayPowerControlEXT                : extern "C" fn(VkDevice, VkDisplayKHR, *const VkDisplayPowerInfoEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_display_control")]
	pfn_vkRegisterDeviceEventEXT                : extern "C" fn(VkDevice, *const VkDeviceEventInfoEXT, *const VkAllocationCallbacks, *mut VkFence) -> VkResult,
	#[cfg(feature = "VK_EXT_display_control")]
	pfn_vkRegisterDisplayEventEXT               : extern "C" fn(VkDevice, VkDisplayKHR, *const VkDisplayEventInfoEXT, *const VkAllocationCallbacks, *mut VkFence) -> VkResult,
	#[cfg(feature = "VK_EXT_display_control")]
	pfn_vkGetSwapchainCounterEXT                : extern "C" fn(VkDevice, VkSwapchainKHR, VkSurfaceCounterFlagBitsEXT, *mut u64) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetDeviceGroupPeerMemoryFeatures      : extern "C" fn(VkDevice, u32, u32, u32, *mut VkPeerMemoryFeatureFlags) -> (),
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkGetDeviceGroupPeerMemoryFeaturesKHR   : extern "C" fn(VkDevice, u32, u32, u32, *mut VkPeerMemoryFeatureFlags) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkBindBufferMemory2                     : extern "C" fn(VkDevice, u32, *const VkBindBufferMemoryInfo) -> VkResult,
	#[cfg(feature = "VK_KHR_bind_memory2")]
	pfn_vkBindBufferMemory2KHR                  : extern "C" fn(VkDevice, u32, *const VkBindBufferMemoryInfo) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkBindImageMemory2                      : extern "C" fn(VkDevice, u32, *const VkBindImageMemoryInfo) -> VkResult,
	#[cfg(feature = "VK_KHR_bind_memory2")]
	pfn_vkBindImageMemory2KHR                   : extern "C" fn(VkDevice, u32, *const VkBindImageMemoryInfo) -> VkResult,
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkGetDeviceGroupPresentCapabilitiesKHR  : extern "C" fn(VkDevice, *mut VkDeviceGroupPresentCapabilitiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkGetDeviceGroupSurfacePresentModesKHR  : extern "C" fn(VkDevice, VkSurfaceKHR, *mut VkDeviceGroupPresentModeFlagsKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkAcquireNextImage2KHR                  : extern "C" fn(VkDevice, *const VkAcquireNextImageInfoKHR, *mut u32) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkCreateDescriptorUpdateTemplate        : extern "C" fn(VkDevice, *const VkDescriptorUpdateTemplateCreateInfo, *const VkAllocationCallbacks, *mut VkDescriptorUpdateTemplate) -> VkResult,
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pfn_vkCreateDescriptorUpdateTemplateKHR     : extern "C" fn(VkDevice, *const VkDescriptorUpdateTemplateCreateInfo, *const VkAllocationCallbacks, *mut VkDescriptorUpdateTemplate) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkDestroyDescriptorUpdateTemplate       : extern "C" fn(VkDevice, VkDescriptorUpdateTemplate, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pfn_vkDestroyDescriptorUpdateTemplateKHR    : extern "C" fn(VkDevice, VkDescriptorUpdateTemplate, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkUpdateDescriptorSetWithTemplate       : extern "C" fn(VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, *const ()) -> (),
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pfn_vkUpdateDescriptorSetWithTemplateKHR    : extern "C" fn(VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, *const ()) -> (),
	#[cfg(feature = "VK_EXT_hdr_metadata")]
	pfn_vkSetHdrMetadataEXT                     : extern "C" fn(VkDevice, u32, *const VkSwapchainKHR, *const VkHdrMetadataEXT) -> (),
	#[cfg(feature = "VK_KHR_shared_presentable_image")]
	pfn_vkGetSwapchainStatusKHR                 : extern "C" fn(VkDevice, VkSwapchainKHR) -> VkResult,
	#[cfg(feature = "VK_GOOGLE_display_timing")]
	pfn_vkGetRefreshCycleDurationGOOGLE         : extern "C" fn(VkDevice, VkSwapchainKHR, *mut VkRefreshCycleDurationGOOGLE) -> VkResult,
	#[cfg(feature = "VK_GOOGLE_display_timing")]
	pfn_vkGetPastPresentationTimingGOOGLE       : extern "C" fn(VkDevice, VkSwapchainKHR, *mut u32, *mut VkPastPresentationTimingGOOGLE) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetBufferMemoryRequirements2          : extern "C" fn(VkDevice, *const VkBufferMemoryRequirementsInfo2, *mut VkMemoryRequirements2) -> (),
	#[cfg(feature = "VK_KHR_get_memory_requirements2")]
	pfn_vkGetBufferMemoryRequirements2KHR       : extern "C" fn(VkDevice, *const VkBufferMemoryRequirementsInfo2, *mut VkMemoryRequirements2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetImageMemoryRequirements2           : extern "C" fn(VkDevice, *const VkImageMemoryRequirementsInfo2, *mut VkMemoryRequirements2) -> (),
	#[cfg(feature = "VK_KHR_get_memory_requirements2")]
	pfn_vkGetImageMemoryRequirements2KHR        : extern "C" fn(VkDevice, *const VkImageMemoryRequirementsInfo2, *mut VkMemoryRequirements2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetImageSparseMemoryRequirements2     : extern "C" fn(VkDevice, *const VkImageSparseMemoryRequirementsInfo2, *mut u32, *mut VkSparseImageMemoryRequirements2) -> (),
	#[cfg(feature = "VK_KHR_get_memory_requirements2")]
	pfn_vkGetImageSparseMemoryRequirements2KHR  : extern "C" fn(VkDevice, *const VkImageSparseMemoryRequirementsInfo2, *mut u32, *mut VkSparseImageMemoryRequirements2) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkCreateSamplerYcbcrConversion          : extern "C" fn(VkDevice, *const VkSamplerYcbcrConversionCreateInfo, *const VkAllocationCallbacks, *mut VkSamplerYcbcrConversion) -> VkResult,
	#[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
	pfn_vkCreateSamplerYcbcrConversionKHR       : extern "C" fn(VkDevice, *const VkSamplerYcbcrConversionCreateInfo, *const VkAllocationCallbacks, *mut VkSamplerYcbcrConversion) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkDestroySamplerYcbcrConversion         : extern "C" fn(VkDevice, VkSamplerYcbcrConversion, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
	pfn_vkDestroySamplerYcbcrConversionKHR      : extern "C" fn(VkDevice, VkSamplerYcbcrConversion, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetDeviceQueue2                       : extern "C" fn(VkDevice, *const VkDeviceQueueInfo2, *mut VkQueue) -> (),
	#[cfg(feature = "VK_EXT_validation_cache")]
	pfn_vkCreateValidationCacheEXT              : extern "C" fn(VkDevice, *const VkValidationCacheCreateInfoEXT, *const VkAllocationCallbacks, *mut VkValidationCacheEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_validation_cache")]
	pfn_vkDestroyValidationCacheEXT             : extern "C" fn(VkDevice, VkValidationCacheEXT, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_EXT_validation_cache")]
	pfn_vkGetValidationCacheDataEXT             : extern "C" fn(VkDevice, VkValidationCacheEXT, *mut usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_EXT_validation_cache")]
	pfn_vkMergeValidationCachesEXT              : extern "C" fn(VkDevice, VkValidationCacheEXT, u32, *const VkValidationCacheEXT) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkGetDescriptorSetLayoutSupport         : extern "C" fn(VkDevice, *const VkDescriptorSetLayoutCreateInfo, *mut VkDescriptorSetLayoutSupport) -> (),
	#[cfg(feature = "VK_KHR_maintenance3")]
	pfn_vkGetDescriptorSetLayoutSupportKHR      : extern "C" fn(VkDevice, *const VkDescriptorSetLayoutCreateInfo, *mut VkDescriptorSetLayoutSupport) -> (),
	pfn_vkGetSwapchainGrallocUsageANDROID       : extern "C" fn(VkDevice, VkFormat, VkImageUsageFlags, *mut i32) -> VkResult,
	pfn_vkGetSwapchainGrallocUsage2ANDROID      : extern "C" fn(VkDevice, VkFormat, VkImageUsageFlags, VkSwapchainImageUsageFlagsANDROID, *mut u64, *mut u64) -> VkResult,
	pfn_vkAcquireImageANDROID                   : extern "C" fn(VkDevice, VkImage, i32, VkSemaphore, VkFence) -> VkResult,
	#[cfg(feature = "VK_AMD_shader_info")]
	pfn_vkGetShaderInfoAMD                      : extern "C" fn(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, *mut usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_AMD_display_native_hdr")]
	pfn_vkSetLocalDimmingAMD                    : extern "C" fn(VkDevice, VkSwapchainKHR, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_calibrated_timestamps")]
	pfn_vkGetCalibratedTimestampsEXT            : extern "C" fn(VkDevice, u32, *const VkCalibratedTimestampInfoEXT, *mut u64, *mut u64) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkSetDebugUtilsObjectNameEXT            : extern "C" fn(VkDevice, *const VkDebugUtilsObjectNameInfoEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkSetDebugUtilsObjectTagEXT             : extern "C" fn(VkDevice, *const VkDebugUtilsObjectTagInfoEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_external_memory_host")]
	pfn_vkGetMemoryHostPointerPropertiesEXT     : extern "C" fn(VkDevice, VkExternalMemoryHandleTypeFlagBits, *const (), *mut VkMemoryHostPointerPropertiesEXT) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkCreateRenderPass2                     : extern "C" fn(VkDevice, *const VkRenderPassCreateInfo2, *const VkAllocationCallbacks, *mut VkRenderPass) -> VkResult,
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pfn_vkCreateRenderPass2KHR                  : extern "C" fn(VkDevice, *const VkRenderPassCreateInfo2, *const VkAllocationCallbacks, *mut VkRenderPass) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkGetSemaphoreCounterValue              : extern "C" fn(VkDevice, VkSemaphore, *mut u64) -> VkResult,
	#[cfg(feature = "VK_KHR_timeline_semaphore")]
	pfn_vkGetSemaphoreCounterValueKHR           : extern "C" fn(VkDevice, VkSemaphore, *mut u64) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkWaitSemaphores                        : extern "C" fn(VkDevice, *const VkSemaphoreWaitInfo, u64) -> VkResult,
	#[cfg(feature = "VK_KHR_timeline_semaphore")]
	pfn_vkWaitSemaphoresKHR                     : extern "C" fn(VkDevice, *const VkSemaphoreWaitInfo, u64) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkSignalSemaphore                       : extern "C" fn(VkDevice, *const VkSemaphoreSignalInfo) -> VkResult,
	#[cfg(feature = "VK_KHR_timeline_semaphore")]
	pfn_vkSignalSemaphoreKHR                    : extern "C" fn(VkDevice, *const VkSemaphoreSignalInfo) -> VkResult,
	#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
	pfn_vkGetAndroidHardwareBufferPropertiesANDROID: extern "C" fn(VkDevice, *const AHardwareBuffer, *mut VkAndroidHardwareBufferPropertiesANDROID) -> VkResult,
	#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
	pfn_vkGetMemoryAndroidHardwareBufferANDROID : extern "C" fn(VkDevice, *const VkMemoryGetAndroidHardwareBufferInfoANDROID, *mut *mut AHardwareBuffer) -> VkResult,
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCompileDeferredNV                     : extern "C" fn(VkDevice, VkPipeline, u32) -> VkResult,
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCreateAccelerationStructureNV         : extern "C" fn(VkDevice, *const VkAccelerationStructureCreateInfoNV, *const VkAllocationCallbacks, *mut VkAccelerationStructureNV) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkDestroyAccelerationStructureKHR       : extern "C" fn(VkDevice, VkAccelerationStructureKHR, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkDestroyAccelerationStructureNV        : extern "C" fn(VkDevice, VkAccelerationStructureNV, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkGetAccelerationStructureMemoryRequirementsNV: extern "C" fn(VkDevice, *const VkAccelerationStructureMemoryRequirementsInfoNV, *mut VkMemoryRequirements2KHR) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkBindAccelerationStructureMemoryNV     : extern "C" fn(VkDevice, u32, *const VkBindAccelerationStructureMemoryInfoNV) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCopyAccelerationStructureKHR          : extern "C" fn(VkDevice, VkDeferredOperationKHR, *const VkCopyAccelerationStructureInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCopyAccelerationStructureToMemoryKHR  : extern "C" fn(VkDevice, VkDeferredOperationKHR, *const VkCopyAccelerationStructureToMemoryInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCopyMemoryToAccelerationStructureKHR  : extern "C" fn(VkDevice, VkDeferredOperationKHR, *const VkCopyMemoryToAccelerationStructureInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkWriteAccelerationStructuresPropertiesKHR: extern "C" fn(VkDevice, u32, *const VkAccelerationStructureKHR, VkQueryType, usize, *mut (), usize) -> VkResult,
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkGetRayTracingShaderGroupHandlesKHR    : extern "C" fn(VkDevice, VkPipeline, u32, u32, usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkGetRayTracingShaderGroupHandlesNV     : extern "C" fn(VkDevice, VkPipeline, u32, u32, usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR: extern "C" fn(VkDevice, VkPipeline, u32, u32, usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkGetAccelerationStructureHandleNV      : extern "C" fn(VkDevice, VkAccelerationStructureNV, usize, *mut ()) -> VkResult,
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCreateRayTracingPipelinesNV           : extern "C" fn(VkDevice, VkPipelineCache, u32, *const VkRayTracingPipelineCreateInfoNV, *const VkAllocationCallbacks, *mut VkPipeline) -> VkResult,
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkCreateRayTracingPipelinesKHR          : extern "C" fn(VkDevice, VkDeferredOperationKHR, VkPipelineCache, u32, *const VkRayTracingPipelineCreateInfoKHR, *const VkAllocationCallbacks, *mut VkPipeline) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkGetDeviceAccelerationStructureCompatibilityKHR: extern "C" fn(VkDevice, *const VkAccelerationStructureVersionInfoKHR, *mut VkAccelerationStructureCompatibilityKHR) -> (),
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkGetRayTracingShaderGroupStackSizeKHR  : extern "C" fn(VkDevice, VkPipeline, u32, VkShaderGroupShaderKHR) -> VkDeviceSize,
	#[cfg(feature = "VK_NVX_image_view_handle")]
	pfn_vkGetImageViewHandleNVX                 : extern "C" fn(VkDevice, *const VkImageViewHandleInfoNVX) -> u32,
	#[cfg(feature = "VK_NVX_image_view_handle")]
	pfn_vkGetImageViewAddressNVX                : extern "C" fn(VkDevice, VkImageView, *mut VkImageViewAddressPropertiesNVX) -> VkResult,
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pfn_vkGetDeviceGroupSurfacePresentModes2EXT : extern "C" fn(VkDevice, *const VkPhysicalDeviceSurfaceInfo2KHR, *mut VkDeviceGroupPresentModeFlagsKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pfn_vkAcquireFullScreenExclusiveModeEXT     : extern "C" fn(VkDevice, VkSwapchainKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_full_screen_exclusive")]
	pfn_vkReleaseFullScreenExclusiveModeEXT     : extern "C" fn(VkDevice, VkSwapchainKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_performance_query")]
	pfn_vkAcquireProfilingLockKHR               : extern "C" fn(VkDevice, *const VkAcquireProfilingLockInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_performance_query")]
	pfn_vkReleaseProfilingLockKHR               : extern "C" fn(VkDevice) -> (),
	#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
	pfn_vkGetImageDrmFormatModifierPropertiesEXT: extern "C" fn(VkDevice, VkImage, *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkGetBufferOpaqueCaptureAddress         : extern "C" fn(VkDevice, *const VkBufferDeviceAddressInfo) -> u64,
	#[cfg(feature = "VK_KHR_buffer_device_address")]
	pfn_vkGetBufferOpaqueCaptureAddressKHR      : extern "C" fn(VkDevice, *const VkBufferDeviceAddressInfo) -> u64,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkGetBufferDeviceAddress                : extern "C" fn(VkDevice, *const VkBufferDeviceAddressInfo) -> VkDeviceAddress,
	#[cfg(feature = "VK_KHR_buffer_device_address")]
	pfn_vkGetBufferDeviceAddressKHR             : extern "C" fn(VkDevice, *const VkBufferDeviceAddressInfo) -> VkDeviceAddress,
	#[cfg(feature = "VK_EXT_buffer_device_address")]
	pfn_vkGetBufferDeviceAddressEXT             : extern "C" fn(VkDevice, *const VkBufferDeviceAddressInfo) -> VkDeviceAddress,
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkInitializePerformanceApiINTEL         : extern "C" fn(VkDevice, *const VkInitializePerformanceApiInfoINTEL) -> VkResult,
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkUninitializePerformanceApiINTEL       : extern "C" fn(VkDevice) -> (),
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkAcquirePerformanceConfigurationINTEL  : extern "C" fn(VkDevice, *const VkPerformanceConfigurationAcquireInfoINTEL, *mut VkPerformanceConfigurationINTEL) -> VkResult,
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkReleasePerformanceConfigurationINTEL  : extern "C" fn(VkDevice, VkPerformanceConfigurationINTEL) -> VkResult,
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkGetPerformanceParameterINTEL          : extern "C" fn(VkDevice, VkPerformanceParameterTypeINTEL, *mut VkPerformanceValueINTEL) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkGetDeviceMemoryOpaqueCaptureAddress   : extern "C" fn(VkDevice, *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64,
	#[cfg(feature = "VK_KHR_buffer_device_address")]
	pfn_vkGetDeviceMemoryOpaqueCaptureAddressKHR: extern "C" fn(VkDevice, *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64,
	#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
	pfn_vkGetPipelineExecutablePropertiesKHR    : extern "C" fn(VkDevice, *const VkPipelineInfoKHR, *mut u32, *mut VkPipelineExecutablePropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
	pfn_vkGetPipelineExecutableStatisticsKHR    : extern "C" fn(VkDevice, *const VkPipelineExecutableInfoKHR, *mut u32, *mut VkPipelineExecutableStatisticKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
	pfn_vkGetPipelineExecutableInternalRepresentationsKHR: extern "C" fn(VkDevice, *const VkPipelineExecutableInfoKHR, *mut u32, *mut VkPipelineExecutableInternalRepresentationKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCreateAccelerationStructureKHR        : extern "C" fn(VkDevice, *const VkAccelerationStructureCreateInfoKHR, *const VkAllocationCallbacks, *mut VkAccelerationStructureKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkBuildAccelerationStructuresKHR        : extern "C" fn(VkDevice, VkDeferredOperationKHR, u32, *const VkAccelerationStructureBuildGeometryInfoKHR, *const *const VkAccelerationStructureBuildRangeInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkGetAccelerationStructureDeviceAddressKHR: extern "C" fn(VkDevice, *const VkAccelerationStructureDeviceAddressInfoKHR) -> VkDeviceAddress,
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pfn_vkCreateDeferredOperationKHR            : extern "C" fn(VkDevice, *const VkAllocationCallbacks, *mut VkDeferredOperationKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pfn_vkDestroyDeferredOperationKHR           : extern "C" fn(VkDevice, VkDeferredOperationKHR, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pfn_vkGetDeferredOperationMaxConcurrencyKHR : extern "C" fn(VkDevice, VkDeferredOperationKHR) -> u32,
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pfn_vkGetDeferredOperationResultKHR         : extern "C" fn(VkDevice, VkDeferredOperationKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_deferred_host_operations")]
	pfn_vkDeferredOperationJoinKHR              : extern "C" fn(VkDevice, VkDeferredOperationKHR) -> VkResult,
	#[cfg(feature = "VK_EXT_private_data")]
	pfn_vkCreatePrivateDataSlotEXT              : extern "C" fn(VkDevice, *const VkPrivateDataSlotCreateInfoEXT, *const VkAllocationCallbacks, *mut VkPrivateDataSlotEXT) -> VkResult,
	#[cfg(feature = "VK_EXT_private_data")]
	pfn_vkDestroyPrivateDataSlotEXT             : extern "C" fn(VkDevice, VkPrivateDataSlotEXT, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_EXT_private_data")]
	pfn_vkSetPrivateDataEXT                     : extern "C" fn(VkDevice, VkObjectType, u64, VkPrivateDataSlotEXT, u64) -> VkResult,
	#[cfg(feature = "VK_EXT_private_data")]
	pfn_vkGetPrivateDataEXT                     : extern "C" fn(VkDevice, VkObjectType, u64, VkPrivateDataSlotEXT, *mut u64) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkGetAccelerationStructureBuildSizesKHR : extern "C" fn(VkDevice, VkAccelerationStructureBuildTypeKHR, *const VkAccelerationStructureBuildGeometryInfoKHR, *const u32, *mut VkAccelerationStructureBuildSizesInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkCreateVideoSessionKHR                 : extern "C" fn(VkDevice, *const VkVideoSessionCreateInfoKHR, *const VkAllocationCallbacks, *mut VkVideoSessionKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkDestroyVideoSessionKHR                : extern "C" fn(VkDevice, VkVideoSessionKHR, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkCreateVideoSessionParametersKHR       : extern "C" fn(VkDevice, *const VkVideoSessionParametersCreateInfoKHR, *const VkAllocationCallbacks, *mut VkVideoSessionParametersKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkUpdateVideoSessionParametersKHR       : extern "C" fn(VkDevice, VkVideoSessionParametersKHR, *const VkVideoSessionParametersUpdateInfoKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkDestroyVideoSessionParametersKHR      : extern "C" fn(VkDevice, VkVideoSessionParametersKHR, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkGetVideoSessionMemoryRequirementsKHR  : extern "C" fn(VkDevice, VkVideoSessionKHR, *mut u32, *mut VkVideoGetMemoryPropertiesKHR) -> VkResult,
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkBindVideoSessionMemoryKHR             : extern "C" fn(VkDevice, VkVideoSessionKHR, u32, *const VkVideoBindMemoryKHR) -> VkResult,
	#[cfg(feature = "VK_NVX_binary_import")]
	pfn_vkCreateCuModuleNVX                     : extern "C" fn(VkDevice, *const VkCuModuleCreateInfoNVX, *const VkAllocationCallbacks, *mut VkCuModuleNVX) -> VkResult,
	#[cfg(feature = "VK_NVX_binary_import")]
	pfn_vkCreateCuFunctionNVX                   : extern "C" fn(VkDevice, *const VkCuFunctionCreateInfoNVX, *const VkAllocationCallbacks, *mut VkCuFunctionNVX) -> VkResult,
	#[cfg(feature = "VK_NVX_binary_import")]
	pfn_vkDestroyCuModuleNVX                    : extern "C" fn(VkDevice, VkCuModuleNVX, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_NVX_binary_import")]
	pfn_vkDestroyCuFunctionNVX                  : extern "C" fn(VkDevice, VkCuFunctionNVX, *const VkAllocationCallbacks) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkQueueSubmit                           : extern "C" fn(VkQueue, u32, *const VkSubmitInfo, VkFence) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkQueueWaitIdle                         : extern "C" fn(VkQueue) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkQueueBindSparse                       : extern "C" fn(VkQueue, u32, *const VkBindSparseInfo, VkFence) -> VkResult,
	#[cfg(feature = "VK_KHR_swapchain")]
	pfn_vkQueuePresentKHR                       : extern "C" fn(VkQueue, *const VkPresentInfoKHR) -> VkResult,
	pfn_vkQueueSignalReleaseImageANDROID        : extern "C" fn(VkQueue, u32, *const VkSemaphore, VkImage, *mut i32) -> VkResult,
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkQueueBeginDebugUtilsLabelEXT          : extern "C" fn(VkQueue, *const VkDebugUtilsLabelEXT) -> (),
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkQueueEndDebugUtilsLabelEXT            : extern "C" fn(VkQueue) -> (),
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkQueueInsertDebugUtilsLabelEXT         : extern "C" fn(VkQueue, *const VkDebugUtilsLabelEXT) -> (),
	#[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
	pfn_vkGetQueueCheckpointDataNV              : extern "C" fn(VkQueue, *mut u32, *mut VkCheckpointDataNV) -> (),
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkQueueSetPerformanceConfigurationINTEL : extern "C" fn(VkQueue, VkPerformanceConfigurationINTEL) -> VkResult,
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkQueueSubmit2KHR                       : extern "C" fn(VkQueue, u32, *const VkSubmitInfo2KHR, VkFence) -> VkResult,
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkGetQueueCheckpointData2NV             : extern "C" fn(VkQueue, *mut u32, *mut VkCheckpointData2NV) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkBeginCommandBuffer                    : extern "C" fn(VkCommandBuffer, *const VkCommandBufferBeginInfo) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkEndCommandBuffer                      : extern "C" fn(VkCommandBuffer) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkResetCommandBuffer                    : extern "C" fn(VkCommandBuffer, VkCommandBufferResetFlags) -> VkResult,
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBindPipeline                       : extern "C" fn(VkCommandBuffer, VkPipelineBindPoint, VkPipeline) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetViewport                        : extern "C" fn(VkCommandBuffer, u32, u32, *const VkViewport) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetScissor                         : extern "C" fn(VkCommandBuffer, u32, u32, *const VkRect2D) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetLineWidth                       : extern "C" fn(VkCommandBuffer, f32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetDepthBias                       : extern "C" fn(VkCommandBuffer, f32, f32, f32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetBlendConstants                  : extern "C" fn(VkCommandBuffer, [f32;  4 as usize]) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetDepthBounds                     : extern "C" fn(VkCommandBuffer, f32, f32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetStencilCompareMask              : extern "C" fn(VkCommandBuffer, VkStencilFaceFlags, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetStencilWriteMask                : extern "C" fn(VkCommandBuffer, VkStencilFaceFlags, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetStencilReference                : extern "C" fn(VkCommandBuffer, VkStencilFaceFlags, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBindDescriptorSets                 : extern "C" fn(VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, u32, u32, *const VkDescriptorSet, u32, *const u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBindIndexBuffer                    : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkIndexType) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBindVertexBuffers                  : extern "C" fn(VkCommandBuffer, u32, u32, *const VkBuffer, *const VkDeviceSize) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdDraw                               : extern "C" fn(VkCommandBuffer, u32, u32, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdDrawIndexed                        : extern "C" fn(VkCommandBuffer, u32, u32, u32, i32, u32) -> (),
	#[cfg(feature = "VK_EXT_multi_draw")]
	pfn_vkCmdDrawMultiEXT                       : extern "C" fn(VkCommandBuffer, u32, *const VkMultiDrawInfoEXT, u32, u32, u32) -> (),
	#[cfg(feature = "VK_EXT_multi_draw")]
	pfn_vkCmdDrawMultiIndexedEXT                : extern "C" fn(VkCommandBuffer, u32, *const VkMultiDrawIndexedInfoEXT, u32, u32, u32, *const i32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdDrawIndirect                       : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdDrawIndexedIndirect                : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdDispatch                           : extern "C" fn(VkCommandBuffer, u32, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdDispatchIndirect                   : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize) -> (),
	#[cfg(feature = "VK_HUAWEI_subpass_shading")]
	pfn_vkCmdSubpassShadingHUAWEI               : extern "C" fn(VkCommandBuffer) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdCopyBuffer                         : extern "C" fn(VkCommandBuffer, VkBuffer, VkBuffer, u32, *const VkBufferCopy) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdCopyImage                          : extern "C" fn(VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, u32, *const VkImageCopy) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBlitImage                          : extern "C" fn(VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, u32, *const VkImageBlit, VkFilter) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdCopyBufferToImage                  : extern "C" fn(VkCommandBuffer, VkBuffer, VkImage, VkImageLayout, u32, *const VkBufferImageCopy) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdCopyImageToBuffer                  : extern "C" fn(VkCommandBuffer, VkImage, VkImageLayout, VkBuffer, u32, *const VkBufferImageCopy) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdUpdateBuffer                       : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkDeviceSize, *const ()) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdFillBuffer                         : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkDeviceSize, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdClearColorImage                    : extern "C" fn(VkCommandBuffer, VkImage, VkImageLayout, *const VkClearColorValue, u32, *const VkImageSubresourceRange) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdClearDepthStencilImage             : extern "C" fn(VkCommandBuffer, VkImage, VkImageLayout, *const VkClearDepthStencilValue, u32, *const VkImageSubresourceRange) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdClearAttachments                   : extern "C" fn(VkCommandBuffer, u32, *const VkClearAttachment, u32, *const VkClearRect) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdResolveImage                       : extern "C" fn(VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, u32, *const VkImageResolve) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdSetEvent                           : extern "C" fn(VkCommandBuffer, VkEvent, VkPipelineStageFlags) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdResetEvent                         : extern "C" fn(VkCommandBuffer, VkEvent, VkPipelineStageFlags) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdWaitEvents                         : extern "C" fn(VkCommandBuffer, u32, *const VkEvent, VkPipelineStageFlags, VkPipelineStageFlags, u32, *const VkMemoryBarrier, u32, *const VkBufferMemoryBarrier, u32, *const VkImageMemoryBarrier) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdPipelineBarrier                    : extern "C" fn(VkCommandBuffer, VkPipelineStageFlags, VkPipelineStageFlags, VkDependencyFlags, u32, *const VkMemoryBarrier, u32, *const VkBufferMemoryBarrier, u32, *const VkImageMemoryBarrier) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBeginQuery                         : extern "C" fn(VkCommandBuffer, VkQueryPool, u32, VkQueryControlFlags) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdEndQuery                           : extern "C" fn(VkCommandBuffer, VkQueryPool, u32) -> (),
	#[cfg(feature = "VK_EXT_conditional_rendering")]
	pfn_vkCmdBeginConditionalRenderingEXT       : extern "C" fn(VkCommandBuffer, *const VkConditionalRenderingBeginInfoEXT) -> (),
	#[cfg(feature = "VK_EXT_conditional_rendering")]
	pfn_vkCmdEndConditionalRenderingEXT         : extern "C" fn(VkCommandBuffer) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdResetQueryPool                     : extern "C" fn(VkCommandBuffer, VkQueryPool, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdWriteTimestamp                     : extern "C" fn(VkCommandBuffer, VkPipelineStageFlagBits, VkQueryPool, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdCopyQueryPoolResults               : extern "C" fn(VkCommandBuffer, VkQueryPool, u32, u32, VkBuffer, VkDeviceSize, VkDeviceSize, VkQueryResultFlags) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdPushConstants                      : extern "C" fn(VkCommandBuffer, VkPipelineLayout, VkShaderStageFlags, u32, u32, *const ()) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdBeginRenderPass                    : extern "C" fn(VkCommandBuffer, *const VkRenderPassBeginInfo, VkSubpassContents) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdNextSubpass                        : extern "C" fn(VkCommandBuffer, VkSubpassContents) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdEndRenderPass                      : extern "C" fn(VkCommandBuffer) -> (),
	#[cfg(feature = "VK_VERSION_1_0")]
	pfn_vkCmdExecuteCommands                    : extern "C" fn(VkCommandBuffer, u32, *const VkCommandBuffer) -> (),
	#[cfg(feature = "VK_EXT_debug_marker")]
	pfn_vkCmdDebugMarkerBeginEXT                : extern "C" fn(VkCommandBuffer, *const VkDebugMarkerMarkerInfoEXT) -> (),
	#[cfg(feature = "VK_EXT_debug_marker")]
	pfn_vkCmdDebugMarkerEndEXT                  : extern "C" fn(VkCommandBuffer) -> (),
	#[cfg(feature = "VK_EXT_debug_marker")]
	pfn_vkCmdDebugMarkerInsertEXT               : extern "C" fn(VkCommandBuffer, *const VkDebugMarkerMarkerInfoEXT) -> (),
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pfn_vkCmdExecuteGeneratedCommandsNV         : extern "C" fn(VkCommandBuffer, VkBool32, *const VkGeneratedCommandsInfoNV) -> (),
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pfn_vkCmdPreprocessGeneratedCommandsNV      : extern "C" fn(VkCommandBuffer, *const VkGeneratedCommandsInfoNV) -> (),
	#[cfg(feature = "VK_NV_device_generated_commands")]
	pfn_vkCmdBindPipelineShaderGroupNV          : extern "C" fn(VkCommandBuffer, VkPipelineBindPoint, VkPipeline, u32) -> (),
	#[cfg(feature = "VK_KHR_push_descriptor")]
	pfn_vkCmdPushDescriptorSetKHR               : extern "C" fn(VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, u32, u32, *const VkWriteDescriptorSet) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkCmdSetDeviceMask                      : extern "C" fn(VkCommandBuffer, u32) -> (),
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkCmdSetDeviceMaskKHR                   : extern "C" fn(VkCommandBuffer, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_1")]
	pfn_vkCmdDispatchBase                       : extern "C" fn(VkCommandBuffer, u32, u32, u32, u32, u32, u32) -> (),
	#[cfg(feature = "VK_KHR_device_group")]
	pfn_vkCmdDispatchBaseKHR                    : extern "C" fn(VkCommandBuffer, u32, u32, u32, u32, u32, u32) -> (),
	#[cfg(feature = "VK_KHR_descriptor_update_template")]
	pfn_vkCmdPushDescriptorSetWithTemplateKHR   : extern "C" fn(VkCommandBuffer, VkDescriptorUpdateTemplate, VkPipelineLayout, u32, *const ()) -> (),
	#[cfg(feature = "VK_NV_clip_space_w_scaling")]
	pfn_vkCmdSetViewportWScalingNV              : extern "C" fn(VkCommandBuffer, u32, u32, *const VkViewportWScalingNV) -> (),
	#[cfg(feature = "VK_EXT_discard_rectangles")]
	pfn_vkCmdSetDiscardRectangleEXT             : extern "C" fn(VkCommandBuffer, u32, u32, *const VkRect2D) -> (),
	#[cfg(feature = "VK_EXT_sample_locations")]
	pfn_vkCmdSetSampleLocationsEXT              : extern "C" fn(VkCommandBuffer, *const VkSampleLocationsInfoEXT) -> (),
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkCmdBeginDebugUtilsLabelEXT            : extern "C" fn(VkCommandBuffer, *const VkDebugUtilsLabelEXT) -> (),
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkCmdEndDebugUtilsLabelEXT              : extern "C" fn(VkCommandBuffer) -> (),
	#[cfg(feature = "VK_EXT_debug_utils")]
	pfn_vkCmdInsertDebugUtilsLabelEXT           : extern "C" fn(VkCommandBuffer, *const VkDebugUtilsLabelEXT) -> (),
	#[cfg(feature = "VK_AMD_buffer_marker")]
	pfn_vkCmdWriteBufferMarkerAMD               : extern "C" fn(VkCommandBuffer, VkPipelineStageFlagBits, VkBuffer, VkDeviceSize, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkCmdBeginRenderPass2                   : extern "C" fn(VkCommandBuffer, *const VkRenderPassBeginInfo, *const VkSubpassBeginInfo) -> (),
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pfn_vkCmdBeginRenderPass2KHR                : extern "C" fn(VkCommandBuffer, *const VkRenderPassBeginInfo, *const VkSubpassBeginInfo) -> (),
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkCmdNextSubpass2                       : extern "C" fn(VkCommandBuffer, *const VkSubpassBeginInfo, *const VkSubpassEndInfo) -> (),
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pfn_vkCmdNextSubpass2KHR                    : extern "C" fn(VkCommandBuffer, *const VkSubpassBeginInfo, *const VkSubpassEndInfo) -> (),
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkCmdEndRenderPass2                     : extern "C" fn(VkCommandBuffer, *const VkSubpassEndInfo) -> (),
	#[cfg(feature = "VK_KHR_create_renderpass2")]
	pfn_vkCmdEndRenderPass2KHR                  : extern "C" fn(VkCommandBuffer, *const VkSubpassEndInfo) -> (),
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkCmdDrawIndirectCount                  : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_KHR_draw_indirect_count")]
	pfn_vkCmdDrawIndirectCountKHR               : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_AMD_draw_indirect_count")]
	pfn_vkCmdDrawIndirectCountAMD               : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_VERSION_1_2")]
	pfn_vkCmdDrawIndexedIndirectCount           : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_KHR_draw_indirect_count")]
	pfn_vkCmdDrawIndexedIndirectCountKHR        : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_AMD_draw_indirect_count")]
	pfn_vkCmdDrawIndexedIndirectCountAMD        : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
	pfn_vkCmdSetCheckpointNV                    : extern "C" fn(VkCommandBuffer, *const ()) -> (),
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pfn_vkCmdBindTransformFeedbackBuffersEXT    : extern "C" fn(VkCommandBuffer, u32, u32, *const VkBuffer, *const VkDeviceSize, *const VkDeviceSize) -> (),
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pfn_vkCmdBeginTransformFeedbackEXT          : extern "C" fn(VkCommandBuffer, u32, u32, *const VkBuffer, *const VkDeviceSize) -> (),
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pfn_vkCmdEndTransformFeedbackEXT            : extern "C" fn(VkCommandBuffer, u32, u32, *const VkBuffer, *const VkDeviceSize) -> (),
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pfn_vkCmdBeginQueryIndexedEXT               : extern "C" fn(VkCommandBuffer, VkQueryPool, u32, VkQueryControlFlags, u32) -> (),
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pfn_vkCmdEndQueryIndexedEXT                 : extern "C" fn(VkCommandBuffer, VkQueryPool, u32, u32) -> (),
	#[cfg(feature = "VK_EXT_transform_feedback")]
	pfn_vkCmdDrawIndirectByteCountEXT           : extern "C" fn(VkCommandBuffer, u32, u32, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_NV_scissor_exclusive")]
	pfn_vkCmdSetExclusiveScissorNV              : extern "C" fn(VkCommandBuffer, u32, u32, *const VkRect2D) -> (),
	#[cfg(feature = "VK_NV_shading_rate_image")]
	pfn_vkCmdBindShadingRateImageNV             : extern "C" fn(VkCommandBuffer, VkImageView, VkImageLayout) -> (),
	#[cfg(feature = "VK_NV_shading_rate_image")]
	pfn_vkCmdSetViewportShadingRatePaletteNV    : extern "C" fn(VkCommandBuffer, u32, u32, *const VkShadingRatePaletteNV) -> (),
	#[cfg(feature = "VK_NV_shading_rate_image")]
	pfn_vkCmdSetCoarseSampleOrderNV             : extern "C" fn(VkCommandBuffer, VkCoarseSampleOrderTypeNV, u32, *const VkCoarseSampleOrderCustomNV) -> (),
	#[cfg(feature = "VK_NV_mesh_shader")]
	pfn_vkCmdDrawMeshTasksNV                    : extern "C" fn(VkCommandBuffer, u32, u32) -> (),
	#[cfg(feature = "VK_NV_mesh_shader")]
	pfn_vkCmdDrawMeshTasksIndirectNV            : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_NV_mesh_shader")]
	pfn_vkCmdDrawMeshTasksIndirectCountNV       : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCmdCopyAccelerationStructureNV        : extern "C" fn(VkCommandBuffer, VkAccelerationStructureNV, VkAccelerationStructureNV, VkCopyAccelerationStructureModeKHR) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCmdCopyAccelerationStructureKHR       : extern "C" fn(VkCommandBuffer, *const VkCopyAccelerationStructureInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCmdCopyAccelerationStructureToMemoryKHR: extern "C" fn(VkCommandBuffer, *const VkCopyAccelerationStructureToMemoryInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCmdCopyMemoryToAccelerationStructureKHR: extern "C" fn(VkCommandBuffer, *const VkCopyMemoryToAccelerationStructureInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCmdWriteAccelerationStructuresPropertiesKHR: extern "C" fn(VkCommandBuffer, u32, *const VkAccelerationStructureKHR, VkQueryType, VkQueryPool, u32) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCmdWriteAccelerationStructuresPropertiesNV: extern "C" fn(VkCommandBuffer, u32, *const VkAccelerationStructureNV, VkQueryType, VkQueryPool, u32) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCmdBuildAccelerationStructureNV       : extern "C" fn(VkCommandBuffer, *const VkAccelerationStructureInfoNV, VkBuffer, VkDeviceSize, VkBool32, VkAccelerationStructureNV, VkAccelerationStructureNV, VkBuffer, VkDeviceSize) -> (),
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkCmdTraceRaysKHR                       : extern "C" fn(VkCommandBuffer, *const VkStridedDeviceAddressRegionKHR, *const VkStridedDeviceAddressRegionKHR, *const VkStridedDeviceAddressRegionKHR, *const VkStridedDeviceAddressRegionKHR, u32, u32, u32) -> (),
	#[cfg(feature = "VK_NV_ray_tracing")]
	pfn_vkCmdTraceRaysNV                        : extern "C" fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, u32, u32, u32) -> (),
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkCmdTraceRaysIndirectKHR               : extern "C" fn(VkCommandBuffer, *const VkStridedDeviceAddressRegionKHR, *const VkStridedDeviceAddressRegionKHR, *const VkStridedDeviceAddressRegionKHR, *const VkStridedDeviceAddressRegionKHR, VkDeviceAddress) -> (),
	#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
	pfn_vkCmdSetRayTracingPipelineStackSizeKHR  : extern "C" fn(VkCommandBuffer, u32) -> (),
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkCmdSetPerformanceMarkerINTEL          : extern "C" fn(VkCommandBuffer, *const VkPerformanceMarkerInfoINTEL) -> VkResult,
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkCmdSetPerformanceStreamMarkerINTEL    : extern "C" fn(VkCommandBuffer, *const VkPerformanceStreamMarkerInfoINTEL) -> VkResult,
	#[cfg(feature = "VK_INTEL_performance_query")]
	pfn_vkCmdSetPerformanceOverrideINTEL        : extern "C" fn(VkCommandBuffer, *const VkPerformanceOverrideInfoINTEL) -> VkResult,
	#[cfg(feature = "VK_EXT_line_rasterization")]
	pfn_vkCmdSetLineStippleEXT                  : extern "C" fn(VkCommandBuffer, u32, u16) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCmdBuildAccelerationStructuresKHR     : extern "C" fn(VkCommandBuffer, u32, *const VkAccelerationStructureBuildGeometryInfoKHR, *const *const VkAccelerationStructureBuildRangeInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_acceleration_structure")]
	pfn_vkCmdBuildAccelerationStructuresIndirectKHR: extern "C" fn(VkCommandBuffer, u32, *const VkAccelerationStructureBuildGeometryInfoKHR, *const VkDeviceAddress, *const u32, *const *const u32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetCullModeEXT                     : extern "C" fn(VkCommandBuffer, VkCullModeFlags) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetFrontFaceEXT                    : extern "C" fn(VkCommandBuffer, VkFrontFace) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetPrimitiveTopologyEXT            : extern "C" fn(VkCommandBuffer, VkPrimitiveTopology) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetViewportWithCountEXT            : extern "C" fn(VkCommandBuffer, u32, *const VkViewport) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetScissorWithCountEXT             : extern "C" fn(VkCommandBuffer, u32, *const VkRect2D) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdBindVertexBuffers2EXT              : extern "C" fn(VkCommandBuffer, u32, u32, *const VkBuffer, *const VkDeviceSize, *const VkDeviceSize, *const VkDeviceSize) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetDepthTestEnableEXT              : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetDepthWriteEnableEXT             : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetDepthCompareOpEXT               : extern "C" fn(VkCommandBuffer, VkCompareOp) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetDepthBoundsTestEnableEXT        : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetStencilTestEnableEXT            : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state")]
	pfn_vkCmdSetStencilOpEXT                    : extern "C" fn(VkCommandBuffer, VkStencilFaceFlags, VkStencilOp, VkStencilOp, VkStencilOp, VkCompareOp) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pfn_vkCmdSetPatchControlPointsEXT           : extern "C" fn(VkCommandBuffer, u32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pfn_vkCmdSetRasterizerDiscardEnableEXT      : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pfn_vkCmdSetDepthBiasEnableEXT              : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pfn_vkCmdSetLogicOpEXT                      : extern "C" fn(VkCommandBuffer, VkLogicOp) -> (),
	#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
	pfn_vkCmdSetPrimitiveRestartEnableEXT       : extern "C" fn(VkCommandBuffer, VkBool32) -> (),
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pfn_vkCmdCopyBuffer2KHR                     : extern "C" fn(VkCommandBuffer, *const VkCopyBufferInfo2KHR) -> (),
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pfn_vkCmdCopyImage2KHR                      : extern "C" fn(VkCommandBuffer, *const VkCopyImageInfo2KHR) -> (),
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pfn_vkCmdBlitImage2KHR                      : extern "C" fn(VkCommandBuffer, *const VkBlitImageInfo2KHR) -> (),
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pfn_vkCmdCopyBufferToImage2KHR              : extern "C" fn(VkCommandBuffer, *const VkCopyBufferToImageInfo2KHR) -> (),
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pfn_vkCmdCopyImageToBuffer2KHR              : extern "C" fn(VkCommandBuffer, *const VkCopyImageToBufferInfo2KHR) -> (),
	#[cfg(feature = "VK_KHR_copy_commands2")]
	pfn_vkCmdResolveImage2KHR                   : extern "C" fn(VkCommandBuffer, *const VkResolveImageInfo2KHR) -> (),
	#[cfg(feature = "VK_KHR_fragment_shading_rate")]
	pfn_vkCmdSetFragmentShadingRateKHR          : extern "C" fn(VkCommandBuffer, *const VkExtent2D, [VkFragmentShadingRateCombinerOpKHR;  2 as usize]) -> (),
	#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
	pfn_vkCmdSetFragmentShadingRateEnumNV       : extern "C" fn(VkCommandBuffer, VkFragmentShadingRateNV, [VkFragmentShadingRateCombinerOpKHR;  2 as usize]) -> (),
	#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
	pfn_vkCmdSetVertexInputEXT                  : extern "C" fn(VkCommandBuffer, u32, *const VkVertexInputBindingDescription2EXT, u32, *const VkVertexInputAttributeDescription2EXT) -> (),
	#[cfg(feature = "VK_EXT_color_write_enable")]
	pfn_vkCmdSetColorWriteEnableEXT             : extern "C" fn(VkCommandBuffer, u32, *const VkBool32) -> (),
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkCmdSetEvent2KHR                       : extern "C" fn(VkCommandBuffer, VkEvent, *const VkDependencyInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkCmdResetEvent2KHR                     : extern "C" fn(VkCommandBuffer, VkEvent, VkPipelineStageFlags2KHR) -> (),
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkCmdWaitEvents2KHR                     : extern "C" fn(VkCommandBuffer, u32, *const VkEvent, *const VkDependencyInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkCmdPipelineBarrier2KHR                : extern "C" fn(VkCommandBuffer, *const VkDependencyInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkCmdWriteTimestamp2KHR                 : extern "C" fn(VkCommandBuffer, VkPipelineStageFlags2KHR, VkQueryPool, u32) -> (),
	#[cfg(feature = "VK_KHR_synchronization2")]
	pfn_vkCmdWriteBufferMarker2AMD              : extern "C" fn(VkCommandBuffer, VkPipelineStageFlags2KHR, VkBuffer, VkDeviceSize, u32) -> (),
	#[cfg(feature = "VK_KHR_video_decode_queue")]
	pfn_vkCmdDecodeVideoKHR                     : extern "C" fn(VkCommandBuffer, *const VkVideoDecodeInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkCmdBeginVideoCodingKHR                : extern "C" fn(VkCommandBuffer, *const VkVideoBeginCodingInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkCmdControlVideoCodingKHR              : extern "C" fn(VkCommandBuffer, *const VkVideoCodingControlInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_video_queue")]
	pfn_vkCmdEndVideoCodingKHR                  : extern "C" fn(VkCommandBuffer, *const VkVideoEndCodingInfoKHR) -> (),
	#[cfg(feature = "VK_KHR_video_encode_queue")]
	pfn_vkCmdEncodeVideoKHR                     : extern "C" fn(VkCommandBuffer, *const VkVideoEncodeInfoKHR) -> (),
	#[cfg(feature = "VK_NVX_binary_import")]
	pfn_vkCmdCuLaunchKernelNVX                  : extern "C" fn(VkCommandBuffer, *const VkCuLaunchInfoNVX) -> (),
}

impl VkDeviceTable {
	fn load(handle: VkDevice, table: &VkInstanceTable) -> Arc<Self> {
		Arc::new(unsafe { Self {
			
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyDevice                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyDevice\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetDeviceQueue                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceQueue\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDeviceWaitIdle                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDeviceWaitIdle\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkAllocateMemory                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAllocateMemory\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkFreeMemory                                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkFreeMemory\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkMapMemory                                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkMapMemory\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkUnmapMemory                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkUnmapMemory\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkFlushMappedMemoryRanges                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkFlushMappedMemoryRanges\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkInvalidateMappedMemoryRanges                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkInvalidateMappedMemoryRanges\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetDeviceMemoryCommitment                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceMemoryCommitment\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetBufferMemoryRequirements                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferMemoryRequirements\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkBindBufferMemory                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindBufferMemory\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetImageMemoryRequirements                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageMemoryRequirements\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkBindImageMemory                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindImageMemory\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetImageSparseMemoryRequirements                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageSparseMemoryRequirements\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateFence                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateFence\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyFence                                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyFence\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkResetFences                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetFences\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetFenceStatus                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetFenceStatus\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkWaitForFences                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkWaitForFences\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateSemaphore                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateSemaphore\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroySemaphore                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroySemaphore\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateEvent                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateEvent\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyEvent                                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyEvent\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetEventStatus                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetEventStatus\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkSetEvent                                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSetEvent\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkResetEvent                                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetEvent\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateQueryPool                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateQueryPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyQueryPool                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyQueryPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetQueryPoolResults                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetQueryPoolResults\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkResetQueryPool                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetQueryPool\0".as_ptr())),
			#[cfg(feature = "VK_EXT_host_query_reset")]
			pfn_vkResetQueryPoolEXT                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetQueryPoolEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateBuffer                                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyBuffer                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateBufferView                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateBufferView\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyBufferView                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyBufferView\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateImage                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyImage                                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetImageSubresourceLayout                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageSubresourceLayout\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateImageView                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateImageView\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyImageView                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyImageView\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateShaderModule                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateShaderModule\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyShaderModule                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyShaderModule\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreatePipelineCache                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreatePipelineCache\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyPipelineCache                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyPipelineCache\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetPipelineCacheData                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPipelineCacheData\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkMergePipelineCaches                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkMergePipelineCaches\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateGraphicsPipelines                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateGraphicsPipelines\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateComputePipelines                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateComputePipelines\0".as_ptr())),
			#[cfg(feature = "VK_HUAWEI_subpass_shading")]
			pfn_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyPipeline                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyPipeline\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreatePipelineLayout                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreatePipelineLayout\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyPipelineLayout                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyPipelineLayout\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateSampler                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateSampler\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroySampler                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroySampler\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateDescriptorSetLayout                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateDescriptorSetLayout\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyDescriptorSetLayout                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyDescriptorSetLayout\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateDescriptorPool                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateDescriptorPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyDescriptorPool                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyDescriptorPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkResetDescriptorPool                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetDescriptorPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkAllocateDescriptorSets                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAllocateDescriptorSets\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkFreeDescriptorSets                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkFreeDescriptorSets\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkUpdateDescriptorSets                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkUpdateDescriptorSets\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateFramebuffer                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateFramebuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyFramebuffer                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyFramebuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateRenderPass                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateRenderPass\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyRenderPass                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyRenderPass\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkGetRenderAreaGranularity                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetRenderAreaGranularity\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCreateCommandPool                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateCommandPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkDestroyCommandPool                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyCommandPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkResetCommandPool                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetCommandPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkAllocateCommandBuffers                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAllocateCommandBuffers\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkFreeCommandBuffers                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkFreeCommandBuffers\0".as_ptr())),
			#[cfg(feature = "VK_KHR_display_swapchain")]
			pfn_vkCreateSharedSwapchainsKHR                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateSharedSwapchainsKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_swapchain")]
			pfn_vkCreateSwapchainKHR                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateSwapchainKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_swapchain")]
			pfn_vkDestroySwapchainKHR                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroySwapchainKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_swapchain")]
			pfn_vkGetSwapchainImagesKHR                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSwapchainImagesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_swapchain")]
			pfn_vkAcquireNextImageKHR                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAcquireNextImageKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_marker")]
			pfn_vkDebugMarkerSetObjectNameEXT                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDebugMarkerSetObjectNameEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_marker")]
			pfn_vkDebugMarkerSetObjectTagEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDebugMarkerSetObjectTagEXT\0".as_ptr())),
			#[cfg(feature = "VK_NV_external_memory_win32")]
			pfn_vkGetMemoryWin32HandleNV                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryWin32HandleNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_generated_commands")]
			pfn_vkGetGeneratedCommandsMemoryRequirementsNV                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetGeneratedCommandsMemoryRequirementsNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_generated_commands")]
			pfn_vkCreateIndirectCommandsLayoutNV                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateIndirectCommandsLayoutNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_generated_commands")]
			pfn_vkDestroyIndirectCommandsLayoutNV                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyIndirectCommandsLayoutNV\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkTrimCommandPool                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkTrimCommandPool\0".as_ptr())),
			#[cfg(feature = "VK_KHR_maintenance1")]
			pfn_vkTrimCommandPoolKHR                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkTrimCommandPoolKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_memory_win32")]
			pfn_vkGetMemoryWin32HandleKHR                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryWin32HandleKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_memory_win32")]
			pfn_vkGetMemoryWin32HandlePropertiesKHR                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryWin32HandlePropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_memory_fd")]
			pfn_vkGetMemoryFdKHR                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryFdKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_memory_fd")]
			pfn_vkGetMemoryFdPropertiesKHR                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryFdPropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_FUCHSIA_external_memory")]
			pfn_vkGetMemoryZirconHandleFUCHSIA                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryZirconHandleFUCHSIA\0".as_ptr())),
			#[cfg(feature = "VK_FUCHSIA_external_memory")]
			pfn_vkGetMemoryZirconHandlePropertiesFUCHSIA                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryZirconHandlePropertiesFUCHSIA\0".as_ptr())),
			#[cfg(feature = "VK_NV_external_memory_rdma")]
			pfn_vkGetMemoryRemoteAddressNV                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryRemoteAddressNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_semaphore_win32")]
			pfn_vkGetSemaphoreWin32HandleKHR                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSemaphoreWin32HandleKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_semaphore_win32")]
			pfn_vkImportSemaphoreWin32HandleKHR                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkImportSemaphoreWin32HandleKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_semaphore_fd")]
			pfn_vkGetSemaphoreFdKHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSemaphoreFdKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_semaphore_fd")]
			pfn_vkImportSemaphoreFdKHR                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkImportSemaphoreFdKHR\0".as_ptr())),
			#[cfg(feature = "VK_FUCHSIA_external_semaphore")]
			pfn_vkGetSemaphoreZirconHandleFUCHSIA                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSemaphoreZirconHandleFUCHSIA\0".as_ptr())),
			#[cfg(feature = "VK_FUCHSIA_external_semaphore")]
			pfn_vkImportSemaphoreZirconHandleFUCHSIA                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkImportSemaphoreZirconHandleFUCHSIA\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_fence_win32")]
			pfn_vkGetFenceWin32HandleKHR                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetFenceWin32HandleKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_fence_win32")]
			pfn_vkImportFenceWin32HandleKHR                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkImportFenceWin32HandleKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_fence_fd")]
			pfn_vkGetFenceFdKHR                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetFenceFdKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_external_fence_fd")]
			pfn_vkImportFenceFdKHR                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkImportFenceFdKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_display_control")]
			pfn_vkDisplayPowerControlEXT                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDisplayPowerControlEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_display_control")]
			pfn_vkRegisterDeviceEventEXT                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkRegisterDeviceEventEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_display_control")]
			pfn_vkRegisterDisplayEventEXT                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkRegisterDisplayEventEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_display_control")]
			pfn_vkGetSwapchainCounterEXT                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSwapchainCounterEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetDeviceGroupPeerMemoryFeatures                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceGroupPeerMemoryFeatures\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkGetDeviceGroupPeerMemoryFeaturesKHR                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceGroupPeerMemoryFeaturesKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkBindBufferMemory2                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindBufferMemory2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_bind_memory2")]
			pfn_vkBindBufferMemory2KHR                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindBufferMemory2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkBindImageMemory2                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindImageMemory2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_bind_memory2")]
			pfn_vkBindImageMemory2KHR                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindImageMemory2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkGetDeviceGroupPresentCapabilitiesKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceGroupPresentCapabilitiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkGetDeviceGroupSurfacePresentModesKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceGroupSurfacePresentModesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkAcquireNextImage2KHR                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAcquireNextImage2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkCreateDescriptorUpdateTemplate                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateDescriptorUpdateTemplate\0".as_ptr())),
			#[cfg(feature = "VK_KHR_descriptor_update_template")]
			pfn_vkCreateDescriptorUpdateTemplateKHR                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateDescriptorUpdateTemplateKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkDestroyDescriptorUpdateTemplate                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyDescriptorUpdateTemplate\0".as_ptr())),
			#[cfg(feature = "VK_KHR_descriptor_update_template")]
			pfn_vkDestroyDescriptorUpdateTemplateKHR                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyDescriptorUpdateTemplateKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkUpdateDescriptorSetWithTemplate                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkUpdateDescriptorSetWithTemplate\0".as_ptr())),
			#[cfg(feature = "VK_KHR_descriptor_update_template")]
			pfn_vkUpdateDescriptorSetWithTemplateKHR                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkUpdateDescriptorSetWithTemplateKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_hdr_metadata")]
			pfn_vkSetHdrMetadataEXT                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSetHdrMetadataEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_shared_presentable_image")]
			pfn_vkGetSwapchainStatusKHR                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSwapchainStatusKHR\0".as_ptr())),
			#[cfg(feature = "VK_GOOGLE_display_timing")]
			pfn_vkGetRefreshCycleDurationGOOGLE                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetRefreshCycleDurationGOOGLE\0".as_ptr())),
			#[cfg(feature = "VK_GOOGLE_display_timing")]
			pfn_vkGetPastPresentationTimingGOOGLE                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPastPresentationTimingGOOGLE\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetBufferMemoryRequirements2                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferMemoryRequirements2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_memory_requirements2")]
			pfn_vkGetBufferMemoryRequirements2KHR                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferMemoryRequirements2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetImageMemoryRequirements2                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageMemoryRequirements2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_memory_requirements2")]
			pfn_vkGetImageMemoryRequirements2KHR                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageMemoryRequirements2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetImageSparseMemoryRequirements2                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageSparseMemoryRequirements2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_get_memory_requirements2")]
			pfn_vkGetImageSparseMemoryRequirements2KHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageSparseMemoryRequirements2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkCreateSamplerYcbcrConversion                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateSamplerYcbcrConversion\0".as_ptr())),
			#[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
			pfn_vkCreateSamplerYcbcrConversionKHR                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateSamplerYcbcrConversionKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkDestroySamplerYcbcrConversion                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroySamplerYcbcrConversion\0".as_ptr())),
			#[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
			pfn_vkDestroySamplerYcbcrConversionKHR                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroySamplerYcbcrConversionKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetDeviceQueue2                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceQueue2\0".as_ptr())),
			#[cfg(feature = "VK_EXT_validation_cache")]
			pfn_vkCreateValidationCacheEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateValidationCacheEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_validation_cache")]
			pfn_vkDestroyValidationCacheEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyValidationCacheEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_validation_cache")]
			pfn_vkGetValidationCacheDataEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetValidationCacheDataEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_validation_cache")]
			pfn_vkMergeValidationCachesEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkMergeValidationCachesEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkGetDescriptorSetLayoutSupport                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDescriptorSetLayoutSupport\0".as_ptr())),
			#[cfg(feature = "VK_KHR_maintenance3")]
			pfn_vkGetDescriptorSetLayoutSupportKHR                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDescriptorSetLayoutSupportKHR\0".as_ptr())),
			pfn_vkGetSwapchainGrallocUsageANDROID                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSwapchainGrallocUsageANDROID\0".as_ptr())),
			pfn_vkGetSwapchainGrallocUsage2ANDROID                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSwapchainGrallocUsage2ANDROID\0".as_ptr())),
			pfn_vkAcquireImageANDROID                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAcquireImageANDROID\0".as_ptr())),
			#[cfg(feature = "VK_AMD_shader_info")]
			pfn_vkGetShaderInfoAMD                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetShaderInfoAMD\0".as_ptr())),
			#[cfg(feature = "VK_AMD_display_native_hdr")]
			pfn_vkSetLocalDimmingAMD                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSetLocalDimmingAMD\0".as_ptr())),
			#[cfg(feature = "VK_EXT_calibrated_timestamps")]
			pfn_vkGetCalibratedTimestampsEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetCalibratedTimestampsEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkSetDebugUtilsObjectNameEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSetDebugUtilsObjectNameEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkSetDebugUtilsObjectTagEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSetDebugUtilsObjectTagEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_external_memory_host")]
			pfn_vkGetMemoryHostPointerPropertiesEXT                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryHostPointerPropertiesEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkCreateRenderPass2                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateRenderPass2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_create_renderpass2")]
			pfn_vkCreateRenderPass2KHR                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateRenderPass2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkGetSemaphoreCounterValue                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSemaphoreCounterValue\0".as_ptr())),
			#[cfg(feature = "VK_KHR_timeline_semaphore")]
			pfn_vkGetSemaphoreCounterValueKHR                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetSemaphoreCounterValueKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkWaitSemaphores                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkWaitSemaphores\0".as_ptr())),
			#[cfg(feature = "VK_KHR_timeline_semaphore")]
			pfn_vkWaitSemaphoresKHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkWaitSemaphoresKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkSignalSemaphore                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSignalSemaphore\0".as_ptr())),
			#[cfg(feature = "VK_KHR_timeline_semaphore")]
			pfn_vkSignalSemaphoreKHR                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSignalSemaphoreKHR\0".as_ptr())),
			#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
			pfn_vkGetAndroidHardwareBufferPropertiesANDROID                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetAndroidHardwareBufferPropertiesANDROID\0".as_ptr())),
			#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
			pfn_vkGetMemoryAndroidHardwareBufferANDROID                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetMemoryAndroidHardwareBufferANDROID\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCompileDeferredNV                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCompileDeferredNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCreateAccelerationStructureNV                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateAccelerationStructureNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkDestroyAccelerationStructureKHR                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyAccelerationStructureKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkDestroyAccelerationStructureNV                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyAccelerationStructureNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkGetAccelerationStructureMemoryRequirementsNV              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetAccelerationStructureMemoryRequirementsNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkBindAccelerationStructureMemoryNV                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindAccelerationStructureMemoryNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCopyAccelerationStructureKHR                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCopyAccelerationStructureKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCopyAccelerationStructureToMemoryKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCopyAccelerationStructureToMemoryKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCopyMemoryToAccelerationStructureKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCopyMemoryToAccelerationStructureKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkWriteAccelerationStructuresPropertiesKHR                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkWriteAccelerationStructuresPropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkGetRayTracingShaderGroupHandlesKHR                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetRayTracingShaderGroupHandlesKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkGetRayTracingShaderGroupHandlesNV                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetRayTracingShaderGroupHandlesNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkGetAccelerationStructureHandleNV                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetAccelerationStructureHandleNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCreateRayTracingPipelinesNV                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateRayTracingPipelinesNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkCreateRayTracingPipelinesKHR                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateRayTracingPipelinesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkGetDeviceAccelerationStructureCompatibilityKHR            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceAccelerationStructureCompatibilityKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkGetRayTracingShaderGroupStackSizeKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetRayTracingShaderGroupStackSizeKHR\0".as_ptr())),
			#[cfg(feature = "VK_NVX_image_view_handle")]
			pfn_vkGetImageViewHandleNVX                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageViewHandleNVX\0".as_ptr())),
			#[cfg(feature = "VK_NVX_image_view_handle")]
			pfn_vkGetImageViewAddressNVX                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageViewAddressNVX\0".as_ptr())),
			#[cfg(feature = "VK_EXT_full_screen_exclusive")]
			pfn_vkGetDeviceGroupSurfacePresentModes2EXT                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceGroupSurfacePresentModes2EXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_full_screen_exclusive")]
			pfn_vkAcquireFullScreenExclusiveModeEXT                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAcquireFullScreenExclusiveModeEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_full_screen_exclusive")]
			pfn_vkReleaseFullScreenExclusiveModeEXT                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkReleaseFullScreenExclusiveModeEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_performance_query")]
			pfn_vkAcquireProfilingLockKHR                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAcquireProfilingLockKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_performance_query")]
			pfn_vkReleaseProfilingLockKHR                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkReleaseProfilingLockKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
			pfn_vkGetImageDrmFormatModifierPropertiesEXT                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetImageDrmFormatModifierPropertiesEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkGetBufferOpaqueCaptureAddress                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferOpaqueCaptureAddress\0".as_ptr())),
			#[cfg(feature = "VK_KHR_buffer_device_address")]
			pfn_vkGetBufferOpaqueCaptureAddressKHR                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferOpaqueCaptureAddressKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkGetBufferDeviceAddress                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferDeviceAddress\0".as_ptr())),
			#[cfg(feature = "VK_KHR_buffer_device_address")]
			pfn_vkGetBufferDeviceAddressKHR                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferDeviceAddressKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_buffer_device_address")]
			pfn_vkGetBufferDeviceAddressEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetBufferDeviceAddressEXT\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkInitializePerformanceApiINTEL                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkInitializePerformanceApiINTEL\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkUninitializePerformanceApiINTEL                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkUninitializePerformanceApiINTEL\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkAcquirePerformanceConfigurationINTEL                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkAcquirePerformanceConfigurationINTEL\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkReleasePerformanceConfigurationINTEL                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkReleasePerformanceConfigurationINTEL\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkGetPerformanceParameterINTEL                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPerformanceParameterINTEL\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkGetDeviceMemoryOpaqueCaptureAddress                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceMemoryOpaqueCaptureAddress\0".as_ptr())),
			#[cfg(feature = "VK_KHR_buffer_device_address")]
			pfn_vkGetDeviceMemoryOpaqueCaptureAddressKHR                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeviceMemoryOpaqueCaptureAddressKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
			pfn_vkGetPipelineExecutablePropertiesKHR                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPipelineExecutablePropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
			pfn_vkGetPipelineExecutableStatisticsKHR                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPipelineExecutableStatisticsKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
			pfn_vkGetPipelineExecutableInternalRepresentationsKHR           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPipelineExecutableInternalRepresentationsKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCreateAccelerationStructureKHR                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateAccelerationStructureKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkBuildAccelerationStructuresKHR                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBuildAccelerationStructuresKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkGetAccelerationStructureDeviceAddressKHR                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetAccelerationStructureDeviceAddressKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_deferred_host_operations")]
			pfn_vkCreateDeferredOperationKHR                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateDeferredOperationKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_deferred_host_operations")]
			pfn_vkDestroyDeferredOperationKHR                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyDeferredOperationKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_deferred_host_operations")]
			pfn_vkGetDeferredOperationMaxConcurrencyKHR                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeferredOperationMaxConcurrencyKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_deferred_host_operations")]
			pfn_vkGetDeferredOperationResultKHR                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetDeferredOperationResultKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_deferred_host_operations")]
			pfn_vkDeferredOperationJoinKHR                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDeferredOperationJoinKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_private_data")]
			pfn_vkCreatePrivateDataSlotEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreatePrivateDataSlotEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_private_data")]
			pfn_vkDestroyPrivateDataSlotEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyPrivateDataSlotEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_private_data")]
			pfn_vkSetPrivateDataEXT                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkSetPrivateDataEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_private_data")]
			pfn_vkGetPrivateDataEXT                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetPrivateDataEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkGetAccelerationStructureBuildSizesKHR                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetAccelerationStructureBuildSizesKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkCreateVideoSessionKHR                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateVideoSessionKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkDestroyVideoSessionKHR                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyVideoSessionKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkCreateVideoSessionParametersKHR                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateVideoSessionParametersKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkUpdateVideoSessionParametersKHR                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkUpdateVideoSessionParametersKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkDestroyVideoSessionParametersKHR                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyVideoSessionParametersKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkGetVideoSessionMemoryRequirementsKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetVideoSessionMemoryRequirementsKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkBindVideoSessionMemoryKHR                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBindVideoSessionMemoryKHR\0".as_ptr())),
			#[cfg(feature = "VK_NVX_binary_import")]
			pfn_vkCreateCuModuleNVX                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateCuModuleNVX\0".as_ptr())),
			#[cfg(feature = "VK_NVX_binary_import")]
			pfn_vkCreateCuFunctionNVX                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCreateCuFunctionNVX\0".as_ptr())),
			#[cfg(feature = "VK_NVX_binary_import")]
			pfn_vkDestroyCuModuleNVX                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyCuModuleNVX\0".as_ptr())),
			#[cfg(feature = "VK_NVX_binary_import")]
			pfn_vkDestroyCuFunctionNVX                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkDestroyCuFunctionNVX\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkQueueSubmit                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueSubmit\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkQueueWaitIdle                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueWaitIdle\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkQueueBindSparse                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueBindSparse\0".as_ptr())),
			#[cfg(feature = "VK_KHR_swapchain")]
			pfn_vkQueuePresentKHR                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueuePresentKHR\0".as_ptr())),
			pfn_vkQueueSignalReleaseImageANDROID                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueSignalReleaseImageANDROID\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkQueueBeginDebugUtilsLabelEXT                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueBeginDebugUtilsLabelEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkQueueEndDebugUtilsLabelEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueEndDebugUtilsLabelEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkQueueInsertDebugUtilsLabelEXT                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueInsertDebugUtilsLabelEXT\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
			pfn_vkGetQueueCheckpointDataNV                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetQueueCheckpointDataNV\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkQueueSetPerformanceConfigurationINTEL                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueSetPerformanceConfigurationINTEL\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkQueueSubmit2KHR                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkQueueSubmit2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkGetQueueCheckpointData2NV                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkGetQueueCheckpointData2NV\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkBeginCommandBuffer                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkBeginCommandBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkEndCommandBuffer                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkEndCommandBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkResetCommandBuffer                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkResetCommandBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBindPipeline                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindPipeline\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetViewport                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetViewport\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetScissor                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetScissor\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetLineWidth                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetLineWidth\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetDepthBias                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthBias\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetBlendConstants                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetBlendConstants\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetDepthBounds                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthBounds\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetStencilCompareMask                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetStencilCompareMask\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetStencilWriteMask                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetStencilWriteMask\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetStencilReference                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetStencilReference\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBindDescriptorSets                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindDescriptorSets\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBindIndexBuffer                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindIndexBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBindVertexBuffers                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindVertexBuffers\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdDraw                                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDraw\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdDrawIndexed                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndexed\0".as_ptr())),
			#[cfg(feature = "VK_EXT_multi_draw")]
			pfn_vkCmdDrawMultiEXT                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawMultiEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_multi_draw")]
			pfn_vkCmdDrawMultiIndexedEXT                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawMultiIndexedEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdDrawIndirect                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndirect\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdDrawIndexedIndirect                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndexedIndirect\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdDispatch                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDispatch\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdDispatchIndirect                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDispatchIndirect\0".as_ptr())),
			#[cfg(feature = "VK_HUAWEI_subpass_shading")]
			pfn_vkCmdSubpassShadingHUAWEI                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSubpassShadingHUAWEI\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdCopyBuffer                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdCopyImage                                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBlitImage                                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBlitImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdCopyBufferToImage                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyBufferToImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdCopyImageToBuffer                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyImageToBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdUpdateBuffer                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdUpdateBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdFillBuffer                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdFillBuffer\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdClearColorImage                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdClearColorImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdClearDepthStencilImage                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdClearDepthStencilImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdClearAttachments                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdClearAttachments\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdResolveImage                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdResolveImage\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdSetEvent                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetEvent\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdResetEvent                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdResetEvent\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdWaitEvents                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWaitEvents\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdPipelineBarrier                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdPipelineBarrier\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBeginQuery                                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginQuery\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdEndQuery                                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndQuery\0".as_ptr())),
			#[cfg(feature = "VK_EXT_conditional_rendering")]
			pfn_vkCmdBeginConditionalRenderingEXT                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginConditionalRenderingEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_conditional_rendering")]
			pfn_vkCmdEndConditionalRenderingEXT                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndConditionalRenderingEXT\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdResetQueryPool                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdResetQueryPool\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdWriteTimestamp                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWriteTimestamp\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdCopyQueryPoolResults                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyQueryPoolResults\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdPushConstants                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdPushConstants\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdBeginRenderPass                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginRenderPass\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdNextSubpass                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdNextSubpass\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdEndRenderPass                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndRenderPass\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_0")]
			pfn_vkCmdExecuteCommands                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdExecuteCommands\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_marker")]
			pfn_vkCmdDebugMarkerBeginEXT                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDebugMarkerBeginEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_marker")]
			pfn_vkCmdDebugMarkerEndEXT                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDebugMarkerEndEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_marker")]
			pfn_vkCmdDebugMarkerInsertEXT                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDebugMarkerInsertEXT\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_generated_commands")]
			pfn_vkCmdExecuteGeneratedCommandsNV                             : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdExecuteGeneratedCommandsNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_generated_commands")]
			pfn_vkCmdPreprocessGeneratedCommandsNV                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdPreprocessGeneratedCommandsNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_generated_commands")]
			pfn_vkCmdBindPipelineShaderGroupNV                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindPipelineShaderGroupNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_push_descriptor")]
			pfn_vkCmdPushDescriptorSetKHR                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdPushDescriptorSetKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkCmdSetDeviceMask                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDeviceMask\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkCmdSetDeviceMaskKHR                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDeviceMaskKHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_1")]
			pfn_vkCmdDispatchBase                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDispatchBase\0".as_ptr())),
			#[cfg(feature = "VK_KHR_device_group")]
			pfn_vkCmdDispatchBaseKHR                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDispatchBaseKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_descriptor_update_template")]
			pfn_vkCmdPushDescriptorSetWithTemplateKHR                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdPushDescriptorSetWithTemplateKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_clip_space_w_scaling")]
			pfn_vkCmdSetViewportWScalingNV                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetViewportWScalingNV\0".as_ptr())),
			#[cfg(feature = "VK_EXT_discard_rectangles")]
			pfn_vkCmdSetDiscardRectangleEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDiscardRectangleEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_sample_locations")]
			pfn_vkCmdSetSampleLocationsEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetSampleLocationsEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkCmdBeginDebugUtilsLabelEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginDebugUtilsLabelEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkCmdEndDebugUtilsLabelEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndDebugUtilsLabelEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_debug_utils")]
			pfn_vkCmdInsertDebugUtilsLabelEXT                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdInsertDebugUtilsLabelEXT\0".as_ptr())),
			#[cfg(feature = "VK_AMD_buffer_marker")]
			pfn_vkCmdWriteBufferMarkerAMD                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWriteBufferMarkerAMD\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkCmdBeginRenderPass2                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginRenderPass2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_create_renderpass2")]
			pfn_vkCmdBeginRenderPass2KHR                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginRenderPass2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkCmdNextSubpass2                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdNextSubpass2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_create_renderpass2")]
			pfn_vkCmdNextSubpass2KHR                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdNextSubpass2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkCmdEndRenderPass2                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndRenderPass2\0".as_ptr())),
			#[cfg(feature = "VK_KHR_create_renderpass2")]
			pfn_vkCmdEndRenderPass2KHR                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndRenderPass2KHR\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkCmdDrawIndirectCount                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndirectCount\0".as_ptr())),
			#[cfg(feature = "VK_KHR_draw_indirect_count")]
			pfn_vkCmdDrawIndirectCountKHR                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndirectCountKHR\0".as_ptr())),
			#[cfg(feature = "VK_AMD_draw_indirect_count")]
			pfn_vkCmdDrawIndirectCountAMD                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndirectCountAMD\0".as_ptr())),
			#[cfg(feature = "VK_VERSION_1_2")]
			pfn_vkCmdDrawIndexedIndirectCount                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndexedIndirectCount\0".as_ptr())),
			#[cfg(feature = "VK_KHR_draw_indirect_count")]
			pfn_vkCmdDrawIndexedIndirectCountKHR                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndexedIndirectCountKHR\0".as_ptr())),
			#[cfg(feature = "VK_AMD_draw_indirect_count")]
			pfn_vkCmdDrawIndexedIndirectCountAMD                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndexedIndirectCountAMD\0".as_ptr())),
			#[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
			pfn_vkCmdSetCheckpointNV                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetCheckpointNV\0".as_ptr())),
			#[cfg(feature = "VK_EXT_transform_feedback")]
			pfn_vkCmdBindTransformFeedbackBuffersEXT                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindTransformFeedbackBuffersEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_transform_feedback")]
			pfn_vkCmdBeginTransformFeedbackEXT                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginTransformFeedbackEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_transform_feedback")]
			pfn_vkCmdEndTransformFeedbackEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndTransformFeedbackEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_transform_feedback")]
			pfn_vkCmdBeginQueryIndexedEXT                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginQueryIndexedEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_transform_feedback")]
			pfn_vkCmdEndQueryIndexedEXT                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndQueryIndexedEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_transform_feedback")]
			pfn_vkCmdDrawIndirectByteCountEXT                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawIndirectByteCountEXT\0".as_ptr())),
			#[cfg(feature = "VK_NV_scissor_exclusive")]
			pfn_vkCmdSetExclusiveScissorNV                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetExclusiveScissorNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_shading_rate_image")]
			pfn_vkCmdBindShadingRateImageNV                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindShadingRateImageNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_shading_rate_image")]
			pfn_vkCmdSetViewportShadingRatePaletteNV                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetViewportShadingRatePaletteNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_shading_rate_image")]
			pfn_vkCmdSetCoarseSampleOrderNV                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetCoarseSampleOrderNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_mesh_shader")]
			pfn_vkCmdDrawMeshTasksNV                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawMeshTasksNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_mesh_shader")]
			pfn_vkCmdDrawMeshTasksIndirectNV                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawMeshTasksIndirectNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_mesh_shader")]
			pfn_vkCmdDrawMeshTasksIndirectCountNV                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDrawMeshTasksIndirectCountNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCmdCopyAccelerationStructureNV                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyAccelerationStructureNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCmdCopyAccelerationStructureKHR                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyAccelerationStructureKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCmdCopyAccelerationStructureToMemoryKHR                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyAccelerationStructureToMemoryKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCmdCopyMemoryToAccelerationStructureKHR                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyMemoryToAccelerationStructureKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCmdWriteAccelerationStructuresPropertiesKHR               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWriteAccelerationStructuresPropertiesKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCmdWriteAccelerationStructuresPropertiesNV                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWriteAccelerationStructuresPropertiesNV\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCmdBuildAccelerationStructureNV                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBuildAccelerationStructureNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkCmdTraceRaysKHR                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdTraceRaysKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_ray_tracing")]
			pfn_vkCmdTraceRaysNV                                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdTraceRaysNV\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkCmdTraceRaysIndirectKHR                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdTraceRaysIndirectKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
			pfn_vkCmdSetRayTracingPipelineStackSizeKHR                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetRayTracingPipelineStackSizeKHR\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkCmdSetPerformanceMarkerINTEL                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetPerformanceMarkerINTEL\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkCmdSetPerformanceStreamMarkerINTEL                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetPerformanceStreamMarkerINTEL\0".as_ptr())),
			#[cfg(feature = "VK_INTEL_performance_query")]
			pfn_vkCmdSetPerformanceOverrideINTEL                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetPerformanceOverrideINTEL\0".as_ptr())),
			#[cfg(feature = "VK_EXT_line_rasterization")]
			pfn_vkCmdSetLineStippleEXT                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetLineStippleEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCmdBuildAccelerationStructuresKHR                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBuildAccelerationStructuresKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_acceleration_structure")]
			pfn_vkCmdBuildAccelerationStructuresIndirectKHR                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBuildAccelerationStructuresIndirectKHR\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetCullModeEXT                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetCullModeEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetFrontFaceEXT                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetFrontFaceEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetPrimitiveTopologyEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetPrimitiveTopologyEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetViewportWithCountEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetViewportWithCountEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetScissorWithCountEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetScissorWithCountEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdBindVertexBuffers2EXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBindVertexBuffers2EXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetDepthTestEnableEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthTestEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetDepthWriteEnableEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthWriteEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetDepthCompareOpEXT                                   : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthCompareOpEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetDepthBoundsTestEnableEXT                            : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthBoundsTestEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetStencilTestEnableEXT                                : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetStencilTestEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state")]
			pfn_vkCmdSetStencilOpEXT                                        : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetStencilOpEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
			pfn_vkCmdSetPatchControlPointsEXT                               : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetPatchControlPointsEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
			pfn_vkCmdSetRasterizerDiscardEnableEXT                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetRasterizerDiscardEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
			pfn_vkCmdSetDepthBiasEnableEXT                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetDepthBiasEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
			pfn_vkCmdSetLogicOpEXT                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetLogicOpEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
			pfn_vkCmdSetPrimitiveRestartEnableEXT                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetPrimitiveRestartEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_copy_commands2")]
			pfn_vkCmdCopyBuffer2KHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyBuffer2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_copy_commands2")]
			pfn_vkCmdCopyImage2KHR                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyImage2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_copy_commands2")]
			pfn_vkCmdBlitImage2KHR                                          : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBlitImage2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_copy_commands2")]
			pfn_vkCmdCopyBufferToImage2KHR                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyBufferToImage2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_copy_commands2")]
			pfn_vkCmdCopyImageToBuffer2KHR                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCopyImageToBuffer2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_copy_commands2")]
			pfn_vkCmdResolveImage2KHR                                       : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdResolveImage2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_fragment_shading_rate")]
			pfn_vkCmdSetFragmentShadingRateKHR                              : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetFragmentShadingRateKHR\0".as_ptr())),
			#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
			pfn_vkCmdSetFragmentShadingRateEnumNV                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetFragmentShadingRateEnumNV\0".as_ptr())),
			#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
			pfn_vkCmdSetVertexInputEXT                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetVertexInputEXT\0".as_ptr())),
			#[cfg(feature = "VK_EXT_color_write_enable")]
			pfn_vkCmdSetColorWriteEnableEXT                                 : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetColorWriteEnableEXT\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkCmdSetEvent2KHR                                           : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdSetEvent2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkCmdResetEvent2KHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdResetEvent2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkCmdWaitEvents2KHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWaitEvents2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkCmdPipelineBarrier2KHR                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdPipelineBarrier2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkCmdWriteTimestamp2KHR                                     : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWriteTimestamp2KHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_synchronization2")]
			pfn_vkCmdWriteBufferMarker2AMD                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdWriteBufferMarker2AMD\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_decode_queue")]
			pfn_vkCmdDecodeVideoKHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdDecodeVideoKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkCmdBeginVideoCodingKHR                                    : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdBeginVideoCodingKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkCmdControlVideoCodingKHR                                  : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdControlVideoCodingKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_queue")]
			pfn_vkCmdEndVideoCodingKHR                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEndVideoCodingKHR\0".as_ptr())),
			#[cfg(feature = "VK_KHR_video_encode_queue")]
			pfn_vkCmdEncodeVideoKHR                                         : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdEncodeVideoKHR\0".as_ptr())),
			#[cfg(feature = "VK_NVX_binary_import")]
			pfn_vkCmdCuLaunchKernelNVX                                      : transmute((table.pfn_vkGetDeviceProcAddr)(handle, b"vkCmdCuLaunchKernelNVX\0".as_ptr())),
		} })
	}
}

impl fmt::Debug for VkDeviceTable {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceTable").finish()
	}
}

